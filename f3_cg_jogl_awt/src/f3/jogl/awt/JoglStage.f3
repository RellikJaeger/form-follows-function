package f3.jogl.awt;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.util.Bits;
import f3.media.scene.*;
import f3.media.input.*;
import java.awt.Frame;
import java.awt.geom.GeneralPath;
import java.awt.geom.AffineTransform;
import java.awt.BasicStroke;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.dnd.*;
import java.awt.datatransfer.*;
import java.awt.event.KeyEvent;
import javax.media.opengl.GLProfile;
import javax.media.opengl.GLContext;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLCapabilities;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.glu.GLU;
import javax.media.opengl.glu.gl2.GLUgl2;
import javax.media.opengl.awt.GLCanvas;
import java.lang.Math;
import com.jogamp.opengl.util.texture.awt.AWTTextureIO;
import com.jogamp.opengl.util.texture.Texture;
import com.jogamp.opengl.util.texture.TextureData;
import com.jogamp.opengl.util.texture.TextureIO;
import java.lang.IllegalStateException;
import java.nio.*;
import f3.media.scene.Shape2D;
import f3.media.scene.Shape2D.*;
import f3.media.scene.Shape2D.Path2D;
import f3.media.scene.Shape2D.Path2DFactory;
import f3.media.scene.MeshBuffer.*;
import f3.media.svg.SVG;
import com.jogamp.opengl.util.awt.TextureRenderer;
import f3.media.web.awesomium.AwesomiumWebBrowserFactory;

class JoglPath2D is Path2D {
    public var path is GeneralPath = new GeneralPath();
    override public function apply from (output is Path2D) to () 
    {
        const pi = path.getPathIterator(null);
        const coords = java.lang.reflect.Array.newInstance(java.lang.Float.TYPE, 6) as nativearray of Number;
        while (not pi.isDone()) {
            var seg = pi.currentSegment(coords);
            if (seg == java.awt.geom.PathIterator.SEG_MOVETO) {
                output.moveTo(coords[0], coords[1]);
            } else if (seg == java.awt.geom.PathIterator.SEG_LINETO) {
                output.lineTo(coords[0], coords[1]);
            } else if (seg == java.awt.geom.PathIterator.SEG_CUBICTO) {
                output.cubicTo(coords[0], coords[1], coords[2],coords[3], coords[4], coords[5]);
            } else if (seg == java.awt.geom.PathIterator.SEG_QUADTO) {
                output.quadTo(coords[0], coords[1], coords[2],coords[3]);
            } else if (seg == java.awt.geom.PathIterator.SEG_CLOSE) {
                output.closePath();
            }
        }
    }
    override public function moveTo from (x0 is Number, y0 is Number) to () {
        path.moveTo(x0, y0);
    }
    override public function lineTo from (x1 is Number, y1 is Number) to () {
        path.lineTo(x1, y1);
    }
    override public function quadTo from (cx1 is Number, cy1 is Number, x2 is Number, y2 is Number) to () 
    {
        path.quadTo(cx1, cy1, x2, y2);
    }
    override public function cubicTo 
	from (cx1 is Number, cy1 is Number, 
	      cx2 is Number, cy2 is Number,
	      x2 is Number, y2 is Number) 
	to () 
    {
        path.curveTo(cx1, cy1, cx2, cy2, x2, y2);
    }
    override public function closePath {
        path.closePath();
    }
    override public function reset {
        path = new GeneralPath();
    }
    override public function getBounds to Bounds {
        const bnds = path.getBounds2D();
        Bounds {
            center: point(bnds.getX()-bnds.getWidth()/2,
                             bnds.getY()-bnds.getHeight()/2,
                             0);
            extent: tuple(bnds.getWidth()/2, bnds.getHeight()/2, 0);
        }
    }
    override public function createStrokedShape from (stroke is Stroke) to Path2D 
    {
        var cap is Integer;
        var join is Integer;
        cap = 
            if (stroke.cap == Stroke.Cap.BUTT) then BasicStroke.CAP_BUTT 
                else if (stroke.cap == Stroke.Cap.SQUARE) then BasicStroke.CAP_SQUARE
                    else BasicStroke.CAP_ROUND;
        join = 
            if (stroke.join == Stroke.Join.BEVEL) then BasicStroke.JOIN_BEVEL 
                else if (stroke.join == Stroke.Join.MITER) then BasicStroke.JOIN_MITER
                    else BasicStroke.JOIN_ROUND;
        var bs = new BasicStroke(stroke.width, cap, join);
        var ss = bs.createStrokedShape(path);
        var gp is GeneralPath;
        if (ss instanceof GeneralPath){
            gp = ss as GeneralPath;
        } else {
            gp = new GeneralPath(ss);
        }
        JoglPath2D {
            path: gp;
        }
    }
    override public function contains from (x is Number, y is Number) to Boolean 
    {
        path.contains(x, y);
    }
    override public function createMesh to AbstractMesh 
    {
        const extrusion = new Jogl2DExtruder.Extrusion(path, false, 0);
        const md = extrusion.createMeshData();
        const mb = MeshBuffer {
            indexBuffer: md.getIndexBuffer();
            vertexBuffer: VertexAttributeBuffer { coordsPerVertex: 3, buffer: md.getVertexBuffer() }
            textureBuffers: VertexAttributeBuffer { coordsPerVertex: 2, buffer: md.getTextureBuffer(0) }
            normalBuffer: VertexAttributeBuffer { coordsPerVertex: 3, buffer: md.getNormalBuffer() }
        }
        return mb.toMesh();
    }
}

class JoglPath2DFactory extends Shape2D.Path2DFactory 
{
    override public function createPath to Path2D 
    {
        JoglPath2D {}
    }
}

const ThePath2DFactory = JoglPath2DFactory {};



function makeGradientShader(gl:GL2, grad:Shape2D.GradientPaint) {
    if (grad instanceof Shape2D.LinearGradient) {
        JoglLinearGradientShader {
            gl: gl;
            grad: grad;
        }
    } else{
        JoglRadialGradientShader {
            gl: gl;
            grad: grad;
        }
    }
}

class SceneRenderer2D 
{
    public var gl is GL2;
    public var glp is GLProfile;
    const tx = new java.awt.geom.AffineTransform();
    public var tex is JoglTexture;
    public var meshNode is MeshNode;
    var target is TextureRenderer;

    function applyTransform from (mat is Mat4) to () {
	tx.setTransform(mat.xx, mat.yx, mat.xy,
			mat.yy, mat.xz, mat.yz+target.getHeight());
    }

    function applyPaint from (g is java.awt.Graphics2D, paint is Shape2D.Paint) to () 
    {
	if (paint is Shape2D.ColorPaint) {
	    const cp = paint as Shape2D.ColorPaint;
	    var r = new java.awt.Color(cp.color.red,
				       cp.color.green,
				       cp.color.blue,
				       cp.color.opacity);
	    g.setPaint(r);
	}
    }

    function render2d from (camera is Camera2D, scene is Scene) to () 
    {
	const w = pot(scene.stage.width);
	const h = pot(scene.stage.height);
	if (target.getWidth() <> w or target.getHeight() <> h) {
	    target = new TextureRenderer(w, h, true);
	    tex == null;
	    meshNode = null;
	}
	const g = target.createGraphics();
	g.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
			   java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
	g.setBackground(new java.awt.Color(scene.background.red,
					   scene.background.green,
					   scene.background.blue,
					   scene.background.opacity));
	g.clearRect(0, 0, w, h);
	scene.root.foldLeft((), 
			    function from (_ is (), n is Node) to () 
			    {
				if (n is Shape2D.MeshNode2D) {
				    const shape = n as Shape2D.MeshNode2D;
				    const p = shape.path as JoglPath2D;
				    applyTransform(n.sceneTransform);
				    const saved = g.getTransform();
				    g.setTransform(tx);
				    applyPaint(g, shape.paint);
				    g.fill(p.path);
				    g.setTransform(saved);
				}
			    });
	target.markDirty(0, 0, w, h);
	target.getTexture();
	if (tex == null or meshNode == null) {
	    println("target texture {target.getTexture()}");
	    const texture = JoglTexture {
		gl: this.gl;
		tex: target.getTexture();
		id: scene.id;
	    }
	    tex = texture;
	    meshNode = MeshNode {
	       id: scene.id;
	       mesh: MeshBuffer.quad(w, h);
	       shader: TexturePaintShader 
	       {
		   color: Color.WHITE;
		   tex: texture;
	       }
	       override var transform = translate(w / 2.0, h / 2.0, 0);
	   }
	}
    }     
}

abstract class JoglGradientShader extends CGFXShader {
    public var gl is GL2;
    public var tex is Texture;
    public var grad is Shape2D.GradientPaint;
    public var transparent is Boolean = false;
    override function isTransparent() {transparent}
    override var technique = bind if (transparent) "Transparent" else "Opaque";
    var texture = JoglTexture {
        gl: bind gl;
        tex: bind tex;
    };
    var buf is ByteBuffer;
    var textureDirty = true;
    function toByte from (color is Number) to Byte {
        return Bits.bitAnd((color * 255) as Integer, 0xff);
    }

    function toInt from (color is Number) to Integer {
        return Bits.bitAnd((color * 255) as Integer, 0xff);
    }

    function updateTexture {
        if (tex == null) {
            tex = genTexture(gl, 16, 1);
            tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_EDGE);
            tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_EDGE);
        }
        if (buf == null) {
            buf = BufferUtils.createByteBuffer(16*4);
        }
        var hasTransparency = false;
        for (i in [0..<16]) {
            var color = grad.colors[i];
            if (color == null) {
                color = Color.BLACK;
            }
            var j = i * 4;
            var r = buf.get(j);
            var g = buf.get(j+1);
            var b = buf.get(j+2);
            var a = buf.get(j+3);
            var x = toByte(color.red);
            var y = toByte(color.green);
            var z = toByte(color.blue);
            var w = toByte(color.opacity);
            if (r != x or
                g != y or 
                b != z or 
                a != w) {
                textureDirty = true;
                buf.put(j, x);
                buf.put(j+1, y);
                buf.put(j+2, z);
                buf.put(j+3, w);
            }
            if (color.opacity != 1.0) {
                hasTransparency = true;
            }
        }
        if (textureDirty) {
            transparent = hasTransparency;
            textureDirty = false;
            var glp = GLProfile.get("GL2");
            println("updating gradient colors");
            tex.updateImage(gl, 
                            new TextureData(glp, 
                                            GL.GL_RGBA8, 
                                            16, 1,
                                            0,
                                            GL2.GL_RGBA,
                                            GL2.GL_UNSIGNED_BYTE,
                                            false, 
                                            false, 
                                            true, 
                                            buf, 
                                            null));
        }
        setParameter("colors", texture);
    }

    function updateParams from (mesh is AbstractMesh) to () {
        var x is Number;
        var y is Number;
        var w is Number;
        var h is Number;
        if (grad.proportional) {
            var bounds = mesh.bounds;
            x = bounds.center.x - bounds.extent.x;
            y = bounds.center.y - bounds.extent.y;
            w = bounds.extent.x * 2;
            h = bounds.extent.y * 2;
            if (w == 0 or h == 0)  {
                //                println("bounds={bounds}");
                w = h = 1;
            }
        } else {
            x = 0; y = 0; w = 1; h = 1
        }
        updateParams(x, y, w, h);
        for (i in [0..<4]) {
            var v = vector(grad.stops[i*4],
			   grad.stops[i*4+1],
			   grad.stops[i*4+2],
			   grad.stops[i*4+3]);
            setParameter("fractions{i+1}", v);
        }
        var scaleFactors = foreach (i in [0..<16]) 0.0;
        for (i in [0..<sizeof grad.stops-1]) {
            scaleFactors[i] = 1.0 / (grad.stops[i+1]-grad.stops[i]);
        }
        for (i in [0..<4]) {
            var v = vector(scaleFactors[i*4],
			   scaleFactors[i*4+1],
			   scaleFactors[i*4+2],
			   scaleFactors[i*4+3]);
            setParameter("scaleFactors{i+1}", v);
        }
    }

    protected abstract function updateParams(x is Number, y is Number, w is Number, h is Number) to ();

    override function apply from (mesh is AbstractMesh, 
				  worldTransform is  Mat4,
				  viewMatrix is  Mat4,
				  projectionMatrix is  Mat4) to ()
    {

        updateTexture();
        updateParams(mesh);
        super.apply(mesh, worldTransform, viewMatrix, projectionMatrix);
    }

}

class JoglRadialGradientShader extends JoglGradientShader {
    override var uvMap = [0];
    override var url = "{__DIR__}radialgradient.cgfx";
    override function updateParams(rx is Number, ry is Number, rw is Number, rh is Number) to () {
        var grad = this.grad as Shape2D.RadialGradient;
        var fx = grad.focusX;
        var fy = grad.focusY;
        var cx = fx;
        var cy = fy;
        var tcx = rx + cx * rw;
        var tcy = ry + cy * rh;
        var tfx = rx + fx * rw;
        var tfy = ry + fy * rh;
        var r = grad.radius;
        var tr  = r * Math.max(rw, rh);
        var focus = vector(tfx, tfy, 0);
        var gradientTransform = Mat4.<<1>> * grad.transform;
        focus = gradientTransform * focus;
        var t = 
            (gradientTransform * 
             translate(tcx, tcy) * 
             rotate(Math.toDegrees(Math.atan2(tfy-tcy, tfx-tcx))) *
             scale(tr, tr));
        try {
            t = t.inverse(); // t now maps from object space to unit circle
        } catch (e) {
            t = Mat4.<<1>>;
        }
        focus = t * focus;
        setParameter("objectSpaceToUnitCircle", t);
        setParameter("focus", focus);
    }
}

class JoglLinearGradientShader extends JoglGradientShader {

    override var url = "{__DIR__}lineargradient.cgfx";


    override function updateParams(rx is Number, ry is Number, rw is Number, rh is Number) to () 
    {
        var grad = this.grad as Shape2D.LinearGradient;
        var gradientTransform = grad.transform;
        var t = Mat4.<<1>> * grad.transform;

        var x1 = grad.x1;
        var y1 = grad.y1;
        var x2 = grad.x2;
        var y2 = grad.y2;

        var tx1 = rx + x1 * rw;
        var ty1 = ry + y1 * rh;
        var tx2 = rx + x2 * rw;
        var ty2 = ry + y2 * rh;

        // calculate plane equation constants
        var x = tx1;
        var y = ty1;
        t *= translate(x, y);

        // now gradient point 1 is at the origin
        x = tx2 - x;
        y = ty2 - y;

        t *= rotate(Math.toDegrees(Math.atan2(y, x)));

        var len = Math.sqrt(x*x + y*y) as Number;

        // now gradient point 2 is on the positive x-axis
        t *= scale(len, 1);

        // now gradient point 1 is at (0.0, 0), point 2 is at (1.0, 0)

        try {
            t = t.inverse();
        } catch (e) {
            t = Mat4.<<1>>
        }
        setParameter("toUnitX", t);
    }
}


class ColorPaintShader extends CGFXShader 
{
    public var colorPaint is ColorPaint;
    public readonly var color = bind colorPaint.color;
    override var url =  "{__DIR__}flat.cgfx";
    override var technique =  bind if (color.opacity == 1) "Opaque" else "Transparent";
    override function apply from 
	(mesh is AbstractMesh,
	 worldTransform is Mat4,
	 viewMatrix is Mat4,
	 projectionMatrix is Mat4) to () 
    {
        setParameter("diffuse", color);
        super.apply(mesh,
		    worldTransform,
                    viewMatrix,
                    projectionMatrix);
    }
}

class TexturePaintShader is CGFXShader 
{
    public var colorPaint is ColorPaint;
    public var tex is  AbstractTexture;
    public readonly var color = bind colorPaint.color;
    override var url =  "{__DIR__}flat-textured.cgfx";
    override var technique =  bind if (color.opacity == 1) "Opaque" else "Transparent";
    override var uvMap = [0];
    override function apply from (mesh is AbstractMesh,
				  worldTransform is  Mat4,
				  viewMatrix is  Mat4,
				  projectionMatrix is  Mat4) to () 
    {
        setParameter("diffuse", color);
        setParameter("texSampler0", tex);
        super.apply(mesh,
		    worldTransform,
                    viewMatrix,
                    projectionMatrix);
    }
}

function flatShader from (color is Color, tex is AbstractTexture) to Shader {
    var shader is CGFXShader;
    if (tex == null) {
        shader = CGFXShader {
            url: "{__DIR__}flat.cgfx";
            technique: bind if (color.opacity == 1) "Opaque" else "Transparent";
        }
    } else {
        shader = CGFXShader {
	    override var uvMap = [0];
            url: "{__DIR__}flat-textured.cgfx";
            //technique: bind if (color.opacity == 1) "Opaque" else "Transparent";
            override function apply from (mesh is AbstractMesh,
					  worldTransform is Mat4,
					  viewMatrix is Mat4,
					  projectionMatrix is Mat4) to () 
	    {
                var xywh = vector(0, 0, tex.getWidth(), tex.getHeight());
                shader.setParameter("xywh", xywh);
                super.apply(mesh, worldTransform, viewMatrix, projectionMatrix);
            }
        }
        shader.setParameter("texSampler0", tex);
    }
    shader.setParameter("diffuse", color);
    return shader;
}

function pot from (n is Integer) to Integer 
{
    var result = 2;
    while (result < n) {
        result *= 2;
    }
    return result;
}

const NUM_SAMPLES = java.lang.Integer.getInteger("numSamples", 8);
const SAMPLE_BUFFERS = NUM_SAMPLES <> 0;
const DEPTH_BITS = java.lang.Integer.getInteger("depthBits", 32);

class DefaultPhongShader is CGFXShader 
{
    public var lightScenePos is Point3 = Point3.<<0>>;
    override function apply
	from (mesh is AbstractMesh,
	      sceneTransform is Mat4,
	      viewMatrix is Mat4,
	      projectionMatrix is Mat4)
	to ()
    {
        setParameter("lightWorldPos", lightScenePos);
        super.apply(mesh, sceneTransform, viewMatrix, projectionMatrix);
    }
}

class DefaultPhongShader4 is CGFXShader 
{
    public var lightScenePos1 is Point3 = Point3.<<0>>;
    public var lightScenePos2 is Point3 = Point3.<<0>>;
    public var lightScenePos3 is Point3 = Point3.<<0>>;
    public var lightScenePos4 is Point3 = Point3.<<0>>;
    public var lightMask is Tuple4 = Tuple4.<<1>>;
    override function apply
	from (mesh is AbstractMesh,
	      sceneTransform is Mat4,
	      viewMatrix is Mat4,
	      projectionMatrix is Mat4)
	to ()
    {
        setParameter("lightWorldPos1", lightScenePos1);
        setParameter("lightWorldPos2", lightScenePos2);
        setParameter("lightWorldPos3", lightScenePos3);
        setParameter("lightWorldPos4", lightScenePos4);
        setParameter("lightMask", lightMask);
        super.apply(mesh, sceneTransform, viewMatrix, projectionMatrix);
    }
}

class JoglCGEffectLoader is CGEffectLoader 
{
    override public function loadDefaultShader(diffuseTexture is AbstractTexture,
                                               diffuse is Color,
                                               ambient is Color,
                                               emissive is Color,
                                               specular is Color,
                                               shininess is Number)
	to Shader 
    {
        var shader is CGFXShader;
        if (diffuseTexture == null) {
            shader = DefaultPhongShader4 { 
                url: "{__DIR__}phong4.cgfx";
                technique: if (diffuse.opacity == 1) "Opaque" else "Transparent";
                override function isTransparent():Boolean {
                    return diffuse.opacity <> 1;
                }
            }
        } else {
            shader = DefaultPhongShader4 { 
                url: "{__DIR__}phong4-textured.cgfx"
		uvMap: [0];
            }
            println("loading shader with texture {diffuseTexture}");
            shader.setParameter("texSampler0", diffuseTexture);
        }
        shader.setParameter("diffuse", diffuse);
        shader.setParameter("emissive", emissive);
        var ambientIntensity = 
	    vector(ambient.red, ambient.green, ambient.blue, ambient.opacity);
        const lightIntensity = Vec4.<<1>> - ambientIntensity;
        shader.setParameter("ambientIntensity", ambientIntensity);
        shader.setParameter("lightIntensity", lightIntensity);
        shader.setParameter("specular", specular);
        shader.setParameter("shininess", shininess);
        shader.setParameter("colorMult", Vec4.<<1>>);
        return shader;
    }

    override public function loadEffect
	from (url is String,
	      technique is String)
	to Shader
    {

        var result = CGFXShader {
            url: url;
            technique: technique;
        }
        return result;
    }
}


const ENABLE_VBOS = java.lang.Boolean.getBoolean("enable.vbos");

class MeshVBO {
    var gl is GL2;
    var indexBuffer is Integer;
    var vertexBuffer is Integer;
    var normalBuffer is Integer;
    var textureBuffers is Integer[];
    override function finalize() {
        org.f3.runtime.Entry.deferAction(java.lang.Runnable {
                override function run() {
                    var count = sizeof textureBuffers + 3;
                    var ids = BufferUtils.createIntBuffer(count);
                    ids.put(indexBuffer);
                    ids.put(vertexBuffer);
                    ids.put(normalBuffer);
                    for (i in textureBuffers) {
                        ids.put(i);
                    }
                    ids.flip();
                    gl.glDeleteBuffers(ids.remaining(), ids);
                }
            });
    }
}

var meshToVBO = new java.util.HashMap of (AbstractMesh, MeshVBO);

function bufferData
    from (gl is GL2, 
	  buffer is java.nio.FloatBuffer)
    to Integer 
{
    const ibuf = BufferUtils.createIntBuffer(1);
    gl.glGenBuffers(1, ibuf);
    const id = ibuf.get(0);
    buffer.rewind();
    gl.glBindBuffer(GL.GL_ARRAY_BUFFER, id);
    gl.glBufferData(GL.GL_ARRAY_BUFFER, buffer.limit() * 4,  buffer, GL.GL_STATIC_DRAW);
    gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0);
    return id;
}

function bufferData
    from (gl is GL2, 
	  buffer is java.nio.IntBuffer)
    to Integer 
{
    const ibuf = BufferUtils.createIntBuffer(1);
    gl.glGenBuffers(1, ibuf);
    const id = ibuf.get(0);
    buffer.rewind();
    gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, id);
    gl.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER, buffer.limit() * 4,  buffer, GL.GL_STATIC_DRAW);
    gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, 0);
    return id;
}

function getVBO
    from (gl is GL2, mesh is AbstractMesh)
    to MeshVBO 
{
    if (not ENABLE_VBOS) {
        return null;
    }
    var vb = meshToVBO.get(mesh) as MeshVBO;
    if (vb == null) {
        vb = MeshVBO {gl:gl};
        meshToVBO.put(mesh, vb);
        vb.indexBuffer = bufferData(gl, mesh.getIndexBuffer());
        vb.vertexBuffer = bufferData(gl, mesh.getVertexBuffer());
        vb.normalBuffer = bufferData(gl, mesh.getNormalBuffer());
        vb.textureBuffers = foreach (i in [0..<mesh.getTextureBuffers().size()]) {
            bufferData(gl, mesh.getTextureBuffers()[i]);
        };
    }
    return vb;
}

const DEBUG_USE_DEFAULT_SHADER = 
    java.lang.Boolean.getBoolean("debug.use.default.shader");

const SHADER_DEBUG = java.lang.Boolean.getBoolean("debug.cgfx");

function genTexture
    from (gl is GL2, width is Integer, height is Integer)
    to Texture 
{
    const ibuf = BufferUtils.createIntBuffer(1);
    gl.glGenTextures(ibuf.limit(), ibuf); 
    const id = ibuf.get(0);
    const glp = GLProfile.get("GL2");
    const tex = TextureIO.newTexture(id,
				     GL.GL_TEXTURE_2D,
				     width, height,
				     width, height,
				     false);
    tex.updateImage(gl, new TextureData(glp, 
                                        GL.GL_RGBA8, 
                                        width, height, 
                                        0,
                                        GL2.GL_RGBA,
                                        GL2.GL_UNSIGNED_BYTE,
                                        false, 
                                        false, 
                                        true, 
                                        null, 
                                        null));
    return tex;
}



class OffscreenSurface is JoglTexture 
{
    var sceneRenderer is SceneRenderer;
    override var tex = bind genTexture(gl, pot_width, pot_height);
    const _backgroundColor is Color;
    var _width is Integer = bind (width+0.5) as Integer;
    var _height is Integer = bind (height+0.5) as Integer;
    var pot_width = bind pot(_width);
    var pot_height = bind pot(_height);
    const _samples is Integer = 0;
    const _depthBits is Integer = 24;
    const _stencilBits is Integer = 8;
    var _fboID is Integer;
    var _depthRBID is Integer;
    var _msfboID is Integer;
    var _msDepthID is Integer;
    var _mscolorRBID is Integer;
    var _msdepthRBID is Integer;
    var lastTextureId is Integer;

    function activate to () 
    {
        // Lazy init
        if (_fboID == 0) {
            var ibuf = BufferUtils.createIntBuffer(1);
            gl.glGetIntegerv(gl.GL_MAX_SAMPLES, ibuf);
            var maxSamples = ibuf.get(0);
            var _samples = Math.min(this._samples, maxSamples);
            println("samples={this._samples} max={maxSamples}");
            var buffer = BufferUtils.createIntBuffer(1);
            // Create our texture binding FBO
            gl.glGenFramebuffers(1, buffer); // generate id
            _fboID = buffer.get(0);
            // Create a depth renderbuffer to use for RTT use
            gl.glGenRenderbuffers(1, buffer); // generate id
            _depthRBID = buffer.get(0);
            gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, _depthRBID);
            var format = GL2.GL_DEPTH_COMPONENT;
            if (_depthBits == 24 and _stencilBits == 8) {
                format = GL.GL_DEPTH24_STENCIL8;
            } else if (_depthBits == 16) {
                format = GL.GL_DEPTH_COMPONENT16;
            } else if (_depthBits == 24) {
                format = GL.GL_DEPTH_COMPONENT24;
            } else if (_depthBits == 32) {
                format = GL.GL_DEPTH_COMPONENT32;
            }
            gl.glRenderbufferStorage(GL.GL_RENDERBUFFER, format, pot_width, pot_height);
            // unbind...
            gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, 0);
            checkFBOComplete(_fboID);  
            // release
            gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, 0);
            // add multisample framebuffer + renderbuffers
            if (_samples <> 0) {
                // create ms framebuffer object
                gl.glGenFramebuffers(1, buffer);
                _msfboID = buffer.get(0);
                // create ms renderbuffers
                gl.glGenRenderbuffers(1, buffer); // generate id
                _mscolorRBID = buffer.get(0);
                gl.glGenRenderbuffers(1, buffer); // generate id
                _msdepthRBID = buffer.get(0);

                // set up renderbuffer properties
                gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, _mscolorRBID);
                gl.glRenderbufferStorageMultisample(GL.GL_RENDERBUFFER, 
                                                    _samples, GL.GL_RGBA, pot_width, pot_height);

                gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, _msdepthRBID);
                gl.glRenderbufferStorageMultisample(GL.GL_RENDERBUFFER, _samples, 
                                                    GL.GL_DEPTH24_STENCIL8, pot_width, pot_height);

                gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, 0);

                gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, _msfboID);
                gl.glFramebufferRenderbuffer(GL.GL_FRAMEBUFFER, GL.GL_COLOR_ATTACHMENT0,
                        GL.GL_RENDERBUFFER, _mscolorRBID);
                gl.glFramebufferRenderbuffer(GL.GL_FRAMEBUFFER, GL.GL_DEPTH_ATTACHMENT,
                        GL.GL_RENDERBUFFER, _msdepthRBID);
                // check for errors
                checkFBOComplete(_msfboID);

                // release
                gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, 0);
            }
        }
        bindFrameBuffer();
     }

    function bindFrameBuffer to ()
    {
         if (_samples > 0) {
            gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, _msfboID);
        } else {
            gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, _fboID);
        }
        gl.glViewport(0, 0, _width, _height);
    }

    function checkFBOComplete from (fboID is Integer) to ()
    {
        var status = gl.glCheckFramebufferStatus(GL.GL_FRAMEBUFFER);
        if (status == GL.GL_FRAMEBUFFER_COMPLETE) {
            
        } else if (status == GL.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT exception");
        } else if (status == GL.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT exception");
        } else if (status == GL.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS exception");
        } else if (status == GL2.GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER exception");
        } else if (status == GL.GL_FRAMEBUFFER_INCOMPLETE_FORMATS) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_FORMATS exception");
        } else if (status == GL2.GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER exception");
        } else if (status == GL.GL_FRAMEBUFFER_UNSUPPORTED) {
            throw new IllegalStateException("FrameBuffer {fboID} has caused a GL_FRAMEBUFFER_UNSUPPORTED exception");
        } else if (status == GL2.GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE exception.");
        }
    }

    function blitMSFBO to () 
    {
        if (_samples > 0) {
            gl.glBindFramebuffer(GL2.GL_READ_FRAMEBUFFER, _msfboID);
            gl.glBindFramebuffer(GL2.GL_DRAW_FRAMEBUFFER, _fboID);
            var bits is Integer = GL.GL_COLOR_BUFFER_BIT;
            if (_depthBits > 0) {
                bits = Bits.add(bits, GL.GL_DEPTH_BUFFER_BIT);
            }
            gl.glBlitFramebuffer(0, 0, _width, _height, 
                                 0, 0, pot_width, pot_height, 
                                 bits, GL.GL_LINEAR);

            println("blitting framebuffer {_msfboID} {_fboID} {_width} {_height} {pot_width} {pot_height}");
        }
        if (false) {
            tex.bind(gl);
            gl.glGenerateMipmap(tex.getTarget());
        }
        gl.glBindFramebuffer(GL2.GL_READ_FRAMEBUFFER, 0);
        gl.glBindFramebuffer(GL2.GL_DRAW_FRAMEBUFFER, 0);
        gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, 0);
    }

    function cleanup to () 
    {
        if (_fboID <> 0) {
            const id = BufferUtils.createIntBuffer(1);
            id.put(_fboID);
            id.rewind();
            gl.glDeleteFramebuffers(id.limit(), id);
        }

        if (_msdepthRBID <> 0) {
            const id = BufferUtils.createIntBuffer(1);
            id.put(_depthRBID);
            id.rewind();
            gl.glDeleteRenderbuffers(id.limit(), id);
        }
    }

    function setupForDraw to ()
    {
        const textureId = tex.getTextureObject(gl);
        if (lastTextureId <> 0 and lastTextureId <> textureId) {
            var ibuf = BufferUtils.createIntBuffer(1);
            ibuf.clear();
            ibuf.put(lastTextureId);
            ibuf.rewind();
            gl.glDeleteTextures(1, ibuf);
        }
        lastTextureId = textureId;
        gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, _fboID);
        gl.glFramebufferTexture2D(GL.GL_FRAMEBUFFER, 
                                  GL.GL_COLOR_ATTACHMENT0, 
                                  GL.GL_TEXTURE_2D, textureId, 0);
        if (_depthBits > 0) {
            gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER,
                                         gl.GL_DEPTH_ATTACHMENT,
                                         gl.GL_RENDERBUFFER,
                                         _depthRBID);
        }
        gl.glDrawBuffer(GL.GL_COLOR_ATTACHMENT0);
        gl.glReadBuffer(GL.GL_COLOR_ATTACHMENT0);
        if (_samples > 0) {
            gl.glBindFramebuffer(gl.GL_DRAW_FRAMEBUFFER, _msfboID);
            gl.glFramebufferRenderbuffer(gl.GL_DRAW_FRAMEBUFFER,
                                         gl.GL_COLOR_ATTACHMENT0,
                                         gl.GL_RENDERBUFFER,
                                         _mscolorRBID);
            if (_depthBits > 0) {
                gl.glFramebufferRenderbuffer(gl.GL_DRAW_FRAMEBUFFER,
                                             gl.GL_DEPTH_ATTACHMENT,
                                             gl.GL_RENDERBUFFER,
                                             _msdepthRBID);
                if (_stencilBits > 0) {
                    gl.glFramebufferRenderbuffer(gl.GL_DRAW_FRAMEBUFFER,
                                                 gl.GL_STENCIL_ATTACHMENT,
                                                 gl.GL_RENDERBUFFER,
                                                 _msdepthRBID);
                }
            }
        } 
        checkFBOComplete(_fboID);  
    }

    function renderScenes 
	from (gl is GL2, scenes is Scene[])
	to ()
    {
        push();
        setupForDraw();
        var dirty = false;
        for (scene in scenes where scene.visible) {
            if (sceneRenderer.renderScene(gl, scene, _width, _height, dirty)) {
                dirty = true;
            }
        }
        blitMSFBO();
        pop();
    }

    function push to ()
    {
        activate()
    }

    function pop to () 
    {
        sceneRenderer.parent.activate();        
    }

}

class JoglTexture is AbstractTexture 
{
    public const tex is Texture;
    public const gl is GL2;
    public const id is String;
    public var width = bind tex.getWidth();
    public var height = bind tex.getHeight();
    override function getTextureId to Integer 
    {
        tex.getTextureObject(gl);
    }
    override function toString to String 
    {
        "Texture {id}";
    }
    override function getWidth to Integer 
    {
	tex.getWidth()
    }
    override function getHeight to Integer 
    {
	tex.getHeight()
    }
}

class JoglImageLoader is ImageLoader {
    const glp is GLProfile = GLProfile.get("GL2");
    var gl is GL2;
    var loaded = new java.util.HashMap of (String, java.lang.ref.WeakReference of Texture);

    override public function loadImage from (url is String)
	to AbstractTexture 
    {
        try {
            var result = loadTexture2D0(url);
	    println("LOAD IMAGE {url} => {result}");
	    return result;
        } catch (t is java.lang.Throwable) {
            t.printStackTrace();
        }
        return null;
    }
    function loadTexture2D0
	from (url is String)
	to AbstractTexture 
    {
        //if (url.endsWith(".mp4") or url.endsWith(".mov") or url.endsWith(".wmv")) {
        //    return Movie {url: url};
	// }
        var ref = loaded.get(url) as java.lang.ref.WeakReference;
        var texture is Texture = ref.get() as Texture;
        if (texture == null) {
            if (true) {
                var im is java.awt.Image;
                var tWidth is Integer;
                var tHeight is Integer;
                var w is Integer;
                var h is Integer;
                if (url.endsWith(".png")) {
                    var decoder = new PNGDecoder(new java.io.BufferedInputStream(new java.net.URL(url).openStream()));
                    tWidth = decoder.getWidth();
                    tHeight = decoder.getHeight();
                    var buffer = BufferUtils.createByteBuffer(4*tWidth*tHeight);
                    decoder.decode(buffer, tWidth*4, 
                                   PNGDecoder.TextureFormat.RGBA);
                    w = pot(tWidth);
                    h = pot(tHeight);
                    if (w <> tWidth or h <> tHeight) {
                        var glu = new GLUgl2();
                        var potBuffer = BufferUtils.createByteBuffer(4*w*h);
                        buffer.rewind();
                        glu.gluScaleImage(GL.GL_RGBA, tWidth, tHeight,
                                          GL.GL_UNSIGNED_BYTE,
                                          buffer, w, h, GL.GL_UNSIGNED_BYTE,
                                          potBuffer);
                        buffer = potBuffer;
                    }
                    buffer.rewind();
                    texture = TextureIO.newTexture(new TextureData(glp,
                                                                   GL.GL_RGBA8,
                                                                   w, h,
                                                                   0,
                                                                   GL2.GL_RGBA,
                                                                   GL2.GL_UNSIGNED_BYTE,
                                                                   false,
                                                                   false,
                                                                   true,
                                                                   buffer,
                                                                   null));
                } else {
                    javax.imageio.ImageIO.setUseCache(false);
                    im = javax.imageio.ImageIO.read(new java.net.URL(url));
                    tWidth = im.getWidth(null);
                    tHeight = im.getHeight(null);
                    w = pot(tWidth);
                    h = pot(tHeight);
                    var tFlippedBufferedImage = 
                        new java.awt.image.BufferedImage(w, h,
                                                         java.awt.image.BufferedImage.TYPE_INT_ARGB);
                    var tG2D = tFlippedBufferedImage.createGraphics(); 
                    tG2D.drawImage(im,
                                   0, h, w, 0, 
                                   0, 0, tWidth, tHeight,
                                   null); 
                    tG2D.dispose(); 
                    texture = AWTTextureIO.newTexture(glp, tFlippedBufferedImage, true);
                }
                texture = TextureIO.newTexture(texture.getTextureObject(gl),
                                               texture.getTarget(),
                                               tWidth,
                                               tHeight,
                                               w,
                                               h,
                                               texture.getMustFlipVertically());
            } else {
                texture = TextureIO.newTexture(new java.net.URL(url), false, null);
            }
            println("loaded texture {url}");
            loaded.put(url, new java.lang.ref.WeakReference of Texture(texture));
        } else {
            texture = TextureIO.newTexture(texture.getTextureObject(gl),
                                           texture.getTarget(),
                                           texture.getWidth(),
                                           texture.getHeight(),
                                           texture.getImageWidth(),
                                           texture.getImageHeight(),
                                           texture.getMustFlipVertically());
        }
        texture.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_S, GL.GL_REPEAT);
        texture.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_T, GL.GL_REPEAT);
        texture.setTexParameteri(gl, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR);
        texture.setTexParameteri(gl, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);
        JoglTexture {
            id: url;
            gl: gl;
            tex: texture;
        }
    }
}

class SceneRenderer {

    public var parent is SceneRenderer;

    var phongShader is Shader;
    var transparentToDraw = new java.util.ArrayList of MeshNode;
    var opaqueToDraw = new java.util.ArrayList of MeshNode;

    var activate is function from () to ();

    function renderStageNode 
	from (gl is GL2, stageNode is StageNode)
	to ()
    {
        var surface = stageNode.drawingSurface as OffscreenSurface;
        if (surface == null) {
            surface = OffscreenSurface {
                gl: gl;
                sceneRenderer: SceneRenderer {
                }
                override var width = bind stageNode.width;
                override var height = bind stageNode.height;
            }
            surface.sceneRenderer.activate = surface.activate;
            stageNode.drawingSurface = surface;
        }
        surface.sceneRenderer.parent = this;
        surface.renderScenes(gl, stageNode.content);
    }

    var offscreenToRender = new java.util.HashSet of StageNode;
    var lastDrawn = new java.util.HashSet of MeshNode;
    var lightPositions is Point3[]; // hack
    var lastCamera is Camera;

    var renderer2D is java.util.Map of (Scene, SceneRenderer2D) = new java.util.WeakHashMap of (Scene, SceneRenderer2D) ;
    function getRenderer2D from (scene is Scene, gl is GL2) to SceneRenderer2D 
    {
	var r = renderer2D.get(scene);
	if (r == null) {
	    r = SceneRenderer2D {
		gl: gl;
		glp: GLProfile.get("GL2");
	    }
	    renderer2D.put(scene, r);
	}
	return r;
    }

    function renderScene
	from (gl is GL2, 
	      scene is Scene, 
	      width is Number, 
	      height is Number, 
	      dirty0 is Boolean)
	to Boolean
    {
        opaqueToDraw.clear();
        transparentToDraw.clear();
        offscreenToRender.clear();
        var opaqueTris = 0;
        var transparentTris = 0;
        var lights is PointLight[];
        var dirty = dirty0;
	//println("scene.root={scene.root} => {scene.content}");
	scene.update();
        const vf = function from (_ is (), n is Node) to () {
	    if (n.sceneTransform == null) {
		println("no scene transform: {n.id} => {n.sceneTransform} parent={n.parent.id}");
		return;
	    }
	    if (n.sceneVisible) {
		if (n is PointLight) {
		    insert (n as PointLight) into lights;
		}
		if (n is Shape2D.MeshNode2D){
		    var shape = n as Shape2D.MeshNode2D;
		    if (shape.shader == null) {
			if (shape.paint is Shape2D.ColorPaint) {
			    var paint = bind shape.paint as Shape2D.ColorPaint;
			    if (paint is Shape2D.TexturePaint) {
				var tex = 
				    bind (paint as Shape2D.TexturePaint).texture;
				shape.shader = TexturePaintShader {
				    color: bind paint.color;
				    tex: bind tex;
				}
			    } else {
				shape.shader = ColorPaintShader {
				    color: bind paint.color;
				}
			    }
			} else if (shape.paint is Shape2D.GradientPaint) {
			    const gradient = shape.paint as Shape2D.GradientPaint;
			    shape.shader = makeGradientShader(gl, gradient);
			}
			println("creating shader for {shape} => {shape.shader}");
			dirty = true;
		    }
		} 
		if (n is MeshNode) {
		    if (true or scene.camera.contains(n.sceneBounds)) {
			const mn = n as MeshNode;
			const shader = mn.shader;
			if (mn.shader <> null) {
			    for (p in (mn.shader as CGFXShader).parameters) {
				const value = (p as CGFXShader.Parameter of Object).get();
				if (value is StageNode) {
				    const stageNode = value as StageNode;
				    offscreenToRender.add(stageNode);
				}
			    }
			} 
			if (not dirty) {
			    dirty = true; //mn.shader.isDirty() or mn.needsDraw;
			}
			const tris = mn.mesh.getIndexBuffer().limit() / 3;
			if (shader.isTransparent()) {
			    transparentToDraw.add(mn);
			    transparentTris += tris;
			} else {
			    opaqueToDraw.add(mn);
			    opaqueTris += tris;
			}
			lastDrawn.remove(n);
		    } else {
		    //			println("culled {n} {n.id} {n.sceneBounds}");
			if (lastDrawn.remove(n)) {
			    dirty = true;
			}
		    }
		}
	    }
	};
        scene.updateCamera();
        offscreenToRender.clear();
	if (scene.camera instanceof Camera2D) {
	    const cam = scene.camera as Camera2D;
	    const r = getRenderer2D(scene, gl);
	    r.render2d(cam, scene);
	    opaqueToDraw.add(r.meshNode);
	} else {
	    scene.root.foldLeft((), vf);
	    for (i in offscreenToRender) {
		renderStageNode(gl, i as StageNode);
	    }
	}
        var camera = scene.camera;
        dirty = dirty or camera.needsDraw;
        dirty = dirty or lastDrawn.size() <> 0;
        lastDrawn.clear();
        lastDrawn.addAll(opaqueToDraw);
        lastDrawn.addAll(transparentToDraw);
        var positions is Point3[] = foreach (light in lights) light.location;
	//println("light positions = {positions}");
        if (positions <> lightPositions) {
            lightPositions = positions;
            dirty = true;
        }
        if (scene.camera <> lastCamera) {
            lastCamera = scene.camera;
            dirty = true;
        }
	dirty = true;
        if (not dirty) {
            return false;
        }
        gl.glViewport(0, 0, width, height);
        if (scene.background <> null) {
            var bg = scene.background;
	    //  println("clearing {bg} {java.lang.Thread.currentThread()}");
            gl.glClearColor(bg.red, bg.green, bg.blue, bg.opacity);
            gl.glClear(Bits.add(GL.GL_COLOR_BUFFER_BIT, GL.GL_DEPTH_BUFFER_BIT));
        } else {
	    if (false) {
		gl.glClearColor(1, 1, 1, 1);
		gl.glClear(Bits.add(GL.GL_COLOR_BUFFER_BIT, GL.GL_DEPTH_BUFFER_BIT));
	    } else {
		gl.glClear(GL.GL_DEPTH_BUFFER_BIT);
	    }
        }
        if (true) {
            if (true) {//not (camera instanceof Camera2D)) {
                // sort opaque front to back      
                java.util.Collections.sort(opaqueToDraw, java.util.Comparator of MeshNode {
                        override public function compare(x is MeshNode, y is MeshNode):Integer {
                            var xz = camera.distanceTo(x.sceneTransform.getTranslation());
                            var yz = camera.distanceTo(y.sceneTransform.getTranslation());
                            var cmp = xz - yz;
                            return if (cmp < 0) then -1 else if (cmp > 0) then 1 else 0;
                        }
                    });
                //sort transparent back to front
                java.util.Collections.sort(transparentToDraw, java.util.Comparator of MeshNode {
                        override public function compare(x is MeshNode, y is MeshNode):Integer {
                            var xz = camera.distanceTo(x.sceneTransform.getTranslation());
                            var yz = camera.distanceTo(y.sceneTransform.getTranslation());
                            var cmp = -(xz - yz);
                            return if (cmp < 0) then -1 else if (cmp > 0) then 1 else 0;
                        }
                    });
            }
        }
        onDraw(transparentToDraw.size(), transparentTris, opaqueToDraw.size(), opaqueTris);
        draw(gl, camera, opaqueToDraw, lightPositions);
        opaqueToDraw.clear();
        draw(gl, camera, transparentToDraw, lightPositions);
        transparentToDraw.clear();
        //camera.needsDraw = false;
        return true;
    }

    function onDraw 
	from (transparent is Integer, 
	      transpTris is Integer, 
	      opaque is Integer, 
	      opaqueTris is Integer)
	to ()
    {
    }

    var polygonMode = PolygonMode.Fill;

    function draw
	from (gl is GL2,
	      camera is Camera, 
	      toDraw is java.util.List of MeshNode, 
	      lights is Point3[])
	to ()
    {
        var cameraLight = camera.sceneTransform.getTranslation();
        for (n in toDraw) {
            var mn = n as MeshNode;
            var mesh = mn.mesh;
            var indexBuffer = mesh.getIndexBuffer();
            var vertexBuffer = mesh.getVertexBuffer();
            var normalBuffer = mesh.getNormalBuffer();
	    var badtex = false;
	    for (texb in mesh.getTextureBuffers()) {
	    	if (texb.limit() == 0) {
		    badtex = true;
		    println("bad texture coordinates in {mn}");
		}
	    }
	    if (badtex) {
		continue;
	    }
            var shader = mn.shader;
	    //println("shader={shader}");
            var texParams = 
		foreach (p in shader.getParameters() where p instanceof CGFXShader.SamplerParameter) p as CGFXShader.SamplerParameter;
            if (DEBUG_USE_DEFAULT_SHADER or shader == null) {
                if (phongShader == null) {
                    phongShader = (the CGEffectLoader).loadDefaultShader(null,
									 Color.GRAY,
									 Color.BLACK,
									 Color.BLACK,
									 Color.GRAY,
									 20);
                }
                shader = phongShader;
            }
            var vbo = getVBO(gl, mesh);
            vertexBuffer.rewind();
            gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
            if (vbo <> null) {
                gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vbo.vertexBuffer);
                gl.glVertexPointer(mesh.vertices.getCoordsPerVertex(), 
                                   GL.GL_FLOAT, 0, 0);
            } else {
                vertexBuffer.rewind();
                gl.glVertexPointer(mesh.vertices.getCoordsPerVertex(), 
                                   GL.GL_FLOAT, 0, vertexBuffer);
            }
            if (normalBuffer == null) {
                gl.glDisableClientState(GL2.GL_NORMAL_ARRAY);
            } else {
                gl.glEnableClientState(GL2.GL_NORMAL_ARRAY);
                if (vbo <> null) {
                    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, vbo.normalBuffer);
                    gl.glNormalPointer(GL.GL_FLOAT, 0, 0);
                } else {
                    normalBuffer.rewind();
                    gl.glNormalPointer(GL.GL_FLOAT, 0, normalBuffer);
                }
            }
	    const texUnits = shader.uvMap.size();
	    const coords = foreach (i in shader.uvMap) mesh.textureCoordinates[i];
	    for (unit in [0..<texUnits]) {
		var textureBuffer = mesh.getTextureBuffers()[shader.uvMap[unit]];
		gl.glClientActiveTexture(GL.GL_TEXTURE0+unit);
		if (textureBuffer <> null) {
		    gl.glEnableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
		    if (vbo <> null) {
			gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vbo.textureBuffers[unit]);
			gl.glTexCoordPointer(mesh.textureCoordinates[shader.uvMap[unit]].getCoordsPerVertex(),
					     GL.GL_FLOAT, 0, 0);
		    } else {
			textureBuffer.rewind();
			const coord = coords[unit];
			gl.glTexCoordPointer(coord.getCoordsPerVertex(), 
					     GL.GL_FLOAT, 0, textureBuffer);
		    }
		} else {
		    gl.glDisableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
		}
            }
            //println("applying shader {shader}");
	    if (texUnits > 0) {
                gl.glEnable(GL.GL_TEXTURE_2D);
            } else {
                gl.glDisable(GL.GL_TEXTURE_2D);
            }
            var allLights = if lights == [] then [cameraLight] else lights;
            const bnds = mn.sceneBounds;
            allLights = f3.util.Sequences.sort(allLights, java.util.Comparator of Point3 {
                    override function compare from (x is Point3, y is Point3) to Integer {
                        const p0 = x;
                        const p1 = y;
                        const d0 = (p0 - bnds.center).length();
                        const d1 = (p1 - bnds.center).length();
                        const cmp = d0 - d1;
                        if (cmp < 0) then -1 else if (cmp > 0) 1 else 0;
                    }
                });
            const closestLight = allLights[0];
            try {
                if (shader instanceof DefaultPhongShader) {
                    (shader as DefaultPhongShader).lightScenePos = closestLight;
                } else if (shader instanceof DefaultPhongShader4) {
                    var ds = shader as DefaultPhongShader4;
		    ds.lightScenePos1 = allLights[0];
                    ds.lightScenePos2 = allLights[1];
                    ds.lightScenePos3 = allLights[2];
                    ds.lightScenePos4 = allLights[3];
                    ds.lightMask = tuple(1,
					 if (sizeof allLights > 1) 1 else 0,
					 if (sizeof allLights > 2) 1 else 0,
					 if (sizeof allLights > 3) 1 else 0);
                }
		if (mn.sceneTransform == null or camera.viewMatrix == null or camera.projectionMatrix == null) {
		    println("bad transform {mn} {mn.id} or {camera} {camera.id}");
		    continue;
		}
		///println("applying shader {shader} to {mn.id}");
		shader.apply(mesh,
                             mn.sceneTransform,
                             camera.viewMatrix,
                             camera.projectionMatrix);
            } catch (e is java.lang.Exception) {
                e.printStackTrace();
                (shader = phongShader).apply(mesh,
                                             mn.sceneTransform,
                                             camera.viewMatrix,
                                             camera.projectionMatrix);

            }
            if (mesh.polygonMode <> polygonMode) {
                polygonMode = mesh.polygonMode;
                gl.glPolygonMode(GL.GL_FRONT_AND_BACK, if (mesh.polygonMode == PolygonMode.Line) GL2.GL_LINE else if (mesh.polygonMode == PolygonMode.Point) GL2.GL_POINT else GL2.GL_FILL);
            }
            const mode = if (mesh.indexMode == IndexMode.Lines) GL.GL_LINES else if (mesh.indexMode == IndexMode.Points) GL.GL_POINTS else GL.GL_TRIANGLES;
            if (vbo <> null) {
                gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, vbo.indexBuffer);
                gl.glDrawElements(mode,
                                  indexBuffer.limit(),
                                  GL2.GL_UNSIGNED_INT,
                                  0);
            } else {
                indexBuffer.rewind();
                gl.glDrawElements(mode,
                                  indexBuffer.limit(),
                                  GL2.GL_UNSIGNED_INT,
                                  indexBuffer);
            }            
	    for (unit in [0..<texUnits]) {
		gl.glClientActiveTexture(GL.GL_TEXTURE0+unit);
		gl.glDisableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
            }
            shader.reset();
            //mn.needsDraw = false;
            //shader.validate();
        }
    }
}

public class Listener extends GLEventListener, DropTargetListener {

    var screenx is Number;
    var screeny is Number;
    //    var gl is GL2;
    var stage is JoglStage;
    var ctx is  GLContext;
    function makeDropEvent
	from (e is java.awt.dnd.DropTargetDropEvent) 
	to DropEvent
    {
        var getData = function from () to String
	    {
		e.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE);
		var t = e.getTransferable();
		var flavors = [DataFlavor.stringFlavor, DataFlavor.javaFileListFlavor];
		var dataList: String[];
		for (i in t.getTransferDataFlavors()) {
		    for (j in flavors) {
			if (j == i) {
			    var td = t.getTransferData(j);
			    if (td instanceof java.util.List) {
				td = (td as java.util.List).get(0);
			    }
			    if (td instanceof java.io.File) {
				td = (td as java.io.File).toURL().toString();
			    }
			    insert td.toString() into dataList;
			}
		    }
		};
		dataList[0];
	    }
        DropEvent {
            url: bind getData();
            override function reject to () {
                e.rejectDrop();
            }
            override function accept to () {
                e.dropComplete(true);
            }
        }
    }
    
    function makeDragEvent
	from (e is java.awt.dnd.DropTargetDragEvent) 
	to DragEvent
    {
        DragEvent {
            screenx: screenx;
            screeny: screeny;
            override function reject to () {
                e.rejectDrag();
            }
            override function accept to () {
                e.acceptDrag(e.getSourceActions());
            }
        }
    }
    
    function makeDragEvent
	from (e is java.awt.dnd.DropTargetEvent) 
	to DragEvent
    {
        DragEvent {
            screenx: screenx;
            screeny: screeny;
            override function reject to () {
                // error
            }
            override function accept to () {
                //error
            }
        }
    }

    function mouseMove
	from (x is Number, y is Number, 
	      controlDown is Boolean, 
	      altDown is Boolean, 
	      metaDown is Boolean, 
	      shiftDown is Boolean)
	to ()
    {
        stage.injectMouseMove(MouseEvent {
                screenx: screenx = x;
                screeny: screeny = y;
                altKey: altDown;
                ctrlKey: controlDown;
                metaKey: metaDown;
                shiftKey: shiftDown;
            });
    }

    function mouseDown
	from (button is Integer, 
	      controlDown is Boolean, 
	      altDown is Boolean, 
	      metaDown is Boolean, 
	      shiftDown is Boolean, 
	      clickCount is Integer)
	to ()
    {
        var e is MouseEvent;
        stage.injectMouseDown(e=MouseEvent {
                screenx:  screenx;
                screeny:  screeny;
                altKey:  altDown;
                ctrlKey:  controlDown;
                metaKey:  metaDown;
                buttons:  button;
                clickCount:  clickCount;
            });
    }

    function mouseUp from (button is Integer, controlDown is Boolean, altDown is Boolean, metaDown is Boolean, shiftDown is Boolean) to () {
        var e is MouseEvent;
        stage.injectMouseUp(e=MouseEvent {
                screenx:  screenx;
                screeny:  screeny;
                ctrlKey:  controlDown;
                altKey:  altDown;
                metaKey:  metaDown;
                buttons:  button;
            });
    }

    override function dragEnter from (e is DropTargetDragEvent) to () {
        try {
            ctx.makeCurrent();
            stage.injectDragEnter(makeDragEvent(e));
        } finally {
            ctx.release();
        }
    }

    override function dragOver from (e is DropTargetDragEvent) to () {
        try {
            ctx.makeCurrent();
            stage.injectDragOver(makeDragEvent(e));
        } finally {
            ctx.release();
        }
    }

    override function dragExit from (e is DropTargetEvent) to () {
        try {
            ctx.makeCurrent();
            stage.injectDragLeave(makeDragEvent(e));
        } finally {
            ctx.release();
        }
    }

    override function dropActionChanged from (e is DropTargetDragEvent) to () {
    }

    override function drop from (e is DropTargetDropEvent) to () {
        try {
            ctx.makeCurrent();
            stage.injectDrop(makeDropEvent(e));
        } finally {
            ctx.release();
        }
    }

    function setup from (gl is GL2, width:Integer, height is Integer) to () {
        ctx = GLContext.getCurrent();
	ImageLoader_INSTANCE.gl = gl; // hack
        gl.setSwapInterval(1);
	stage.resize(width, height);
    }

    var mouseX is Number;
    var mouseY is Number;
    var setTitle is function from String to ();
    var setCursor is function from Cursor to ();
    var mainSceneRenderer is SceneRenderer;

    var opaque = 0;
    var transp = 0;

    var opaqueTris = 0;
    var transpTris = 0;
    var startTime is Long;

    var stageTitle is String;

    function render from (gl is GL2, width is Integer, height is Integer) to () {

        if (stageTitle <> stage.title) {
            setTitle(stageTitle = stage.title);
        }

        const now = java.lang.System.currentTimeMillis();
        if (startTime == 0) startTime = now;
        const currentTime = 1ms *(now - startTime);
	MasterTimeline.setPlayhead(currentTime);
        stage.flush();
        setCursor(stage.cursor);
        if (mainSceneRenderer == null and gl <> null) {
            mainSceneRenderer = SceneRenderer {
                activate: function from () to () {
                    gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, 0);
                }
                override function onDraw from (t is Integer, tt is Integer, o is Integer, ot is Integer) to () {
                    opaque += o;
                    transp += t;
                    transp_tris += tt;
                    opaque_tris += ot;
                }
            }
        }
        opaque = 0;
        transp = 0;
        transp_tris = 0;
        opaque_tris = 0;
        var dirty = false;
        for (scene in stage.content) {
	    scene.stage = stage;
	}
        for (scene in stage.content where scene.visible) {
            if (mainSceneRenderer.renderScene(gl, scene, width, height, dirty)) {
                dirty = true;
            }
        }
        if (lastOpaque <> opaque or lastTransp <> transp) {
            lastTransp = transp;
            lastOpaque = opaque;
        }
    }

    var title is String;
    var opaque_tris = 0;
    var transp_tris = 0;
    var lastTransp = 0;
    var lastOpaque = 0;
    override function dispose from (drawable is GLAutoDrawable) to () {}
    override function display from (drawable is GLAutoDrawable) to () {
        render(drawable.getGL().getGL2(), drawable.getWidth(), drawable.getHeight());
    }

    var animator is com.jogamp.opengl.util.Animator;

    override function init from (drawable is GLAutoDrawable) to () {
        animator = new com.jogamp.opengl.util.Animator(drawable);
        //animator.setRunAsFastAsPossible(true);
        animator.start();
    }

    override function reshape 
	from (drawable is GLAutoDrawable, 
	      x is Integer, 
	      y is Integer, 
	      w is Integer, 
	      h is Integer)
	to () 
    {
        setup(drawable.getGL().getGL2(), w, h);
    }
}

const keyMap = new java.util.TreeMap of (Integer, Integer);

function map from (inkey is Integer, outkey is Integer) to () 
{
    keyMap.put(inkey, outkey);
}

function mapKeyCode from (k is Integer) to Integer 
{
    const k0 = keyMap.get(k); 
    if (k0 == null) {
        return 0;
    }
    return k0;
}

function buildKeyMap 
{
    map(KeyEvent.VK_BACK_SPACE, Keys.Backspace);
    map(KeyEvent.VK_SPACE, Keys.Spacebar);
    map(KeyEvent.VK_TAB, Keys.Tab);
    map(KeyEvent.VK_ENTER, Keys.Enter);
    map(KeyEvent.VK_SHIFT, Keys.Shift);
    map(KeyEvent.VK_CONTROL, Keys.Ctrl);
    map(KeyEvent.VK_ALT, Keys.Alt);
    map(KeyEvent.VK_PAUSE, Keys.PauseBreak);
    map(KeyEvent.VK_CAPS_LOCK, Keys.CapsLock);
    map(KeyEvent.VK_ESCAPE, Keys.Esc);
    map(KeyEvent.VK_PAGE_UP, Keys.PageUp);
    map(KeyEvent.VK_PAGE_DOWN, Keys.PageDown);
    map(KeyEvent.VK_END, Keys.End);
    map(KeyEvent.VK_HOME, Keys.Home);
    map(KeyEvent.VK_LEFT, Keys.Left); 
    map(KeyEvent.VK_UP, Keys.Up);
    map(KeyEvent.VK_RIGHT, Keys.Right);
    map(KeyEvent.VK_DOWN, Keys.Down);
    map(KeyEvent.VK_INSERT, Keys.Insert);
    //    map(KeyEvent.VK_DELETE, Keys.Delete);
    map(KeyEvent.VK_DELETE, Keys.Backspace);
    map(KeyEvent.VK_0, Keys._0);
    map(KeyEvent.VK_1, Keys._1);
    map(KeyEvent.VK_2, Keys._2);
    map(KeyEvent.VK_3, Keys._3);
    map(KeyEvent.VK_4, Keys._4);
    map(KeyEvent.VK_5, Keys._5);
    map(KeyEvent.VK_6, Keys._6);
    map(KeyEvent.VK_7, Keys._7);
    map(KeyEvent.VK_8, Keys._8);
    map(KeyEvent.VK_9, Keys._9);
    map(KeyEvent.VK_SEMICOLON, Keys.Semicolon);
    map(KeyEvent.VK_EQUALS, Keys.Equals);
    map(KeyEvent.VK_A, Keys.A);
    map(KeyEvent.VK_B, Keys.B);
    map(KeyEvent.VK_C, Keys.C);
    map(KeyEvent.VK_D, Keys.D);
    map(KeyEvent.VK_E, Keys.E);
    map(KeyEvent.VK_F, Keys.F);
    map(KeyEvent.VK_G, Keys.G);
    map(KeyEvent.VK_H, Keys.H);
    map(KeyEvent.VK_I, Keys.I);
    map(KeyEvent.VK_J, Keys.J);
    map(KeyEvent.VK_K, Keys.K);
    map(KeyEvent.VK_L, Keys.L);
    map(KeyEvent.VK_M, Keys.M);
    map(KeyEvent.VK_N, Keys.N);
    map(KeyEvent.VK_O, Keys.O);
    map(KeyEvent.VK_P, Keys.P);
    map(KeyEvent.VK_Q, Keys.Q);
    map(KeyEvent.VK_R, Keys.R);
    map(KeyEvent.VK_S, Keys.S);
    map(KeyEvent.VK_T, Keys.T);
    map(KeyEvent.VK_U, Keys.U);
    map(KeyEvent.VK_V, Keys.V);
    map(KeyEvent.VK_W, Keys.W);
    map(KeyEvent.VK_X, Keys.X);
    map(KeyEvent.VK_Y, Keys.Y);
    map(KeyEvent.VK_Z, Keys.Z);
    map(KeyEvent.VK_WINDOWS, Keys.Windows);
    map(KeyEvent.VK_CONTEXT_MENU, Keys.RightClick);

    map(KeyEvent.VK_F1, Keys.F1);
    map(KeyEvent.VK_F2, Keys.F2);
    map(KeyEvent.VK_F3, Keys.F3);
    map(KeyEvent.VK_F4, Keys.F4);
    map(KeyEvent.VK_F5, Keys.F5);
    map(KeyEvent.VK_F6, Keys.F6);
    map(KeyEvent.VK_F7, Keys.F7);
    map(KeyEvent.VK_F8, Keys.F8);
    map(KeyEvent.VK_F9, Keys.F9);
    map(KeyEvent.VK_F10, Keys.F10);
    map(KeyEvent.VK_F11, Keys.F11);
    map(KeyEvent.VK_F12, Keys.F12);
    
    map(KeyEvent.VK_NUM_LOCK, Keys.NumLock);
    map(KeyEvent.VK_SCROLL_LOCK, Keys.ScrollLock);
}


var lastKey is Integer;

function makeKeyEvent from (e is java.awt.event.KeyEvent) to KeyboardEvent {
    var keyCode = e.getKeyCode();
    if (keyCode == 0) {
        keyCode = lastKey;
    }
    lastKey = keyCode;
    keyCode = mapKeyCode(keyCode);
    var char = "{e.getKeyChar()}";
    KeyboardEvent {
        keyChar: char;
        keyCode: keyCode;
        altKey: e.isAltDown();
        ctrlKey: e.isControlDown();
        shiftKey: e.isShiftDown();
        metaKey: e.isMetaDown();
    }
}

public class JoglStage is Stage 
{
    var listener is  Listener;
    public var title is String;
    var todo is (function from () to ())[];

    public function invoke from (fun is function from () to ()) to () {
        insert fun into todo;
    }

    function flush {
        var funs = todo;
        todo = [];
        for (fun in funs) fun();
	doUpdate();
    }

    postinit {
	println("setup");
	setup();
	for (scene in content) {
	    scene.stage = this;
	}
    }

    //override var width: Integer = 640;
    // override var height: Integer = 480;
    function doUpdate to () {
	updateCursor();
    }

    function setup {
        const glp = GLProfile.get("GL2");
        const caps = new GLCapabilities(glp);
        println("samples={SAMPLE_BUFFERS} numSamples={NUM_SAMPLES} depthBits={DEPTH_BITS}");
        caps.setDepthBits(DEPTH_BITS);
        caps.setSampleBuffers(SAMPLE_BUFFERS);
        caps.setNumSamples(NUM_SAMPLES);
        const canvas = new GLCanvas(caps);
        const frame = new Frame();
        frame.setSize(width, height);
        frame.add(canvas);
        frame.addWindowListener(java.awt.event.WindowAdapter {
                override public function windowClosing(e:java.awt.event.WindowEvent) {
                    java.lang.System.exit(0);
                }
            });
        buildKeyMap();
        listener = Listener { stage: this }
        listener.setTitle = function from (title is String) to () {
            frame.setTitle(title);
        }
        listener.setCursor = function from (cursor is Cursor) to () {
            if (cursor.type == CursorType.POINTER) {
                frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.DEFAULT_CURSOR));
            } else if (cursor.type == CursorType.HAND) {
                frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.HAND_CURSOR));
            } else if (cursor.type == CursorType.IBEAM) {
                frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.TEXT_CURSOR));
            } else {
                frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.DEFAULT_CURSOR));
            }
        }
        canvas.addMouseListener(java.awt.event.MouseAdapter {
                override function mousePressed from (e is java.awt.event.MouseEvent) to () {
                    listener.mouseDown(e.getButton(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown(), e.getClickCount());
                }
                override function mouseReleased from (e is java.awt.event.MouseEvent) to () {
                    listener.mouseUp(e.getButton(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown());
                }
            });
        canvas.addMouseMotionListener(java.awt.event.MouseMotionAdapter {
                override function mouseMoved from (e is java.awt.event.MouseEvent) to () {
                    listener.mouseMove(e.getX(), e.getY(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown());
                }
                override function mouseDragged from (e is java.awt.event.MouseEvent) to () {
                    listener.mouseMove(e.getX(), e.getY(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown());
                }
            });
        canvas.addKeyListener(java.awt.event.KeyAdapter {
                override function keyPressed from (e is java.awt.event.KeyEvent) to () {
                    injectKeyDown(makeKeyEvent(e));
                }
                override function keyReleased from (e is java.awt.event.KeyEvent) to () {
                    injectKeyUp(makeKeyEvent(e));
                }
                override function keyTyped from (e is java.awt.event.KeyEvent) to () {
                    injectKeyInput(makeKeyEvent(e));
                }
            });
        canvas.addGLEventListener(listener);
        new DropTarget(canvas, listener);
        frame.setVisible(true);
        canvas.requestFocus();
        frame.requestFocus();
    }
}

public static const CGEffectLoader_INSTANCE = JoglCGEffectLoader{};
public static const ImageLoader_INSTANCE = JoglImageLoader {};

var currentCamera is Camera on replace {
    println("currentCamera=>{currentCamera}");
}

public var TheWebBrowserFactory is AbstractWebBrowserFactory;

public function run from (args is String[]) to ()
{

    try {
	const clazz = 
	    java.lang.Class.forName("f3.media.web.awesomium.AwesomiumWebBrowserFactory") as java.lang.Class of AbstractWebBrowserFactory;
	TheWebBrowserFactory = clazz.newInstance();
	    
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't load awesomium web browser factory");
    }

    println("args={args}");

    var playerUrl is String;

    var model is Ma.Model = bind if (not playerUrl.endsWith(".ma")) then null else Ma.Model {
		effectLoader: the CGEffectLoader;
		imageLoader: the ImageLoader;
		url: playerUrl;
	    };

    const player = Timeline {
	content: TimeLayer {
	    content: bind model.getTemporalRoot();
	    playCount: -1;
	}
    }

    const camera = PerspectiveCamera {
        id: "free";
	ty: 3.0;
	tz: 13.7;
	near: .001;
	far: 100;
	content: PointLight {}
    }

    const viewer = DefaultExaminerViewer {
	camera: camera;
    }

    const browser = if TheWebBrowserFactory == null then null else WebBrowser {
	factory: TheWebBrowserFactory;
	effectLoader: CGEffectLoader_INSTANCE;
	pathFactory: ThePath2DFactory;
    }

    var currentModel is Node;

    var svgModel = bind if (not playerUrl.endsWith(".svg")) then null else SVG {
		url: playerUrl;
		factory: ThePath2DFactory
	    };

    var imageModel = bind if (playerUrl.endsWith(".jpg") or 
			      playerUrl.endsWith(".png") or
			      playerUrl.endsWith(".tiff") or
			      playerUrl.endsWith(".tga")) 
	Image { 
	    imageLoader: ImageLoader_INSTANCE; 
	    url: playerUrl;
	    pathFactory: ThePath2DFactory
	} else null;

    const doDrop = function from (url is String) to () {
	stage.title = url;
	playerUrl = url;
	if (url.endsWith(".ma")) {
	    viewer.focusCamera(currentModel = model.getSpatialRoot());
	} else if (url.endsWith(".svg")) {
	    viewer.focusCamera(currentModel = svgModel.root)
	} else if (url.endsWith(".png") or url.endsWith(".jpg") or url.endsWith("tiff") or url.endsWith(".tga")) {
	    viewer.focusCamera(currentModel = imageModel)
	} else {
	    if (browser <> null) {
		browser.url = url;
		currentModel = browser;
		viewer.focusCamera(currentModel = browser);
	    }
	}
    }
    
    currentCamera = camera;
    const stage = JoglStage {
	title: new java.io.File(args[0]).getName();
	content: Scene {
	    background: Color.GRAY;
	    override var camera = bind currentCamera on invalidate {
		println("scene camera invalidated {currentCamera}");
	    }
	    content: bind currentModel;
	}
    }

    const setCamera = function from (i is Integer) to ()
    {
	if (i == 0) {
	    currentCamera = camera;
	} else if (i == 9) {
	    currentCamera = Camera2D {};
	} else {
	    const cam = model.getCameras()[i-1];
	    if (cam <> null) {
		currentCamera = cam;
	    }
	}
    }
    stage.addMouseInputHandler(viewer);
    stage.addKeyboardInputHandler(KeyboardInputHandler {
	    override function onKeyDown from (event is KeyboardEvent) to () {
		if (event.propagate) {
		    if (event.keyCode == Keys.F) {
			viewer.focusCamera(stage.content[0]);
		    } else if (event.keyCode >= Keys._0 and event.keyCode <= Keys._9) {
			var index = event.keyCode - Keys._0;
			setCamera(index);
		    } else if (event.keyCode == Keys.D) {
			DEBUG_USE_DEFAULT_SHADER = not DEBUG_USE_DEFAULT_SHADER;
		    }
		}
	    }
	});
    stage.addDnDInputHandler(DnDInputHandler {
	    override function onDrop from (event is DropEvent) to () {
		var url = event.url;
		event.accept();
		try {
		    const checkProtocol = new java.net.URL(url);
		    doDrop(url);
		} catch (exception is java.lang.Exception) {
		    exception.printStackTrace();
		}
	    }
	});

}




