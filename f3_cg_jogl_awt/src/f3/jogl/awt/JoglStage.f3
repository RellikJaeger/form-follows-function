package f3.jogl.awt;
import f3.util.*;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.util.Bits;
import f3.media.scene.*;
import f3.media.input.*;
import java.awt.Frame;
import java.awt.geom.GeneralPath;
import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;
import java.awt.BasicStroke;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.dnd.*;
import java.awt.datatransfer.*;
import java.awt.event.KeyEvent;
import javax.media.opengl.GLProfile;
import javax.media.opengl.GLContext;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLCapabilities;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.GL;
import javax.media.opengl.GL2;
import javax.media.opengl.glu.GLU;
import javax.media.opengl.glu.gl2.GLUgl2;
import javax.media.opengl.awt.GLCanvas;
import java.lang.Math;
import com.jogamp.opengl.util.texture.awt.AWTTextureIO;
import com.jogamp.opengl.util.texture.Texture;
import com.jogamp.opengl.util.texture.TextureData;
import com.jogamp.opengl.util.texture.TextureIO;
import java.lang.IllegalStateException;
import java.nio.*;
import f3.media.scene.Shape2D;
import f3.media.scene.Shape2D.*;
import f3.media.scene.Shape2D.Path2D;
import f3.media.scene.Shape2D.Path2DFactory;
import f3.media.scene.MeshBuffer.*;
import f3.media.svg.SVG;
import f3.media.xhtml.XHTML;
import com.jogamp.opengl.util.awt.TextureRenderer;
import javax.swing.JOptionPane;
import java.awt.font.TextAttribute;
import java.text.AttributedString;
import java.text.AttributedCharacterIterator;

import org.apache.commons.imaging.ImageReadException;
import org.apache.commons.imaging.Imaging;
import org.apache.commons.imaging.ImagingConstants;
import org.apache.commons.imaging.common.IBufferedImageFactory;

//import f3.media.web.awesomium.AwesomiumWebBrowserFactory;

const ALWAYS_SWAP_BUFFERS is Boolean = Boolean.getBoolean("always.swap.buffers");
const DISABLE_SUPERSAMPLE is Boolean = Boolean.getBoolean("f3.jogl.stage.disable.supersample");
const DEBUG_SCISSOR is Boolean = Boolean.getBoolean("f3.jogl.stage.debug.scissor");


function checkMesh from (mn is MeshNode) to Boolean 
{
    var result = true;
    try {
        mn.mesh.getIndexBuffer();
        const b = mn.boundsInScene;
        if (Number.isNaN(b.center.x) or
            Number.isNaN(b.center.y) or
            Number.isNaN(b.center.z) or
            Number.isNaN(b.extent.x) or
            Number.isNaN(b.extent.y) or
            Number.isNaN(b.extent.z)) 
            {
                println("invalid bounds: {mn}: {b}");
                return false;
            }
            
    } catch (e is java.lang.RuntimeException) {
        var p = mn.parent;
        while (p <> null) {
            println(p);
            p = p.parent;
        }
        e.printStackTrace();
        result = false;
    }
    return result;
}

const DEBUG_HIERARCHY = java.lang.Boolean.getBoolean("f3.jogl.stage.debug.hierarchy");
const DEBUG_MESHES = java.lang.Boolean.getBoolean("f3.jogl.stage.debug.meshes");
const DEBUG_DRAW = java.lang.Boolean.getBoolean("f3.jogl.stage.debug.draw");
const DEBUG_LIGHTS = java.lang.Boolean.getBoolean("f3.jogl.stage.debug.lights");

public const ENABLE_TEXTURED_TEXT is Boolean = java.lang.Boolean.getBoolean("f3.jogl.stage.enable.textured.text");
public const ENABLE_2D_RENDERER is Boolean = java.lang.Boolean.getBoolean("f3.jogl.stage.enable.2d.renderer");

public const DISABLE_SCISSOR is Boolean = java.lang.Boolean.getBoolean("f3.jogl.stage.disable.scissor");

var DISABLE_DEFORMERS = false;

const frc = new java.awt.font.FontRenderContext(null, true, true);
const families = 
    java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames() on replace {
    for (x in families) println(x);
}

function getFont from (spec is String) to java.awt.Font 
{
    const props = spec.split(";");
    var size = 12;
    var style = 0;
    var name = "Lucida Grande";
    const fontAttrs is java.util.Map of (TextAttribute, Object) = new java.util.HashMap of (TextAttribute, Object);
    for (i in props) {
        const j = i.trim();
        if (j == "") continue;
        const prop = j.split(":");
        if (prop.length < 2) {
            throw new java.lang.IllegalArgumentException(spec);
        }
        const attr = prop[0].trim();
        const value = prop[1].trim();
        if (attr == "font-size") {
            size = java.lang.Integer.parseInt(value);
        } else if (attr == "font-weight") {
            if (value == "normal") {
                style = Bits.add(Bits.remove(style, java.awt.Font.BOLD), java.awt.Font.PLAIN);
            } else if (value == "bold") {
                style = Bits.add(Bits.remove(style,java.awt.Font.PLAIN), java.awt.Font.BOLD);
            } else {
		// error
	    }
        } else if (attr == "text-decoration") {
            fontAttrs.remove(TextAttribute.UNDERLINE);
            fontAttrs.remove(TextAttribute.STRIKETHROUGH);
            if (value == "underline") {
                fontAttrs.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
            } else if (value == "line-through") {
                fontAttrs.put(TextAttribute.STRIKETHROUGH, TextAttribute.STRIKETHROUGH_ON);
            }
        } else if (attr == "font-style") {
            style = Bits.remove(style, java.awt.Font.ITALIC);
            if (value == "italic") {
                style = Bits.add(style, java.awt.Font.ITALIC);
            } else if (value == "normal") {
                // @TODO
            } else {
		// error
	    }
        } else if (attr == "font-family") {
            const fams = value.split(",");
            for (x in fams, y in families) {
                if (x.equalsIgnoreCase(y)) {
                    name = x;
                    println("FOUND FONT FAMILY: {x}");
                    break;
                }
            }
        } else {
            throw new java.lang.IllegalArgumentException("unsupported font attribute: {attr}");
        }
    }
    const k = "{name}.{style}.{size}";
    var result = fonts.get(k) as java.awt.Font;
    if (result == null) {
        result = new java.awt.Font(name, style, size);
        fonts.put(k, result);
    }
    if (fontAttrs.size() > 0) {
        result= result.deriveFont(fontAttrs);
    }
    return result;
}

const fonts = new java.util.HashMap of (String, java.awt.Font);

abstract class JoglFont is Text.Font {
    public const font is java.awt.Font;
    override function hashCode to Integer { font.hashCode() }
    override function equals from (obj is Object) to Boolean {
        return obj is JoglFont and { const j = obj as JoglFont; j.font.equals(font) }
    }
    override function width from (text is String) to Number
    {
        const r = font.getStringBounds(text, frc);
        return r.getX() + r.getWidth();
    }
}

function flip_y from (path is GeneralPath) to GeneralPath 
{
    const t = AffineTransform.getScaleInstance(1, -1);
    const p = new GeneralPath();
    p.append(path.getPathIterator(t), false);
    return p;
}

class JoglTextLayoutEngine is Text.LayoutEngine {

    override const allFontFamilies = bind families;

    override public function createFont from (spec is String) to Text.Font 
    {
        const font = getFont(spec);
        println("font spec: {spec}");
        println("font: {font}");
        const lineMetrics = font.getLineMetrics("A", 0, 1, frc);
        JoglFont {
            name: font.getName();
            weight: if (f3.util.Bits.contains(font.getStyle(), java.awt.Font.BOLD)) then "bold" else "normal";
            style: if (f3.util.Bits.contains(font.getStyle(), java.awt.Font.ITALIC)) then "italic" else "normal";
            size: font.getSize2D();
            ascent: lineMetrics.getAscent();
            descent: lineMetrics.getDescent();
            leading: lineMetrics.getLeading();
            font: font;
            override public function derive from (css is String) to Text.Font
            {
                const r = createFont("{spec};{css}");
                return r;
            }
        }
    }
    override public function createLayoutInstance to Text.LayoutInstance {
	JoglTextLayoutInstance {engine: this}
    }
}

class TextRun {
    const text is String;
    const attr is Integer = Integer.MAX_VALUE;
}

public class JoglTextLayoutInstance is Text.LayoutInstance {

    const engine is JoglTextLayoutEngine;
    const shapeExtrusion = new Jogl2DExtruder.Extrusion(null, false, 0);
    const caretExtrusion = new Jogl2DExtruder.Extrusion(null, false, 0);
    const selectionExtrusion = new Jogl2DExtruder.Extrusion(null, false, 0);

    function convertMarkup 
        from (input is String, 
              attrs is java.util.Map of (..AttributedCharacterIterator.Attribute, ?) ) 
        to AttributedString
    {
        var i = 0;
        const len = input.length();
        const LT = "<".charAt(0);
        var runs is TextRun[];
        var count is Integer = 0;

        function flush to () {
            if (count < i) {
                const run = TextRun {
                    text: input.substring(count, i);
                } 
                insert run into runs;
                //println("flushed {i} {run.text}");
                count = i;
            }
        }

        function matches from (str is String) to Boolean {
            for (j in [0..<str.length()]) {
                if (i + j < input.length()) {
                    if (input.charAt(i+j) <> str.charAt(j)) {
                        //println("match failed at {i+j} for {str.charAt(j)}, {input.charAt(i+j)}");
                        return false;
                    }
                } else {
                    return false;
                }
            }
            flush();
            //println("matched {str}");
            i += str.length();
            count += str.length();
            return true;
        }

        while (i < len) {
            const ch = input.charAt(i);
            if (ch == LT) {
                if (matches("<sub>")) {
                    const j = input.indexOf("</sub>", i);
                    if (j >= i) {
                        insert TextRun {
                            text: input.substring(i, j);
                            attr: TextAttribute.SUPERSCRIPT_SUB;
                        } into runs;
                        count = i = j + 6;
                        continue;
                    }
                } else if (matches("<sup>")) {
                    const j = input.indexOf("</sup>", i);
                    if (j >= i) {
                        insert TextRun {
                            text: input.substring(i, j);
                            attr: TextAttribute.SUPERSCRIPT_SUPER;
                        } into runs;
                        count = i = j + 6;
                        continue;
                    }
                } 
            }           
            i++;
        }
        flush();
        const buf = new java.lang.StringBuffer();
        for (r in runs) {
            buf.append(r.text);
        }
        const newString = buf.toString();
        const attrString = new AttributedString(newString);
        attrString.addAttributes(attrs, 0, newString.length());
        var off = 0;
        for (r in runs) {
            if (r.attr <> Integer.MAX_VALUE) {
                //println("adding attribute to {off}: {r.text}");
                attrString.addAttribute(TextAttribute.SUPERSCRIPT, r.attr, off, off+r.text.length());
            }
            off += r.text.length();
        }
        //println("converted markup to {newString}");
        return attrString;
    }

    override public function createLayout
	from (text0 is String, 
	      font0 is Text.Font, 
	      wrapWidth is Integer, 
	      clipHeight is Integer,
	      rightJustify is Boolean)
	to Text.Layout 
    {
	const font = if (font0 <> null) then font0 else engine.createFont("");
        var match is Integer;
        var off is Integer = 0;
        const text = "{text0} ";
        const width = wrapWidth;
        const height = clipHeight;
        const fontHeight = font.height();
        var layouts is java.awt.font.TextLayout[] = [];
        var xs is Number[] = [];
        var ys is Number[] = [];
        const str = convertMarkup(text, (font as JoglFont).font.getAttributes());
        const measurer = new java.awt.font.LineBreakMeasurer(str.getIterator(), frc);
        var y = 0.0;
	var w = Math.round(wrapWidth / 2.0);
        var lastPos = -1;
        while (true) {
            const pos = measurer.getPosition();
            //println("pos: {pos}, of {text.length()}");
            if (pos >= text.length()) {
                break;
            }
            if (pos == lastPos) {
                break;
            }
            lastPos = pos;
            const nextNewline = text.indexOf("\n", measurer.getPosition()+1);
            const limit = if (nextNewline < 0) Integer.MAX_VALUE else nextNewline+1;
	    try {
		const layout = measurer.nextLayout(wrapWidth, limit, false);
                //y += layout.getAscent();
                y += font.ascent;
		if (y > clipHeight) {
		    break;
		}
		if (layout <> null) {
		    var dx = 
			if (rightJustify or not layout.isLeftToRight()) then wrapWidth - layout.getAdvance() else 0.0;
		    dx -= w;
		    //y += layout.getDescent() + layout.getLeading();
                    y += font.descent + font.leading;
		    insert dx into xs;
		    insert y into ys;
		    insert layout into layouts;
		}
	    } catch (e is java.lang.Exception) {
		println("TEXT={text0} wrapWidth={wrapWidth}");
		e.printStackTrace();
		break;
	    }
        }
	JoglTextLayout {
	    shapeExtrusion: shapeExtrusion;
	    caretExtrusion: caretExtrusion;
	    selectionExtrusion: selectionExtrusion;
	    xs: xs;
	    ys: ys;
	    layouts: layouts;
	    height: height;
	    width: width;
	}
    }
}

class JoglTextLayout is Text.Layout 
{
    const shapeExtrusion = new Jogl2DExtruder.Extrusion(null, false, 0);
    const caretExtrusion = new Jogl2DExtruder.Extrusion(null, false, 0);
    const selectionExtrusion = new Jogl2DExtruder.Extrusion(null, false, 0);
    const height is Number;
    const width is Number;
    const fontHeight is Number;
    const layouts is java.awt.font.TextLayout[];
    const xs is Number[];
    const ys is Number[];
    override public function getShape to Path2D 
    {
        const path = new GeneralPath();
        const t = new AffineTransform();
        for (layout in layouts) {
            const i = indexof layout;
            const dx = xs[i];
            const y = ys[i];
            t.setToTranslation(dx, y);
            path.append(layout.getOutline(t), false);
        }
        return JoglPath2D { path: flip_y(path), extrusion: shapeExtrusion }
    }

    override public function getCaretShape
	from (caret is Integer)
	to Path2D 
    {
        var pos = 0;
        for (layout in layouts) {
            if (pos <= caret and pos + layout.getCharacterCount() > caret) {
                const i = indexof layout;
                const dx = xs[i];
                const y = ys[i];
                const path = new GeneralPath();
                const t = AffineTransform.getTranslateInstance(dx, y);
                var shapes = layout.getCaretShapes(caret-pos);
                for (j in shapes) {
                    if (j == null) continue;
                    const shape = if (j.getBounds2D().getWidth() == 0) then new java.awt.BasicStroke(1).createStrokedShape(j) else j;
                    path.append(shape.getPathIterator(t), false);
                }
                return JoglPath2D { 
                    path: flip_y(path);
                    extrusion: caretExtrusion;
                }
            }
            pos += layout.getCharacterCount();
        }
        return null;
    }

    override public function getSelectionShape
	from (selectionStart is Integer, 
	      selectionEnd is Integer)
	to Path2D 
    {
        var pos = 0;
        const path = new GeneralPath();
        const t = new AffineTransform();
        for (layout in layouts) {
            const count = layout.getCharacterCount();
            if (pos + count >= selectionStart and pos <= selectionEnd) {
                const i = indexof layout;
                const dx = xs[i];
                const y = ys[i];
                const anchorStart = Math.max(selectionStart-pos, 0);
                const anchorEnd = Math.min(selectionEnd-pos, count);
                t.setToTranslation(dx, y);
                const shape = layout.getLogicalHighlightShape(anchorStart, anchorEnd);
                path.append(shape.getPathIterator(t), false);
            }
            pos += count;
        }
        return JoglPath2D { path: flip_y(path), extrusion: selectionExtrusion }
    }

    function getPos from (i is Integer,
			  hit is java.awt.font.TextHitInfo) to Point2 
    {
	const layout = layouts[i];
	const y = ys[i];
	if (hit == null) then null else {
		const shape = layout.getCaretShape(hit).getBounds2D();
		point(-width / 2.0 + shape.getX() + shape.getWidth() / 2, 
		      height / 2.0 -y-shape.getY()-shape.getHeight() / 2);
	    }
    }

    override public function pick
	from (charIndex is Integer)
	to Text.Pick
    {
        var pos = 0;
        for (layout in layouts) {
            var count = layout.getCharacterCount();
            if (pos <= charIndex and pos + count > charIndex) {
                var col = charIndex - pos;
                var info = layout.getNextLeftHit(col);
                if (info == null) {
                    info = layout.getNextRightHit(col);
                }
		const pt = getPos(indexof layout, info);
                return Text.Pick {
                    charIndex: pos+info.getCharIndex();
                    insertionIndex: pos+info.getInsertionIndex();
                    isLeadingEdge: info.isLeadingEdge();
                    row: indexof layout;
		    column: 
		    if info.isLeadingEdge() then info.getInsertionIndex() + 1 else info.getInsertionIndex();
		    x: pt.x;
		    y: pt.y;
                }
            }
            pos += count;
        }
        return null;
    }

    override public function pickCell
	from (row is Integer, column is Integer)
	to Text.Pick
    {
        var pos = 0;
        for (layout in layouts) {
            if (indexof layout == row) {
		var col = Math.min(column, layout.getCharacterCount());
                var info = layout.getNextLeftHit(col);
                if (info == null) {
                    info = layout.getNextRightHit(col);
                }
		const pt = getPos(row, info);
                return Text.Pick {
                    charIndex: pos+info.getCharIndex();
                    insertionIndex: pos+info.getInsertionIndex();
                    isLeadingEdge: info.isLeadingEdge();
                    row: row;
		    column:
		    if info.isLeadingEdge() then info.getInsertionIndex() + 1 else info.getInsertionIndex();
		    x: pt.x;
		    y: pt.y;
                }
            }
            pos += layout.getCharacterCount();
        }
        return null;
    }

    override public function pick
	from (x0 is Number, y0 is Number)
	to Text.Pick
    {
        var x = x0;
        var y = height - y0;
        y -= height / 2;
        var pos = 0;
        for (layout in layouts) {
            const i = indexof layout;
            if (y >= ys[i-1] and y <= ys[i]) {
                const dx = x - xs[i];
                const dy = y - ys[i];
		const bounds = layout.getBounds();
		const x1 = Math.min(Math.max(dx, bounds.getX()), bounds.getX() + bounds.getWidth());
                const info = layout.hitTestChar(x1, dy);
		return if (info == null) then null else {
			const pt = getPos(i, info);
			Text.Pick {
			    charIndex: pos+info.getCharIndex();
			    insertionIndex: pos+info.getInsertionIndex();
			    isLeadingEdge: info.isLeadingEdge();
			    row: i;
			    column: if info.isLeadingEdge() then info.getInsertionIndex() + 1 else info.getInsertionIndex();
			    x: pt.x;
			    y: pt.y;
			}
		    };
            }
            pos += layout.getCharacterCount();
        }
        return null;
    }
}

class JoglPath2D is Path2D 
{
    public var path is GeneralPath = new GeneralPath();
    public const extrusion = new Jogl2DExtruder.Extrusion(null, false, 0);
    var textureMatrix is Mat4 = Mat4.<<1>>;
    override public function setTextureMatrix from (m is Mat4) to () { textureMatrix = m; }
    override public function flatten from (flatness is Number) to Path2D
    {
        const newPath = new GeneralPath();
        newPath.append(path.getPathIterator(null, flatness), false);
        JoglPath2D {
            path: newPath;
        }
    }
    /*
    public function add from (other is Path2D) to Path2D {
        const newPath = new GeneralPath();
        const area1 = new Area(getPath());
        const area2 = new Area((other as JoglPath2D).getPath());
        newPath.append(area1.add(area2).getPathIterator(null), false);
        JoglPath2D {
            path: newPath;
        }
    }

    public function subtract from (other is Path2D) to Path2D {
        const newPath = new GeneralPath();
        const area1 = new Area(getPath());
        const area2 = new Area((other as JoglPath2D).getPath());
        newPath.append(area1.subtract(area2).getPathIterator(null), false);
        JoglPath2D {
            path: newPath;
        }
    }

    public function intersection from (other is Path2D) to Path2D {
        const newPath = new GeneralPath();
        const area1 = new Area(getPath());
        const area2 = new Area((other as JoglPath2D).getPath());
        newPath.append(area1.intersect(area2).getPathIterator(null), false);
        JoglPath2D {
            path: newPath;
        }
    }
    */
    function getPath to GeneralPath { 
        path;
    }

    function getPathIterator from (t is AffineTransform) to PathIterator {
        getPath().getPathIterator(t);
    }

    function getPathIterator from (t is AffineTransform, flatness is Number) to PathIterator 
    {
        getPath().getPathIterator(t, flatness);
    }

    override public function getPoints from () to Point2[] 
    {
        getPoints(null);
    }

    override public function getPoints from (mat is Mat4) to Point2[] 
    {
        const t = toAffineTransform(mat);
        var result is Point2[];
        const pi = getPathIterator(t);
        const coords = java.lang.reflect.Array.newInstance(java.lang.Float.TYPE, 6) as nativearray of Number;
        var x is Number;
        var y is Number;
        while (not pi.isDone()) {
            var seg = pi.currentSegment(coords);
            if (seg == java.awt.geom.PathIterator.SEG_MOVETO) {
                x = coords[0];
                y = coords[1];
                insert new Point2(x, y) into result;
            } else if (seg == java.awt.geom.PathIterator.SEG_LINETO) {
                insert new Point2(coords[0], coords[1]) into result;
            } else if (seg == java.awt.geom.PathIterator.SEG_CLOSE) {
                insert new Point2(x, y) into result;
            } else if (seg == java.awt.geom.PathIterator.SEG_CUBICTO) {
                insert new Point2(coords[0], coords[1]) into result;
                insert new Point2(coords[2],coords[3]) into result;
                insert new Point2(coords[4], coords[5]) into result;
            } else if (seg == java.awt.geom.PathIterator.SEG_QUADTO) {
                insert new Point2(coords[0], coords[1]) into result;
                insert new Point2(coords[2],coords[3]) into result;
            }
            pi.next();
        }
        return result;
    }

    override public function apply from (output is Path2D) to () 
    {
        const pi = getPathIterator(null);
        const coords = java.lang.reflect.Array.newInstance(java.lang.Float.TYPE, 6) as nativearray of Number;
        while (not pi.isDone()) {
            var seg = pi.currentSegment(coords);
            if (seg == java.awt.geom.PathIterator.SEG_MOVETO) {
                output.moveTo(coords[0], coords[1]);
            } else if (seg == java.awt.geom.PathIterator.SEG_LINETO) {
                output.lineTo(coords[0], coords[1]);
            } else if (seg == java.awt.geom.PathIterator.SEG_CUBICTO) {
                output.cubicTo(coords[0], coords[1], coords[2],coords[3], coords[4], coords[5]);
            } else if (seg == java.awt.geom.PathIterator.SEG_QUADTO) {
                output.quadTo(coords[0], coords[1], coords[2],coords[3]);
            } else if (seg == java.awt.geom.PathIterator.SEG_CLOSE) {
                output.closePath();
            }
            pi.next();
        }
    }

    override public function moveTo from (x0 is Number, y0 is Number) to () 
    {
        getPath().moveTo(x0, y0);
    }

    override public function lineTo from (x1 is Number, y1 is Number) to () 
    {
        getPath().lineTo(x1, y1);
    }

    override public function quadTo from (cx1 is Number, cy1 is Number, x2 is Number, y2 is Number) to () 
    {
        getPath().quadTo(cx1, cy1, x2, y2);
    }

    override public function cubicTo 
	from (cx1 is Number, cy1 is Number, 
	      cx2 is Number, cy2 is Number,
	      x2 is Number, y2 is Number) 
	to () 
    {
        getPath().curveTo(cx1, cy1, cx2, cy2, x2, y2);
    }

    override public function closePath 
    {
        getPath().closePath();
    }

    override public function reset 
    {
        path = new GeneralPath();
    }

    override public function getBounds to Bounds 
    {
        const bnds = getPath().getBounds2D();
        Bounds {
            center: point(bnds.getX() + bnds.getWidth()/2,
			  bnds.getY() + bnds.getHeight()/2,
			  0);
            extent: tuple(bnds.getWidth()/2, bnds.getHeight()/2, 0);
        }
    }

    override public function createStrokedShape from (stroke is Stroke) to Path2D 
    {
        const cap = 
            if (stroke.cap == Stroke.Cap.BUTT) then BasicStroke.CAP_BUTT 
                else if (stroke.cap == Stroke.Cap.SQUARE) then BasicStroke.CAP_SQUARE
                    else BasicStroke.CAP_ROUND;
        const join = 
            if (stroke.join == Stroke.Join.BEVEL) then BasicStroke.JOIN_BEVEL 
                else if (stroke.join == Stroke.Join.MITER) then BasicStroke.JOIN_MITER
                    else BasicStroke.JOIN_ROUND;
        const dashArray is nativearray of Number = stroke.dash;
        const bs = new BasicStroke(stroke.width, cap, join, 
                                   Math.max(stroke.miterlimit, 1.0), 
                                   if dashArray.length == 0 then null else dashArray, 
                                   stroke.dashPhase);
        const ss = bs.createStrokedShape(getPath());
        var gp is GeneralPath;
        if (ss instanceof GeneralPath){
            gp = ss as GeneralPath;
        } else {
            gp = new GeneralPath(ss);
        }
        JoglPath2D {
            path: gp;
        }
    }

    override public function contains from (x is Number, y is Number) to Boolean 
    {
        getPath().contains(x, y);
    }

    override public function createMesh to AbstractMesh 
    {
        try {
            extrusion.resetShape(getPath());
            extrusion.setTextureMatrix(toAffineTransform(textureMatrix));
            const md = extrusion.createMeshData();
            const mb = MeshBuffer {
                indexBuffer: md.getIndexBuffer();
                vertexBuffer: VertexAttributeBuffer { coordsPerVertex: 3, buffer: md.getVertexBuffer() }
                textureBuffers: VertexAttributeBuffer { coordsPerVertex: 2, buffer: md.getTextureBuffer(0) }
                normalBuffer: VertexAttributeBuffer { coordsPerVertex: 3, buffer: md.getNormalBuffer() }
            }
            return mb.toMesh();
        } catch (e is java.lang.Exception) {
            e.printStackTrace();
            return null;
        }
    }

}

function toAffineTransform from (m is Mat4) to java.awt.geom.AffineTransform 
{
    const r = if (m == Mat4.<<0>> or m == Mat4.<<1>>) 
        then null else 
            new java.awt.geom.AffineTransform(m.xx, m.yx, m.xy,
                                              m.yy, m.xw, m.yw);
    if (r <> null) {
        println("{m} ====> {r}");
    }
    return r;
}

class JoglPath2DFactory is Shape2D.Path2DFactory 
{
    override public function createPath to Path2D 
    {
        JoglPath2D {}
    }
}

public const ThePath2DFactory is Shape2D.Path2DFactory = JoglPath2DFactory {};
public const TheLayoutEngine is Text.LayoutEngine = JoglTextLayoutEngine {};

function makeGradientShader from (gl is GL2, grad is Shape2D.GradientPaint) to Shader 
{
    if (grad is Shape2D.LinearGradient) {
        JoglLinearGradientShader {
            gl: gl;
            grad: grad;
        }
    } else {
        JoglRadialGradientShader {
            gl: gl;
            grad: grad;
        }
    }
}


public class TexturedTextMeshNode is MeshNode {
    public const tn is Text.TextMeshNode;
}

class TextRenderer2D {
    var target is TextureRenderer;
    const gl is GL2;
    function render from (text is Text.TextMeshNode) to MeshNode 
    {
	const p = text.getText();
	const layout = text.getLayout() as JoglTextLayout;
	const bounds = layout.getShape().getBounds();
	const bg = (text.background as ColorPaint).color;
	const fg = (text.paint as ColorPaint).color;
	const w = pot(bounds.width()+4);
	const h = pot(bounds.height()+4);
	if (target.getWidth() <> w or target.getHeight() <> h) {
	    target = new TextureRenderer(w, h, true);
	    target.setSmoothing(false);
	}
	//println("camera={camera.bounds}");
	const g = target.createGraphics();
	const bgc = new java.awt.Color(bg.red,
				       bg.green,
				       bg.blue,
				       bg.opacity);
	g.setBackground(bgc);
	g.clearRect(0, 0, w, h);
	println("layout bounds = {layout.getShape().getBounds()}");
	const tx = AffineTransform.getTranslateInstance(Math.round(w/2.0), Math.round(h/2.0));
	g.setTransform(tx);
	const b = p.bounds;
        /*
	g.setColor(bgc);
	g.fillRect(-b.extent.x-1,
		   b.extent.y+1,
	           b.width()+2, 
		   b.height()+2);
        */                 
	g.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
			   java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
	g.setRenderingHint(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,
			   java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
	g.setRenderingHint(java.awt.RenderingHints.KEY_FRACTIONALMETRICS,
			   java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_OFF);
	
	const fgc = new java.awt.Color(fg.red, fg.green, fg.blue, fg.opacity);
	g.setColor(fgc);
	tx.scale(1, -1);
	tx.translate(-bounds.center.x, bounds.center.y);
	g.setTransform(tx);
        println("transform={tx}");
        println("drawing: {p.text}");
	for (tl in layout.layouts) {
	    const i = indexof tl;
	    const x = layout.xs[i];
	    const y = layout.ys[i];
            println("drawing line {indexof tl + 1} at {x}, {y}");
	    tl.draw(g, x, y);
	}
	target.markDirty(0, 0, w, h);	
	const tex = target.getTexture();
        tex.setTexParameteri(gl, GL.GL_TEXTURE_MIN_FILTER, GL.GL_NONE);
        tex.setTexParameteri(gl, GL.GL_TEXTURE_MAG_FILTER, GL.GL_NONE);
	//tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE);
	//tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE);
	const id = "{text.id}#texture";
	const texture = JoglTexture {
	    gl: this.gl;
	    tex: tex;
	    id: id;
	}
	println("text={p.text} => bounds={bounds.left()}, {bounds.top()}, {bounds.width()}, {bounds.height()} w={w} h={h}");
	TexturedTextMeshNode {
	    parent: text;
	    id: id;
	    mesh: MeshBuffer.quad(bounds.width(), bounds.height(), w, h);
	    shader: TexturePaintShader {
		color: Color.WHITE;
		tex: texture;
	    }
	    transform: bind translate(bounds.center.x, bounds.center.y);
	}
    }
}



class SceneRenderer2D 
{
    public var gl is GL2;
    public var glp is GLProfile;
    const tx = new java.awt.geom.AffineTransform();
    public var tex is JoglTexture;
    public var meshNode is MeshNode;
    var target is TextureRenderer;

    function applyTransform from (mat is Mat4) to () {
	tx.setTransform(mat.xx, mat.yx, mat.xy,
			mat.yy, mat.xw, mat.yw);
    }

    function applyPaint from (g is java.awt.Graphics2D, paint is Shape2D.Paint) to () 
    {
	if (paint is Shape2D.ColorPaint) {
	    const cp = paint as Shape2D.ColorPaint;
	    var r = new java.awt.Color(cp.color.red,
				       cp.color.green,
				       cp.color.blue,
				       cp.color.opacity);
	    g.setPaint(r);
	}
    }


    function render2d from (camera is Camera2D, scene is Scene) to () 
    {
	const w = pot(scene.stage.width);
	const h = pot(scene.stage.height);
	//cx = AffineTransform.getTranslateInstance(0, scene.stage.height);
	if (target.getWidth() <> w or target.getHeight() <> h) {
	    target = new TextureRenderer(w, h, true);
	    tex == null;
	    meshNode = null;
	}
	//println("camera={camera.bounds}");
	const g = target.createGraphics();
	g.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING,
			   java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
	g.setRenderingHint(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING,
			   java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
	g.setRenderingHint(java.awt.RenderingHints.KEY_FRACTIONALMETRICS,
			   java.awt.RenderingHints.VALUE_FRACTIONALMETRICS_ON);
	const bg = if (scene.background == null) Color.color(0, 0, 0, 0) else scene.background;
	g.setBackground(new java.awt.Color(bg.red,
					   bg.green,
					   bg.blue,
					   bg.opacity));
	camera.update();
	g.clearRect(0, 0, w, h);

	scene.root.foldLeft((), 
			    function from (_ is (), n is Node) to () 
			    {
				//println("bounds={n}: {n.boundsInScene}");
				if (n is Shape2D.MeshNode2D and 
				    n.visibleInScene and 
				    camera.contains(n.boundsInScene)) {
				    const shape = n as Shape2D.MeshNode2D;
				    applyTransform(n.toSceneTransform);
				    applyPaint(g, shape.paint);
				    const saved = g.getTransform();
				    if (shape instanceof Text.TextMeshNode) {
					const t = (shape as Text.TextMeshNode).getLayout() as JoglTextLayout;
					const s = AffineTransform.getScaleInstance(1, -1);
					tx.concatenate(s);
					g.setTransform(tx);
					for (layout in t.layouts) {
					    const i = indexof layout;
					    layout.draw(g, t.xs[i], t.ys[i]);
					}
				    } else {
					g.setTransform(tx);
					const p = shape.path as JoglPath2D;
					if (p.path <> null) {
					    g.fill(p.path);
					} else {
					    //println("path is null {n} {n.parent}");
					}
				    }
				    g.setTransform(saved);
				}
			    });
	target.markDirty(0, 0, w, h);
	target.getTexture();
	if (tex == null or meshNode == null) {
	    println("target texture {target.getTexture()}");
	    const texture = JoglTexture {
		gl: this.gl;
		tex: target.getTexture();
		id: scene.id;
	    }
	    tex = texture;
	    meshNode = MeshNode {
	       parent: scene.root;
	       id: scene.id;
	       mesh: MeshBuffer.quad(w, h);
	       shader: TexturePaintShader 
	       {
		   color: Color.WHITE;
		   tex: texture;
	       }
	       override var transform = translate(w / 2.0, h / 2.0);
	   }
	   println("bounds={meshNode.bounds}");
	}
    }     
}

abstract class JoglGradientShader is CGFXShader 
{
    public var gl is GL2;
    public var tex is Texture;
    public var grad is Shape2D.GradientPaint;
    override var uvMap = [0];
    override var technique = bind if (isTransparent) then "Transparent" else "Opaque";
    var texture is JoglTexture; 
    var buf is ByteBuffer;
    var textureDirty = true;
    function toByte from (color is Number) to Byte {
        return Bits.bitAnd((color * 255) as Integer, 0xff);
    }

    function toInt from (color is Number) to Integer {
        return Bits.bitAnd((color * 255) as Integer, 0xff);
    }

    function updateTexture {
        if (tex == null) {
            tex = genTexture(gl, 16, 1);
            tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_S, GL2.GL_CLAMP_TO_EDGE);
            tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_T, GL2.GL_CLAMP_TO_EDGE);
	    texture = JoglTexture {
		gl: gl;
		tex: tex;
	    };
        }
        if (buf == null) {
            buf = BufferUtils.createByteBuffer(16*4);
        }
        var hasTransparency = false;
        for (i in [0..<16]) {
            var color = grad.colors[i];
            if (color == null) {
                color = Color.BLACK;
            }
            const j = i * 4;
            const r = buf.get(j);
            const g = buf.get(j+1);
            const b = buf.get(j+2);
            const a = buf.get(j+3);
            const x = toByte(color.red);
            const y = toByte(color.green);
            const z = toByte(color.blue);
            const w = toByte(color.opacity);
            if (r <> x or
                g <> y or 
                b <> z or 
                a <> w) {
		textureDirty = true;
		buf.put(j, x);
		buf.put(j+1, y);
		buf.put(j+2, z);
		buf.put(j+3, w);
	    }
        }
        if (textureDirty) {
            textureDirty = false;
            const glp = GLProfile.get("GL2");
            println("updating gradient colors {tex} transparent={isTransparent}");
            tex.updateImage(gl, 
                            new TextureData(glp, 
                                            GL.GL_RGBA8, 
                                            16, 1,
                                            0,
                                            GL2.GL_RGBA,
                                            GL2.GL_UNSIGNED_BYTE,
                                            false, 
                                            false, 
                                            true, 
                                            buf, 
                                            null));
        }
        setParameter("colors", texture);
    }

    function updateParams from (mesh is AbstractMesh) to () {
        var x is Number;
        var y is Number;
        var w is Number;
        var h is Number;
        if (grad.proportional) {
            const bounds = mesh.bounds;
            x = bounds.center.x - bounds.extent.x;
            y = bounds.center.y - bounds.extent.y;
            w = bounds.extent.x * 2;
            h = bounds.extent.y * 2;
	    println("bounds={bounds} => {x} {y} {w} {h}");
            if (w == 0 or h == 0)  {
                w = h = 1;
            }
        } else {
            x = 0; y = 0; w = 1; h = 1
        }
        updateParams(x, y, w, h);
        for (i in [0..<4]) {
            var v = vector(grad.stops[i*4],
			   grad.stops[i*4+1],
			   grad.stops[i*4+2],
			   grad.stops[i*4+3]);
            setParameter("fractions{i+1}", v);
        }
        var scaleFactors = foreach (i in [0..<16]) 0.0;
        for (i in [0..<grad.stops.size()-1]) {
            scaleFactors[i] = 1.0 / (grad.stops[i+1]-grad.stops[i]);
        }
        for (i in [0..<4]) {
            var v = vector(scaleFactors[i*4],
			   scaleFactors[i*4+1],
			   scaleFactors[i*4+2],
			   scaleFactors[i*4+3]);
            setParameter("scaleFactors{i+1}", v);
        }
    }

    protected abstract function updateParams
	from (x is Number, y is Number, w is Number, h is Number) to ();

    override function apply from (mesh is AbstractMesh, 
				  worldTransform is  Mat4,
				  viewMatrix is  Mat4,
				  projectionMatrix is  Mat4) to ()
    {
        var t = false;
        for (color in grad.colors) {
            if (color.opacity <> 1.0) {
                t = true;
                break;
            }
        }
        isTransparent = t;
        updateTexture();
        updateParams(mesh);
        super.apply(mesh, worldTransform, viewMatrix, projectionMatrix);
    }

}

class JoglRadialGradientShader is JoglGradientShader 
{

    override var url = "{__DIR__}radialgradient.cgfx";
    override function updateParams
	from (rx is Number, ry is Number, rw is Number, rh is Number) 
	to () 
    {
        const grad = this.grad as Shape2D.RadialGradient;
        const fx = grad.focusX;
        const fy = grad.focusY;
        const cx = fx;
        const cy = fy;
        const r = grad.radius;
        const tr  = r * Math.max(rw, rh);
        const tcx = rx + cx * rw;
        const tcy = ry + cy * rh;
        const tfx = rx + fx * rw;
        const tfy = ry + fy * rh;
        println("center={tcx},{tcy}");
        var focus = new Vec3(tfx, tfy, 0);
        const gradientTransform = Mat4.<<1>> * grad.transform;
        println("focus={focus}");
        var t = 
            (gradientTransform * 
             translate(tcx, tcy) * 
             rotate(Math.toDegrees(Math.atan2(tfy-tcy, tfx-tcx))) *
             scale(tr, tr));
        try {
            t = t.inverse(); // t now maps from object space to unit circle
        } catch (e is java.lang.Exception) {
            e.printStackTrace();
            t = Mat4.<<1>>;
        }
        const focusPt = (t * gradientTransform).getTranslation();
        println("FOCUS => {focusPt}");
        setParameter("objectSpaceToUnitCircle", t);
        setParameter("focus", focusPt);
    }
}

class JoglLinearGradientShader is JoglGradientShader 
{

    override var url = "{__DIR__}lineargradient.cgfx";

    override function updateParams
	from (rx is Number, ry is Number, rw is Number, rh is Number) 
	to () 
    {
        var grad = this.grad as Shape2D.LinearGradient;
        var gradientTransform = grad.transform;
        var t = Mat4.<<1>> * grad.transform;

        var x1 = grad.x1;
        var y1 = grad.y1;
        var x2 = grad.x2;
        var y2 = grad.y2;

        var tx1 = rx + x1 * rw;
        var ty1 = ry + y1 * rh;
        var tx2 = rx + x2 * rw;
        var ty2 = ry + y2 * rh;

        // calculate plane equation constants
        var x = tx1;
        var y = ty1;
        t *= translate(x, y);

        // now gradient point 1 is at the origin
        x = tx2 - x;
        y = ty2 - y;

        t *= rotate(Math.toDegrees(Math.atan2(y, x)));

        var len = Math.sqrt(x*x + y*y) as Number;

        // now gradient point 2 is on the positive x-axis
        t *= scale(len, 1);

        // now gradient point 1 is at (0.0, 0), point 2 is at (1.0, 0)

        try {
            t = t.inverse();
        } catch (e) {
            t = Mat4.<<1>>
        }
        setParameter("toUnitX", t);
    }
}


class ColorPaintShader is CGFXShader 
{
    public var colorPaint is ColorPaint;
    public readonly var color = bind colorPaint.color;
    override var url =  "{__DIR__}flat.cgfx";
    override var technique =  bind if (color.opacity == 1) then "Opaque" else "Transparent";
    
    override function updateParameters to ()
    {
        setParameter("diffuse", color);
    }

    override function apply
        from (mesh is AbstractMesh,
	      worldTransform is Mat4,
	      viewMatrix is Mat4,
	      projectionMatrix is Mat4) 
	to () 
    {

        super.apply(mesh,
		    worldTransform,
                    viewMatrix,
                    projectionMatrix);
    }
}

class TexturePaintShader is CGFXShader 
{
    public var colorPaint is ColorPaint;
    public var tex is AbstractTexture;
    public readonly var color = bind colorPaint.color;
    override var url =  "{__DIR__}flat-textured.cgfx";
    override var technique =  bind if (color.opacity == 1) "Opaque" else "Transparent";
    override var uvMap = [0];
    public var transform is Mat4 = Mat4.<<1>>;

    override function updateParameters to ()
    {
        setParameter("texSampler0", tex);
    }

    override function apply from (mesh is AbstractMesh,
				  worldTransform is  Mat4,
				  viewMatrix is  Mat4,
				  projectionMatrix is  Mat4) to () 
    {
	updateParameters();
        super.apply(mesh,
		    worldTransform,
                    viewMatrix,
                    projectionMatrix);
    }
}

function flatShader from (color is Color, tex is AbstractTexture) to Shader 
{
    var shader is CGFXShader;
    if (tex == null) {
        shader = CGFXShader {
            url: "{__DIR__}flat.cgfx";
            technique: bind if (color.opacity == 1) "Opaque" else "Transparent";
        }
    } else {
        shader = CGFXShader {
	    override var uvMap = [0];
            url: "{__DIR__}flat-textured.cgfx";
            //technique: bind if (color.opacity == 1) "Opaque" else "Transparent";
	    override function updateParameters to ()
	    {
                var xywh = vector(0, 0, tex.getWidth(), tex.getHeight());
                shader.setParameter("xywh", xywh);
	    }

            override function apply from (mesh is AbstractMesh,
					  worldTransform is Mat4,
					  viewMatrix is Mat4,
					  projectionMatrix is Mat4) to () 
	    {
                super.apply(mesh, worldTransform, viewMatrix, projectionMatrix);
            }
        }
        shader.setParameter("texSampler0", tex);
    }
    shader.setParameter("diffuse", color);
    return shader;
}

function pot from (n is Integer) to Integer 
{
    var result = 2;
    while (result < n) {
        result *= 2;
    }
    return result;
}

const NUM_SAMPLES = java.lang.Integer.getInteger("numSamples", 8);
const SAMPLE_BUFFERS = NUM_SAMPLES <> 0;
const DEPTH_BITS = java.lang.Integer.getInteger("depthBits", 32);

class DefaultPhongShader is CGFXShader 
{
    public var lightScenePos is Point3 = Point3.<<0>>;
    override function updateParameters to ()
    {
        setParameter("lightWorldPos", lightScenePos);
    }

    override function apply
	from (mesh is AbstractMesh,
	      sceneTransform is Mat4,
	      viewMatrix is Mat4,
	      projectionMatrix is Mat4)
	to ()
    {

        super.apply(mesh, sceneTransform, viewMatrix, projectionMatrix);
    }
}

class DefaultPhongShader4 is CGFXShader 
{
    public var lightScenePos1 is Point3 = Point3.<<0>>;
    public var lightScenePos2 is Point3 = Point3.<<0>>;
    public var lightScenePos3 is Point3 = Point3.<<0>>;
    public var lightScenePos4 is Point3 = Point3.<<0>>;
    public var lightMask is Tuple4 = Tuple4.<<1>>;
    override function updateParameters to ()
    {
        setParameter("lightWorldPos1", lightScenePos1);
        setParameter("lightWorldPos2", lightScenePos2);
        setParameter("lightWorldPos3", lightScenePos3);
        setParameter("lightWorldPos4", lightScenePos4);
        setParameter("lightMask", lightMask);
    }

    override function apply
	from (mesh is AbstractMesh,
	      sceneTransform is Mat4,
	      viewMatrix is Mat4,
	      projectionMatrix is Mat4)
	to ()
    {
        super.apply(mesh, sceneTransform, viewMatrix, projectionMatrix);
    }
}

class JoglCGEffectLoader is CGEffectLoader 
{
    override public function loadDefaultShader(diffuseTexture is AbstractTexture,
                                               diffuse is Color,
                                               ambient is Color,
                                               emissive is Color,
                                               specular is Color,
                                               shininess is Number)
	to Shader 
    {
        var shader is CGFXShader;
        if (diffuseTexture == null) {
            shader = DefaultPhongShader4 { 
                url: "{__DIR__}phong4.cgfx";
                technique: if (diffuse.opacity == 1) "Opaque" else "Transparent";
		isTransparent: diffuse.opacity <> 1.0;
            }
        } else {
            shader = DefaultPhongShader4 { 
                url: "{__DIR__}phong4-textured.cgfx"
		uvMap: [0];
            }
            println("loading shader with texture {diffuseTexture} colors: d={diffuse}, a={ambient}, e={emissive}, s={specular}, shininess: {shininess}");
            shader.setParameter("texSampler0", diffuseTexture);
        }
        shader.setParameter("diffuse", diffuse);
        shader.setParameter("emissive", emissive);
        const ambientIntensity = Vec4.<<0>>;
        const lightIntensity = Vec4.<<1>> - ambientIntensity;
        shader.setParameter("ambientIntensity", ambientIntensity);        
        shader.setParameter("ambient", ambient);
        shader.setParameter("lightIntensity", lightIntensity);
        shader.setParameter("specular", specular);
        shader.setParameter("shininess", shininess);
        shader.setParameter("colorMult", Vec4.<<1>>);
        return shader;
    }

    override public function loadEffect
	from (url is String,
	      technique is String)
	to Shader
    {
        CGFXShader {
            url: url;
            technique: technique;
        }
    }

    override public function loadPaintShader(paint is Shape2D.Paint) to Shader {
	if (paint is Shape2D.ColorPaint) {
	    readonly var colorPaint = bind paint as Shape2D.ColorPaint;
	    if (paint is Shape2D.TexturePaint) {
		var tex = 
		    bind (paint as Shape2D.TexturePaint).texture;
		TexturePaintShader {
		    color: bind colorPaint.color;
		    tex: bind tex;
		}
	    } else {
		ColorPaintShader {
		    color: bind colorPaint.color;
		}
	    }
	} else null; // @todo
    }
}


const ENABLE_VBOS = java.lang.Boolean.getBoolean("enable.vbos");

class MeshVBO {
    var gl is GL2;
    var indexBuffer is Integer;
    var vertexBuffer is Integer;
    var normalBuffer is Integer;
    var textureBuffers is Integer[];
    override function finalize {
        org.f3.runtime.Entry.deferAction(java.lang.Runnable {
                override function run {
                    var count = textureBuffers.size() + 3;
                    var ids = BufferUtils.createIntBuffer(count);
                    ids.put(indexBuffer);
                    ids.put(vertexBuffer);
                    ids.put(normalBuffer);
                    for (i in textureBuffers) {
                        ids.put(i);
                    }
                    ids.flip();
                    gl.glDeleteBuffers(ids.remaining(), ids);
                }
            });
    }
}

const meshToVBO = new java.util.HashMap of (AbstractMesh, MeshVBO);

function bufferData
    from (gl is GL2, 
	  buffer is java.nio.FloatBuffer)
    to Integer 
{
    const ibuf = BufferUtils.createIntBuffer(1);
    gl.glGenBuffers(1, ibuf);
    const id = ibuf.get(0);
    buffer.rewind();
    gl.glBindBuffer(GL.GL_ARRAY_BUFFER, id);
    gl.glBufferData(GL.GL_ARRAY_BUFFER, buffer.limit() * 4,  buffer, GL.GL_STATIC_DRAW);
    gl.glBindBuffer(GL.GL_ARRAY_BUFFER, 0);
    return id;
}

function bufferData
    from (gl is GL2, 
	  buffer is java.nio.IntBuffer)
    to Integer 
{
    const ibuf = BufferUtils.createIntBuffer(1);
    gl.glGenBuffers(1, ibuf);
    const id = ibuf.get(0);
    buffer.rewind();
    gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, id);
    gl.glBufferData(GL.GL_ELEMENT_ARRAY_BUFFER, buffer.limit() * 4,  buffer, GL.GL_STATIC_DRAW);
    gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, 0);
    return id;
}

function getVBO
    from (gl is GL2, mesh is AbstractMesh)
    to MeshVBO 
{
    if (not ENABLE_VBOS) {
        return null;
    }
    var vb = meshToVBO.get(mesh) as MeshVBO;
    if (vb == null) {
        vb = MeshVBO {gl:gl};
        meshToVBO.put(mesh, vb);
        vb.indexBuffer = bufferData(gl, mesh.getIndexBuffer());
        vb.vertexBuffer = bufferData(gl, mesh.getVertexBuffer());
        vb.normalBuffer = bufferData(gl, mesh.getNormalBuffer());
        vb.textureBuffers = foreach (i in [0..<mesh.getTextureBuffers().size()]) {
            bufferData(gl, mesh.getTextureBuffers()[i]);
        };
    }
    return vb;
}

const DEBUG_USE_DEFAULT_SHADER = 
    java.lang.Boolean.getBoolean("debug.use.default.shader");

const SHADER_DEBUG = java.lang.Boolean.getBoolean("debug.cgfx");

function genTexture
    from (gl is GL2, width is Integer, height is Integer)
    to Texture 
{
    const ibuf = BufferUtils.createIntBuffer(1);
    gl.glGenTextures(ibuf.limit(), ibuf); 
    const id = ibuf.get(0);
    const glp = GLProfile.get("GL2");
    const tex = TextureIO.newTexture(id,
				     GL.GL_TEXTURE_2D,
				     width, height,
				     width, height,
				     false);
    tex.bind(gl);
    tex.updateImage(gl, 
		    new TextureData(glp, 
				    GL.GL_RGBA8, 
				    width, height, 
				    0,
				    GL2.GL_RGBA,
				    GL2.GL_UNSIGNED_BYTE,
				    false, 
				    false, 
				    true, 
				    null, 
				    null));
    tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_S, GL.GL_REPEAT);
    tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_T, GL.GL_REPEAT);
    tex.setTexParameteri(gl, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR);
    tex.setTexParameteri(gl, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);
    return tex;
}



class OffscreenSurface is JoglTexture 
{
    var stageRenderer is StageRenderer;
    const _backgroundColor is Color;
    var _width is Integer = bind (width+0.5) as Integer;
    var _height is Integer = bind (height+0.5) as Integer;
    var pot_width = bind pot(_width);
    var pot_height = bind pot(_height);
    const _samples is Integer = 16;
    const _depthBits is Integer = 24;
    const _stencilBits is Integer = 8;
    var _fboID is Integer;
    var _depthRBID is Integer;
    var _msfboID is Integer;
    var _msDepthID is Integer;
    var _mscolorRBID is Integer;
    var _msdepthRBID is Integer;
    var lastTextureId is Integer;

    function activate 
    {
	if (tex.getWidth() <> pot_width or tex.getHeight() <> pot_height) {
	    tex = null;
	    cleanup();
	}
	if (tex == null) {
	    tex = genTexture(gl, pot_width, pot_height);
	    tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_S, GL.GL_CLAMP_TO_EDGE);
	    tex.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_T, GL.GL_CLAMP_TO_EDGE);
	    tex.setTexParameteri(gl, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR);
	    tex.setTexParameteri(gl, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);
	    const textureId = tex.getTextureObject(gl);
	    println("textureId={textureId} gl={gl}");
            var ibuf = BufferUtils.createIntBuffer(1);
	    if (lastTextureId <> 0 and lastTextureId <> textureId) {
		ibuf.clear();
		ibuf.put(lastTextureId);
		ibuf.rewind();
		gl.glDeleteTextures(1, ibuf);
	    }
	    lastTextureId = textureId;
            gl.glGetIntegerv(gl.GL_MAX_SAMPLES, ibuf);
            var maxSamples = ibuf.get(0);
            var _samples = Math.min(this._samples, maxSamples);
            println("samples={this._samples} max={maxSamples}");
            var buffer = BufferUtils.createIntBuffer(1);
            // Create our texture binding FBO
            gl.glGenFramebuffers(1, buffer); 
            _fboID = buffer.get(0);
	    gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, _fboID);
	    tex.bind(gl);
	    gl.glFramebufferTexture2D(GL.GL_FRAMEBUFFER, 
				      GL.GL_COLOR_ATTACHMENT0, 
				      GL.GL_TEXTURE_2D, textureId, 0);
	    checkFBOComplete(_fboID);  
	    
            // Create a depth renderbuffer to use for RTT use
            gl.glGenRenderbuffers(1, buffer);
            _depthRBID = buffer.get(0);
            gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, _depthRBID);
            var format = GL2.GL_DEPTH_COMPONENT;
            if (_depthBits == 24 and _stencilBits == 8) {
                format = GL.GL_DEPTH24_STENCIL8;
            } else if (_depthBits == 16) {
                format = GL.GL_DEPTH_COMPONENT16;
            } else if (_depthBits == 24) {
                format = GL.GL_DEPTH_COMPONENT24;
            } else if (_depthBits == 32) {
                format = GL.GL_DEPTH_COMPONENT32;
            }
            gl.glRenderbufferStorage(GL.GL_RENDERBUFFER, format, pot_width, pot_height);
            // unbind...
            gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, 0);
	    if (_depthBits > 0) {
		gl.glFramebufferRenderbuffer(gl.GL_FRAMEBUFFER,
					     gl.GL_DEPTH_ATTACHMENT,
					     gl.GL_RENDERBUFFER,
					     _depthRBID);
	    }
            checkFBOComplete(_fboID);  
            // release
            gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, 0);
            // add multisample framebuffer + renderbuffers
            if (_samples > 0) {
                // create ms framebuffer object
                gl.glGenFramebuffers(1, buffer);
                _msfboID = buffer.get(0);
                gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, _msfboID);
                // create ms renderbuffers
                gl.glGenRenderbuffers(1, buffer); 
                _mscolorRBID = buffer.get(0);
                gl.glGenRenderbuffers(1, buffer); 
                _msdepthRBID = buffer.get(0);
                // set up renderbuffer properties
                gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, _mscolorRBID);
                gl.glRenderbufferStorageMultisample(GL.GL_RENDERBUFFER, 
                                                    _samples, 
						    GL.GL_RGBA, 
						    pot_width, pot_height);

                gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, _msdepthRBID);
                gl.glRenderbufferStorageMultisample(GL.GL_RENDERBUFFER, _samples, 
                                                    format, pot_width, pot_height);

                gl.glBindRenderbuffer(GL.GL_RENDERBUFFER, 0);


		gl.glFramebufferTexture2D(GL.GL_FRAMEBUFFER, 
					  GL.GL_COLOR_ATTACHMENT0, 
					  GL.GL_TEXTURE_2D, textureId, 0);

                gl.glFramebufferRenderbuffer(GL.GL_FRAMEBUFFER, GL.GL_COLOR_ATTACHMENT0,
                        GL.GL_RENDERBUFFER, _mscolorRBID);
                gl.glFramebufferRenderbuffer(GL.GL_FRAMEBUFFER, GL.GL_DEPTH_ATTACHMENT,
                        GL.GL_RENDERBUFFER, _msdepthRBID);
                // check for errors
                checkFBOComplete(_msfboID);
                // release
                gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, 0);
            }
        }
        bindFrameBuffer();
     }

    function bindFrameBuffer to ()
    {
	if (_samples > 0) {
	    gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, _msfboID);
	}  else {
	    gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, _fboID);
	}
	//gl.glViewport(0, 0, _width, _height);
	//println("bound frame buffer {_fboID} {_msfboID}, viewport {_width} {_height}");
    }

    function checkFBOComplete from (fboID is Integer) to ()
    {
        var status = gl.glCheckFramebufferStatus(GL.GL_FRAMEBUFFER);
        if (status == GL.GL_FRAMEBUFFER_COMPLETE) {
	    println("frame buffer complete");
        } else if (status == GL.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT exception");
        } else if (status == GL.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT exception");
        } else if (status == GL.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS exception");
        } else if (status == GL2.GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER exception");
        } else if (status == GL.GL_FRAMEBUFFER_INCOMPLETE_FORMATS) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_FORMATS exception");
        } else if (status == GL2.GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER exception");
        } else if (status == GL.GL_FRAMEBUFFER_UNSUPPORTED) {
            throw new IllegalStateException("FrameBuffer {fboID} has caused a GL_FRAMEBUFFER_UNSUPPORTED exception");
        } else if (status == GL2.GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE) {
            throw new IllegalStateException("FrameBuffer: {fboID} has caused a GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE exception.");
        }
    }

    function blitMSFBO to () 
    {
        if (_samples > 0) {
            gl.glBindFramebuffer(GL2.GL_READ_FRAMEBUFFER, _msfboID);
            gl.glBindFramebuffer(GL2.GL_DRAW_FRAMEBUFFER, _fboID);
            var bits is Integer = GL.GL_COLOR_BUFFER_BIT;
            if (_depthBits > 0) {
                bits = Bits.add(bits, GL.GL_DEPTH_BUFFER_BIT);
            }
            gl.glBlitFramebuffer(0, 0, pot_width, pot_height, 
                                 0, 0, pot_width, pot_height, 
                                 bits, GL.GL_NEAREST);
            //println("blitting framebuffer {_msfboID} {_fboID} {_width} {_height} {pot_width} {pot_height}");
        }
        if (false) {
            tex.bind(gl);
            gl.glGenerateMipmap(tex.getTarget());
        }
        gl.glBindFramebuffer(GL2.GL_READ_FRAMEBUFFER, 0);
        gl.glBindFramebuffer(GL2.GL_DRAW_FRAMEBUFFER, 0);
        gl.glBindFramebuffer(GL.GL_FRAMEBUFFER, 0);
    }

    override function finalize  {
        org.f3.runtime.Entry.deferAction(java.lang.Runnable {
                override function run {
		    cleanup();
		}
	    });
    }

    function cleanup 
    {
        if (_fboID <> 0) {
            const id = BufferUtils.createIntBuffer(1);
            id.put(_fboID);
            id.rewind();
            gl.glDeleteFramebuffers(id.limit(), id);
	    _fboID = 0;
        }
        if (_depthRBID <> 0) {
            const id = BufferUtils.createIntBuffer(1);
            id.put(_depthRBID);
            id.rewind();
            gl.glDeleteRenderbuffers(id.limit(), id);
        }
    }

    function setupForDraw
    {
	gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, _fboID);
        gl.glDrawBuffer(GL.GL_COLOR_ATTACHMENT0);
        gl.glReadBuffer(GL.GL_COLOR_ATTACHMENT0);
        if (_samples > 0) {
            gl.glBindFramebuffer(gl.GL_READ_FRAMEBUFFER, _msfboID);
            gl.glBindFramebuffer(gl.GL_DRAW_FRAMEBUFFER, _msfboID);
        } 
    }

    function push to ()
    {
        activate()
    }

    function pop to () 
    {
        stageRenderer.parent.activate();        
    }

}

class JoglTexture is AbstractTexture 
{
    public var tex is Texture;
    public const gl is GL2;
    public const id is String;
    public var width = bind tex.getWidth();
    public var height = bind tex.getHeight();
    override function getTextureId to Integer 
    {
        tex.getTextureObject(gl);
    }
    override function toString to String 
    {
        "Texture {id}";
    }
    override function getWidth to Integer 
    {
	tex.getWidth()
    }
    override function getHeight to Integer 
    {
	tex.getHeight()
    }
}

class JoglImageLoader is ImageLoader {
    const glp is GLProfile = GLProfile.get("GL2");
    var gl is GL2;
    const loaded = new java.util.HashMap of (String, java.lang.ref.WeakReference of Texture);

    override public function loadImage from (url is String)
	to AbstractTexture 
    {
        try {
            var result = loadTexture2D0(url);

	    return result;
        } catch (t is java.lang.Throwable) {
            t.printStackTrace();
        }
        return null;
    }

    function loadTexture2D0
	from (url is String)
	to AbstractTexture 
    {
        const loweredUrl = url.toLowerCase();
        if (loweredUrl.endsWith(".mp4") or loweredUrl.endsWith(".mov") or loweredUrl.endsWith(".wmv")) {
            return Movie { url: url };
	}
        const ref = loaded.get(url) as java.lang.ref.WeakReference;
        var texture is Texture = ref.get() as Texture;
        if (texture == null) {
            if (true) {
                var im is java.awt.Image;
                var tWidth is Integer;
                var tHeight is Integer;
                var w is Integer;
                var h is Integer;
                if (loweredUrl.endsWith(".png")) {
                    try {
                        const decoder = new PNGDecoder(new java.io.BufferedInputStream(new java.net.URL(url).openStream()));
                        tWidth = decoder.getWidth();
                        tHeight = decoder.getHeight();
                        var buffer = BufferUtils.createByteBuffer(4*tWidth*tHeight);
                        decoder.decode(buffer, tWidth*4, 
                                       PNGDecoder.TextureFormat.RGBA);
                        w = pot(tWidth);
                        h = pot(tHeight);
                        if (w <> tWidth or h <> tHeight) {
                            var glu = new GLUgl2();
                            var potBuffer = BufferUtils.createByteBuffer(4*w*h);
                            buffer.rewind();
                            glu.gluScaleImage(GL.GL_RGBA, tWidth, tHeight,
                                              GL.GL_UNSIGNED_BYTE,
                                              buffer, w, h, GL.GL_UNSIGNED_BYTE,
                                              potBuffer);
                            buffer = potBuffer;
                        }
                        buffer.rewind();
                        texture = TextureIO.newTexture(new TextureData(glp,
                                                                       GL.GL_RGBA8,
                                                                       w, h,
                                                                       0,
                                                                       GL2.GL_RGBA,
                                                                       GL2.GL_UNSIGNED_BYTE,
                                                                       false,
                                                                       false,
                                                                       true,
                                                                       buffer,
                                                                       null));
                    } catch (e is java.lang.Exception) {
                        println("warning: PNG decoder failed {url}: {e.getMessage()}");
                    }
                }
                if (texture == null) {
                    // read image
                    im = 
                        if (loweredUrl.endsWith(".jpg")) then {
                                javax.imageio.ImageIO.setUseCache(false);
                                javax.imageio.ImageIO.read(new java.net.URL(url));
                            } else {
                            Imaging.getBufferedImage(new java.net.URL(url).openStream());
                        };
                    tWidth = im.getWidth(null);
                    tHeight = im.getHeight(null);
                    w = pot(tWidth);
                    h = pot(tHeight);
                    var tFlippedBufferedImage = 
                        new java.awt.image.BufferedImage(w, h,
                                                         java.awt.image.BufferedImage.TYPE_INT_ARGB);
                    var tG2D = tFlippedBufferedImage.createGraphics(); 
                    tG2D.drawImage(im,
                                   0, h, w, 0, 
                                   0, 0, tWidth, tHeight,
                                   null); 
                    tG2D.dispose(); 
                    texture = AWTTextureIO.newTexture(glp, tFlippedBufferedImage, true);
                }
                texture = TextureIO.newTexture(texture.getTextureObject(gl),
                                               texture.getTarget(),
                                               tWidth,
                                               tHeight,
                                               w,
                                               h,
                                               texture.getMustFlipVertically());

            } else {
                texture = TextureIO.newTexture(new java.net.URL(url), false, null);
            }
            println("loaded texture {url}");
            loaded.put(url, new java.lang.ref.WeakReference of Texture(texture));
        } else {
            texture = TextureIO.newTexture(texture.getTextureObject(gl),
                                           texture.getTarget(),
                                           texture.getWidth(),
                                           texture.getHeight(),
                                           texture.getImageWidth(),
                                           texture.getImageHeight(),
                                           texture.getMustFlipVertically());
        }
        texture.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_S, GL.GL_REPEAT);
        texture.setTexParameteri(gl, GL.GL_TEXTURE_WRAP_T, GL.GL_REPEAT);
        texture.setTexParameteri(gl, GL.GL_TEXTURE_MIN_FILTER, GL.GL_LINEAR);
        texture.setTexParameteri(gl, GL.GL_TEXTURE_MAG_FILTER, GL.GL_LINEAR);
        JoglTexture {
            id: url;
            gl: gl;
            tex: texture;
        }
    }
}

public class DrawInfo {
    public var shader is Shader;
    public var worldBounds is Bounds;
    public var scissorBounds is Bounds;
    public const shaderParams = new java.util.HashMap of (String, Object);
    public var mesh is AbstractMesh;
}

public class TextDrawInfo is DrawInfo {
    public var renderer is TextRenderer2D;
    public var layout is Text.Layout;
    public var tex is MeshNode;
    public var background is Paint;
    public var foreground is Paint;
}

public class StageRenderer {
    public var topLevel is Boolean = false;
    public var parent is StageRenderer;
    public var activate is function from () to ();
    public var cursor is Cursor;
    public var stage is Stage;
    public var sceneRenderers is SceneRenderer[];
    var lastWidth is Integer;
    var lastHeight is Integer;
    function startDraw from () to () {
	activate();
    }
    function endDraw from () to () {
    }

    function onDraw 
	from (transparent is Integer, 
	      transpTris is Integer, 
	      opaque is Integer, 
	      opaqueTris is Integer)
	to ()
    {
    }

    var m1 = 0;
    var m2 = 0;
    var t1 = 0;
    var t2 = 0;

    public function renderScenes from (gl is GL2, width is Integer, height is Integer) to Boolean
    {
	var dirty = /*topLevel or*/ cursor <> stage.cursor;
        if (dirty) {
            if (topLevel) {
                if (DEBUG_DRAW) {
                    println("dirty due to top level");
                }
            }  else {
                if (DEBUG_DRAW) {
                    println("dirty due to cursor");
                }
            }
        }
	if (lastWidth <> width) {
	    dirty = true;
	    lastWidth = width;
            if (DEBUG_DRAW) {
                println("dirty due to width change");
            }
	}
	if (lastHeight <> height){
	    dirty = true;
	    lastHeight = height;
            if (DEBUG_DRAW) {
                println("dirty due to height change");
            }
	}
	const self = this;
	cursor = stage.cursor;
	if ((foreach (r in sceneRenderers) r.scene) <> stage.content) {
	    dirty = true;
            if (DEBUG_DRAW) {
                println("dirty due to scenes changed");
            }
	    sceneRenderers = 
		foreach (scene in stage.content) {
                var s = SceneRenderer {gl:gl};
                s.scene = scene;
                s.parent = parent;
                s
            }
	}
        for (sceneRenderer in sceneRenderers) {
	    if (sceneRenderer.checkNeedsDraw(gl, width, height)) {
		dirty = true;
                if (DEBUG_DRAW) {
                    println("dirty due to scene {sceneRenderer.scene}");
                }
	    }
	}
	if (dirty) {
	    startDraw();
            gl.glViewport(0, 0, width, height);
	    for (sceneRenderer in sceneRenderers) {
		sceneRenderer.renderScene(gl, width, height, sceneRenderer.scene.camera);
                sceneRenderer.scene.fireRenderComplete();
	    }
	    endDraw();
	    onDraw(m1, t1, m2, t2);
	    m1 = 0;
	    m2 = 0;
	    t1 = 0;
	    t2 = 0;
	}
	return dirty;
    }
}

class SurfaceRenderer is StageRenderer {
    public var surface is OffscreenSurface;
    override function startDraw {
        surface.push();
        surface.setupForDraw();
    }
    override function endDraw {
        surface.blitMSFBO();
        surface.pop();
    }
}

public class SceneRenderer {
    public var gl is GL2;
    var phongShader is Shader;
    var transparentToDraw = new java.util.ArrayList of MeshNode;
    var last2DDraw = new java.util.ArrayList of MeshNode;
    var opaqueToDraw = new java.util.ArrayList of MeshNode;
    public var parent is StageRenderer;

    function renderStageNode 
	from (gl is GL2, stageNode is StageNode)
	to Boolean
    {
        var surface = stageNode.drawingSurface as OffscreenSurface;
        if (surface == null) {
            const scale = if not DISABLE_SUPERSAMPLE then stageNode.superSample else 1;
            surface = OffscreenSurface {
                gl: gl;
                override var width = bind Math.min(4096, stageNode.width * scale);
                override var height = bind Math.min(4096, stageNode.height * scale);
            }
	    surface.stageRenderer = SurfaceRenderer {
		stage: stageNode;
                surface: surface;
	    };
            surface.stageRenderer.activate = surface.activate;
            stageNode.drawingSurface = surface;
        }
	//println("scene renderer = {surface.sceneRenderer}");
        surface.stageRenderer.parent = this.parent;
        for (scene in stageNode.content) {
	    scene.stage = stageNode;
	}
        var result = surface.stageRenderer.renderScenes(gl, surface.width, surface.height);
	//if (result) {
	    //println("rendering stage node {gl} {stageNode}");
	    // println("done rendering stage node => {result}");
	//}
	return result;
    }

    var offscreenToRender = new java.util.HashSet of StageNode;
    var lastDrawn = new java.util.HashMap of (MeshNode, DrawInfo);
    var viewMatrix is Mat4;
    var projectionMatrix is Mat4;
    var lightPositions is Point3[];
    var lastCamera is Camera;

    var renderer2D is java.util.Map of (Scene, SceneRenderer2D) = new java.util.WeakHashMap of (Scene, SceneRenderer2D) ;
    function getRenderer2D from (scene is Scene, gl is GL2) to SceneRenderer2D 
    {
	var r = renderer2D.get(scene);
	if (r == null) {
	    r = SceneRenderer2D {
		gl: gl;
		glp: GLProfile.get("GL2");
	    }
	    renderer2D.put(scene, r);
	}
	return r;
    }

    var lastWidth = 0.0;
    var lastHeight = 0.0;

    var lastVisible = true;


    function checkNeedsDraw
	from (gl is GL2, 
	      width is Number, 
	      height is Number)
	to Boolean
    {
        opaqueToDraw.clear();
	var iter is java.util.Iterator of MeshNode;
	last2DDraw.clear();
	if (scene.camera is Camera2D) {
	    last2DDraw.addAll(transparentToDraw);
	    iter = last2DDraw.iterator();
	}
        transparentToDraw.clear();
        offscreenToRender.clear();
        var opaqueTris = 0;
        var transparentTris = 0;
        var lights is PointLight[];
        var dirty = lastWidth <> width or lastHeight <> height;
        if (dirty) {
        //            firstTime = true;
        }
	if (scene.visible <> lastVisible) {
	    dirty = true;
            if (DEBUG_DRAW) {
                println("dirty to scene visibility change {scene} {scene.visible}");
            }
	    lastVisible = scene.visible;
	} else if (not scene.visible) {
	    return false;
	}
	lastWidth = width;
	lastHeight = height;
	//println("scene.root={scene.root} => {scene.content}");
	scene.update();
        //scene.update(); // hack: necessary to prevent flashing
	const visited = new java.util.HashSet of Node;
	const thisDraw = new java.util.HashMap of (MeshNode, DrawInfo);
        var deformerFutures is (function to ())[];
        const vf = function from (_ is (), n is Node) to () {
	    if (n.toSceneTransform == null) {
		println("no scene transform: {n.id} => {n.toSceneTransform} parent={n.parent.id}");
		return;
	    }
	    if (visited.contains(n)) {
		//java.lang.Thread.currentThread().dumpStack();
                if (DEBUG_HIERARCHY) println("node occurs multiply in hierarchy: {n} => {visited}");
		return;
	    }
	    visited.add(n);
            if (n.bounds.extent == Tuple3.<<0>>) {
                if (lastDrawn.containsKey(n)) {
                    dirty = true;
                }
                return;
            }
	    if (n.visibleInScene) {
		var debug = false;
		var par = n;
		while (par <> null) {
		    if (par.debug) {
			debug = true;		       
			break;
		    }
		    par = par.parent;
		}
		par = n.parent;
                var scissorBounds is Bounds = null;
		if (scene.camera is Camera2D) while (par <> null and not (par is Stage)) {
		    if (par is Scissored) {
                        const sciss = (par as Scissored).scissorBounds;
                        if (sciss != null) {
                            const sb = par.toSceneTransform * sciss;
                            if (Bounds.intersect(sb, n.boundsInScene) == null) {
                                if (DEBUG_DRAW) {
                                    println("scissor cull {par} / {sb} of {n} / {n.boundsInScene}");
                                }
                                if (lastDrawn.containsKey(n)) {
                                    if (DEBUG_DRAW) {
                                        println("scissor cull {par} / {sb} of {n} / {n.boundsInScene}");
                                        println("dirty due to scissor cull change {n}");
                                    }
                                    //dirty = true;
                                }
                                return ();
                            }
                            if (scissorBounds == null) {
                                scissorBounds = sb;
                            } else {
                                scissorBounds = Bounds.intersect(sb, scissorBounds);
                            }
                        }
		    }
		    par = par.parent;
		}
		if (n is Shape2D.MeshNode2D) {
		    const shape = n as Shape2D.MeshNode2D;
		    if (shape.shader == null) {
			if (shape.paint is Shape2D.ColorPaint) {
			    readonly var paint = bind shape.paint as Shape2D.ColorPaint;
			    if (paint is Shape2D.TexturePaint) {
				var tex = 
				    bind (paint as Shape2D.TexturePaint).texture;
				shape.shader = TexturePaintShader {
				    color: bind paint.color;
				    tex: bind tex;
				}
			    } else {
				shape.shader = ColorPaintShader {
				    color: bind paint.color;
				}
			    }
			} else if (shape.paint is Shape2D.GradientPaint) {
			    const gradient = shape.paint as Shape2D.GradientPaint;
			    shape.shader = makeGradientShader(gl, gradient);
			}
                        //			println("creating shader for {shape} => {shape.shader}");
                        if (DEBUG_DRAW) {
                            println("dirty due to shader update {n} {shape.shader}");
                        }
                        dirty = true;
		    }
		} 
		if (n is MeshNode) {
		    var mn = n as MeshNode;
		    if (not DISABLE_DEFORMERS) {
			for (deformer in mn.deformers) {
			    //println("applying deformer {deformer} to {mn}");
                            try {
                                const f = deformer.apply(mn);
                                insert function to () {
                                    f();
                                    mn.mesh.updateBounds();
                                } into deformerFutures;
                            } catch (e is java.lang.Throwable) {
                                e.printStackTrace();
                            }
			    //println("bounds is now {mn.mesh.bounds}");
			}
		    }
		    if (scene.camera.contains(mn.boundsInScene)) {
			const shader = mn.shader;
			if (mn.shader <> null) {
			    for (p in (mn.shader as CGFXShader).parameters) {
				const value = (p as CGFXShader.Parameter of Object).get();
				if (value is StageNode) {
				    const stageNode = value as StageNode;
				    //if (renderStageNode(gl, stageNode)) {
				    //dirty = true;
				    //}
				    offscreenToRender.add(stageNode);
				} else if (value is WebBrowserNode) {
				    if ((value as WebBrowserNode).updateTexture()) {
                                        if (DEBUG_DRAW) {
                                            println("dirty due to texture update {value}");
                                        }
					dirty = true;
				    }
				}
			    }
			} 
                        if (mn is WebBrowserNode) {
                            if ((mn as WebBrowserNode).updateTexture()) {
                                if (DEBUG_DRAW) {
                                    println("dirty due to texture update {mn}");
                                } 
                                dirty = true;
                            } else {
                                if (DEBUG_DRAW) {
                                    println("not dirty due to texture update {mn}");
                                } 
                            }
                        }
			var tris is Integer;
                        if (not checkMesh(mn)) {
                            return ();
                        }
                        tris = mn.mesh.getIndexBuffer().limit() / 3;        
			var info = lastDrawn.get(mn);
			const cgfx = mn.shader as CGFXShader;
			cgfx.updateParameters();
			if (info == null) {
			    dirty = true;
			    if (DEBUG_DRAW) {
				println("dirty due to new mesh {mn}");
			    }
			    if (ENABLE_TEXTURED_TEXT and scene.camera is Camera2D and mn is Text.TextMeshNode and { const tn = mn as Text.TextMeshNode; tn.getText().background <> null }) {
				info = TextDrawInfo {
				    renderer: TextRenderer2D {
					gl: gl
				    }
				}
			    } else {
				info = DrawInfo {
				}
			    }
			    if (DEBUG_DRAW) {
				println("created draw info {info} for {mn}");
			    }
			} else {
			    if (not dirty) {
				if (info.mesh <> mn.mesh or
				    info.worldBounds <> mn.boundsInScene) {
				    dirty = true;
				    if (DEBUG_DRAW) {
                                        if (info.mesh <> mn.mesh) {
                                            println("dirty due to new mesh {mn}");
                                        } else {
                                            println("dirty due to bounds change {mn}, {info.worldBounds} {mn.boundsInScene}");
                                        }
				    }
				}
                                if (info.scissorBounds <> scissorBounds) {
                                    if (DEBUG_DRAW) {
                                        println("dirty due to scissorBounds change {n}");
                                    }
                                    dirty = true;
                                }
				if (info.shader <> mn.shader) {
				    dirty = true;
				    if (DEBUG_DRAW) {
					println("is dirty due to shader change {info.shader} => {mn.shader}");
				    }
				}
				if (not dirty) {
				    for (p in cgfx.parameters) {
					const x = p.get() as Object;
					const y = info.shaderParams.get(p.name);
					if (x <> y) {
					    if (DEBUG_DRAW) {
						println("is dirty: {mn}: {p.name}");
					    }
					    dirty = true;
					    break;
					} else {
                                            if (x is Movie) {
                                                const movie = x as Movie;
                                                if (movie.updateTexture()) {
                                                    if (DEBUG_DRAW) {
                                                        println("is dirty: {mn}: {p.name}");
                                                    }
                                                    dirty = true;
                                                    break;
                                                }
                                            }
                                        }
				    }
				}
			    }
			}
			info.mesh = mn.mesh;
			info.shader = mn.shader;
			info.worldBounds = mn.boundsInScene;
                        info.scissorBounds = scissorBounds;
			const key = mn;
			if (info is TextDrawInfo) {
			    const ti = info as TextDrawInfo;
			    const tn = mn as Text.TextMeshNode;
			    if (ti.tex == null or 
				ti.layout <> tn.getLayout() or 
				ti.background <> tn.background or
				ti.foreground <> tn.paint) {
                                if (DEBUG_DRAW) {
                                    println("dirty due text draw change {tn}");
                                }
				dirty = true;
				ti.tex = ti.renderer.render(mn as Text.TextMeshNode);
				//println("rendered {mn}");
				ti.layout = tn.getLayout();
				ti.background = tn.background;
				ti.foreground = tn.paint;
			    }
			    mn = ti.tex;
			}
			if ((scene.camera is Camera2D) or shader.isTransparent or (mn is Shape2D.MeshNode2D)) {
			    transparentToDraw.add(mn);
			    transparentTris += tris;
			} else {
			    opaqueToDraw.add(mn);
			    opaqueTris += tris;
			}
                        info.scissorBounds = scissorBounds;
			for (i in (mn.shader as CGFXShader).parameters) {
			    info.shaderParams.put(i.name, i.get());
			}
			thisDraw.put(key, info);
			if (scene.camera is Camera2D and not dirty) {
			    if (not iter.hasNext() or iter.next() <> mn) {
				dirty = true;
                                if (DEBUG_DRAW) {
                                    println("dirty due to hierarchy change {mn}");
                                }
			    }
			}
			//println("thisDraw {mn}: {thisDraw.size()}");
		    } else {
			if (DEBUG_DRAW) {
			    println("culled {n} {n.id} {n.boundsInScene}");
			}
			if (lastDrawn.containsKey(mn)) {
			    dirty = true;
			    if (DEBUG_DRAW) {
				println("is dirty: culled {n}");
			    }
			}
		    }
		}
	    } else if (n is MeshNode) {
		if (lastDrawn.containsKey(n as MeshNode)) {
		    dirty = true;
		    if (DEBUG_DRAW) {
			println("is dirty: visibility {n}");
		    }
		}
	    }
            return ();
	};
        lights = scene.visibleLights;
        for (i in scene.visibleMeshes) {
	    vf((), i);
	}
        for (v in deformerFutures) v();
	for (i in offscreenToRender) {
	    if (renderStageNode(gl, i as StageNode)) {
                dirty = true;
                if (DEBUG_DRAW) {
                    println("dirty due to stage node {i}");
                }
	    }
	}	
        offscreenToRender.clear();
	//println("last: {lastDrawn.size()}");
	//println("current: {thisDraw.size()}");
	for (x in lastDrawn.keySet()) {
	    if (not thisDraw.containsKey(x)) {
		dirty = true;
		if (DEBUG_DRAW) {
		    println("dirty due to no longer drawing: {x}");
		}
	    }
	}
	lastDrawn = thisDraw;
        var camera = scene.camera;
	if (not dirty) {
	    if (camera.viewMatrix <> viewMatrix) {
		dirty = true;
		if (DEBUG_DRAW) {
		    println("needs draw due to camera view");
		}
		viewMatrix = camera.viewMatrix;
	    }
	    if (camera.projectionMatrix <> projectionMatrix) {
		dirty = true;
		if (DEBUG_DRAW) {
		    println("needs draw due to camera projection");
		}
		projectionMatrix = camera.projectionMatrix;
	    }
	}

        var positions is Point3[] = foreach (light in lights) light.location;
        positions = Sequences.sort(positions);
	//println("light positions = {positions}");
        if (positions <> lightPositions) {
            lightPositions = positions;
            dirty = true;
	    if (DEBUG_DRAW or DEBUG_LIGHTS) {
		println("needs draw due to light positions");
	    }
        }
        if (scene.camera <> lastCamera) {
            lastCamera = scene.camera;
            dirty = true;
	    if (DEBUG_DRAW) {
		println("needs draw due to camera change {lastCamera} => {camera}");
	    }
        }
	//println("check {scene} dirty={dirty}");
	if (dirty) {
	    onDraw(transparentToDraw.size(), transparentTris, opaqueToDraw.size(), opaqueTris);
	}        
	return dirty;
    }

    public var scene is Scene;

    var firstTime = true;

    function renderScene
	from (gl is GL2, 
	      width is Number, 
	      height is Number,
              camera is Camera)
	to ()
    {
	if (not scene.visible) return;
	camera.update();
	if (ENABLE_2D_RENDERER and camera is Camera2D) {
	    var canUse2d = true;
	    for (x in  transparentToDraw) {
		if (not (x is Shape2D.MeshNode2D)) {
		    canUse2d = false;
		    break;
		}
	    }
	    if (canUse2d) {
		const cam = camera as Camera2D;
		const r = getRenderer2D(scene, gl);
		r.render2d(cam, scene);
		transparentToDraw.clear();
		transparentToDraw.add(r.meshNode);
	    } 
	}
        disableScissorTest();
        if (scene.background.opacity <> 0) {
            const bg = scene.background;
	    //println("clearing {bg}");
            gl.glClearColor(bg.red, bg.green, bg.blue, bg.opacity);
            gl.glClear(Bits.add(GL.GL_COLOR_BUFFER_BIT, GL.GL_DEPTH_BUFFER_BIT));
        } else if (firstTime) {
            gl.glClearColor(.5, .5, .5, 1);
            gl.glClear(Bits.add(GL.GL_COLOR_BUFFER_BIT, GL.GL_DEPTH_BUFFER_BIT));
            firstTime = false;
        } else {
            gl.glClear(GL.GL_DEPTH_BUFFER_BIT);
        }
	if (not (camera is Camera2D)) {
	    // sort opaque front to back      
	    java.util.Collections.sort(opaqueToDraw, java.util.Comparator of MeshNode {
		    override public function compare
			from (x is MeshNode, y is MeshNode)
			to Integer 
		    {
			const xz = camera.distanceTo(x.toSceneTransform.getTranslation());
			const yz = camera.distanceTo(y.toSceneTransform.getTranslation());
			const cmp = xz - yz;
			return if (cmp < 0) then -1 else if (cmp > 0) then 1 else 0;
		    }
		});
	    //sort transparent back to front
	    java.util.Collections.sort(transparentToDraw, java.util.Comparator of MeshNode {
		    override public function compare
			from (x is MeshNode, y is MeshNode)
			to Integer 
		    {
			const xz = camera.distanceTo(x.toSceneTransform.getTranslation());
			const yz = camera.distanceTo(y.toSceneTransform.getTranslation());
			const cmp = xz - yz;
			return if (cmp < 0) then 1 else if (cmp > 0) then -1 else 0;
		    }
		});
	} 
	//println("DRAW: {scene} {camera}");
        draw(gl, scene.root.parent, camera, opaqueToDraw, lightPositions);
        opaqueToDraw.clear();
        draw(gl, scene.root.parent, camera, transparentToDraw, lightPositions);
        //camera.needsDraw = false;
        return true;
    }

    function onDraw 
        from (transparent is Integer, 
              transpTris is Integer, 
              opaque is Integer, 
              opaqueTris is Integer)
        to ()
    {
        //println("draw  {scene} {transparent}/{transpTris}, {opaque}/{opaqueTris}");
        parent.m1 += transparent;
        parent.t1 += transpTris;
        parent.m2 += opaque;
        parent.t2 += opaqueTris;
    }

    var polygonMode = PolygonMode.Fill;

    var currentScissor is Bounds;

    function draw
	from (gl is GL2,
	      sceneParent is Node,
	      camera is Camera, 
	      toDraw is java.util.List of MeshNode, 
	      lights is Point3[])
	to ()
    {
        const cameraLight = camera.toSceneTransform.getTranslation();
	const sceneParentInverse = if (sceneParent == null) Mat4.<<1>> else sceneParent.toSceneTransform.inverse();
	/*
	gl.glPolygonOffset(1, 1);
	gl.glEnable(GL.GL_POLYGON_OFFSET_FILL);

	if (camera instanceof Camera2D) {
	    disableDepth = true;
	} 
	*/
	var prev is Node = null;
        disableScissorTest();
        currentScissor = null;
	gl.glPolygonMode(GL.GL_FRONT_AND_BACK, GL2.GL_FILL);
        for (n in toDraw) {
	    prev = n;
            const mn = n as MeshNode;
            try {
                draw1(gl, sceneParent, camera, prev, cameraLight, lights, sceneParentInverse, mn);
            } catch (e is java.lang.Exception) {
                e.printStackTrace();
            }
        }
    }
    

    var scissoring is Boolean;

    function enableScissorTest to ()
    {
        if (not scissoring) {
            scissoring = true;
            gl.glEnable(GL.GL_SCISSOR_TEST);
        }
    }

    function disableScissorTest to ()
    {
        if (scissoring) {
            scissoring = false;
            gl.glDisable(GL.GL_SCISSOR_TEST);
        }
    }
        


    function draw1 from (gl is GL2,
                         sceneParent is Node,
                         camera is Camera, 
                         prev is Node, 
                         cameraLight is Point3,
                         lights is Point3[],
                         sceneParentInverse is Mat4, 
                         mn is MeshNode) to () 
    {
	var disableDepth = false;
        var n = mn;
	    if (mn instanceof Shape2D.MeshNode2D) {
		if (prev instanceof Shape2D.MeshNode2D) {
		    const t0 = mn.toSceneTransform.getTranslation().z;
		    const t1 = mn.toSceneTransform.getTranslation().z;
		    if (t0 == t1) {
			disableDepth = true;
		    }
		}
	    }
	    var scissor is Node = null;
	    var mp = n.parent;
            var sbounds is Bounds = null;
	    while (mp <> null and not (mp is Stage)) {
		if (mp instanceof Scissored and (mp as Scissored).scissorBounds <> null) {
                    if (DEBUG_SCISSOR) {
                        println("scissoring: {mp}");
                        println("scissorBounds: {(mp as Scissored).scissorBounds}");
                        println("world: {mp.toSceneTransform * (mp as Scissored).scissorBounds}");
                    }
                    const pb = sbounds;
                    if (scissor <> null) {
                        sbounds = Bounds.intersect(sbounds, mp.toSceneTransform * (mp as Scissored).scissorBounds);                        
                    } else {
                        scissor = mp;
                        sbounds = mp.toSceneTransform * (scissor as Scissored).scissorBounds;
                    }
                    if (DEBUG_SCISSOR) {
                        println("intersecting: {pb} => {sbounds}");
                    }
		}
		mp = mp.parent;
	    }
	    if (sbounds <> currentScissor) {
		currentScissor = sbounds;
 		if (not DISABLE_SCISSOR and camera is Camera2D and sbounds <> null) {
		    const bounds = sbounds;
		    const sb = bounds;//camera.toScreen(bounds);
                    const x = camera.width/2 + sb.center.x - sb.extent.x;
                    const y = camera.height/2 + sb.center.y - sb.extent.y;
                    const w = sb.extent.x*2;
                    const h = sb.extent.y*2;
                    if (DEBUG_SCISSOR) {
                       println("glScissor {x},{y},{w},{h}");
                    }
		    enableScissorTest();
		    gl.glScissor(x, y, w, h);
		} else {
		    disableScissorTest();
		}
	    }

	    //println("drawing {n}");
	    var toSceneTransform = if (sceneParent == null) then mn.toSceneTransform else sceneParentInverse * mn.toSceneTransform;
            const mesh = mn.mesh;
	    if (mn is Text.TextMeshNode)  {
                if (camera is Camera2D) {
                    if (toSceneTransform.getRotation() == Quat.<<1>>) {
                        const t = toSceneTransform.getTranslation();
                        const tn = mn as Text.TextMeshNode;
                        //const b = tn.getLayout().getShape().getBounds();
                        //const x = if (tn.getText().rightJustified) then b.right() else b.left();
                        //const dx = x - Math.round(x);
                        //const dy = b.bottom() - Math.round(b.bottom());
                        const vm = camera.viewMatrix;
//                        println("viewMatrix={vm.getTranslation()}");
//                        println("scene={scene.width}, {scene.height}");
                        toSceneTransform = translate(Math.round(t.x),
                                                     Math.round(t.y),
                                                     0);
                        //println("grid fit: {tn.getText().text} {t} => {toSceneTransform.getTranslation()}");
                    } else {
                        println("text was rotated {toSceneTransform.getTranslation()}");
                        const t = toSceneTransform.getTranslation();
                        toSceneTransform *= translate(t.x-Math.round(t.x),
                                                      t.y-Math.round(t.y),
                                                      0);
                    }
                } else {
//                    println("camera is : {camera}");
                }
	    } else if (camera is Camera2D) {
                if (mn is Shape2D.MeshNode2D and (mn as Shape2D.MeshNode2D).gridFit) {
                    if (toSceneTransform.getRotation() == Quat.<<1>>) {
                        const t = toSceneTransform.getTranslation();
                        toSceneTransform = translate(Math.round(t.x),
                                                     Math.round(t.y),
                                                     0);
                        /*
                        println("grid fit {mn} => {toSceneTransform.getTranslation()}");
                        var p = mn.parent;
                        while (p <> null) {
                              println(p);
                              p = p.parent;
                        }
                        */
                    }
                }
		if (mesh.polygonMode == PolygonMode.Line) {
		    if (toSceneTransform.getRotation() == Quat.<<1>>) {
			const t = mn.toSceneTransform.getTranslation();
			toSceneTransform = translate(Math.round(t.x),
						     Math.round(t.y),
						     0);
		    }
		}
	    } 
	    if (DEBUG_MESHES) println("drawing {mn}");

            const indexBuffer = mesh.getIndexBuffer();
            const vertexBuffer = mesh.getVertexBuffer();
            const normalBuffer = mesh.getNormalBuffer();
	    var badtex = false;
	    for (texb in mesh.getTextureBuffers()) {
	    	if (texb.limit() == 0) {
		    badtex = true;
		    println("bad texture coordinates in {mn}");
		}
	    }
	    if (badtex) {
		return;
	    }
            var shader = mn.shader;
	    //println("shader={shader}");
            const texParams = 
		foreach (p in shader.getParameters() where p instanceof CGFXShader.SamplerParameter) p as CGFXShader.SamplerParameter;
            if (DEBUG_USE_DEFAULT_SHADER or shader == null) {
                if (phongShader == null) {
                    phongShader = (the CGEffectLoader).loadDefaultShader(null,
									 Color.GRAY,
									 Color.BLACK,
									 Color.BLACK,
									 Color.GRAY,
									 20);
                }
                shader = phongShader;
            }
            var vbo = getVBO(gl, mesh);
            vertexBuffer.rewind();
            gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
            if (vbo <> null) {
                gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vbo.vertexBuffer);
                gl.glVertexPointer(mesh.vertices.getCoordsPerVertex(), 
                                   GL.GL_FLOAT, 0, 0);
            } else {
                vertexBuffer.rewind();
                gl.glVertexPointer(mesh.vertices.getCoordsPerVertex(), 
                                   GL.GL_FLOAT, 0, vertexBuffer);
            }
            if (normalBuffer == null) {
                gl.glDisableClientState(GL2.GL_NORMAL_ARRAY);
            } else {
                gl.glEnableClientState(GL2.GL_NORMAL_ARRAY);
                if (vbo <> null) {
                    gl.glBindBuffer(gl.GL_ARRAY_BUFFER, vbo.normalBuffer);
                    gl.glNormalPointer(GL.GL_FLOAT, 0, 0);
                } else {
                    normalBuffer.rewind();
                    gl.glNormalPointer(GL.GL_FLOAT, 0, normalBuffer);
                }
            }
	    const texUnits = shader.uvMap.size();
	    //println("mesh={mn.id}");
	    //println("shader={shader.id} uvMap={shader.uvMap.size()}");
	    //println("coords={mesh.textureCoordinates.size()}");
            if (shader.uvMap <> null and mesh.textureCoordinates == null) {
                println("uvMap={shader.uvMap}, coords={mesh.textureCoordinates}");
                return;
            }
	    const coords = foreach (i in shader.uvMap) mesh.textureCoordinates[i];
	    for (unit in [0..<texUnits]) {
		const textureBuffer = mesh.getTextureBuffers()[shader.uvMap[unit]];
		const coord = mesh.textureCoordinates[shader.uvMap[unit]];
		gl.glClientActiveTexture(GL.GL_TEXTURE0+unit);
		if (textureBuffer <> null) {
		    gl.glEnableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
		    if (vbo <> null) {
			gl.glBindBuffer(GL.GL_ARRAY_BUFFER, vbo.textureBuffers[unit]);
			gl.glTexCoordPointer(coord.getCoordsPerVertex(),
					     GL.GL_FLOAT, 0, 0);
		    } else {
			textureBuffer.rewind();
			gl.glTexCoordPointer(coord.getCoordsPerVertex(), 
					     GL.GL_FLOAT, 0, textureBuffer);
		    }
		} else {
		    gl.glDisableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
		}
            }
            //println("applying shader {shader}");
	    if (texUnits > 0) {
                gl.glEnable(GL.GL_TEXTURE_2D);
            } else {
                gl.glDisable(GL.GL_TEXTURE_2D);
            }
            var allLights = if lights == [] then [cameraLight] else lights;
            const bnds = mn.boundsInScene;
            allLights = f3.util.Sequences.sort(allLights, java.util.Comparator of Point3 {
                    override function compare from (x is Point3, y is Point3) to Integer {
                        const p0 = x;
                        const p1 = y;
                        const d0 = (p0 - bnds.center).length();
                        const d1 = (p1 - bnds.center).length();
                        const cmp = d0 - d1;
                        if (cmp < 0) then -1 else if (cmp > 0) 1 else 0;
                    }
                });
            const closestLight = allLights[0];
            try {
                if (shader instanceof DefaultPhongShader) {
                    (shader as DefaultPhongShader).lightScenePos = closestLight;
                } else if (shader instanceof DefaultPhongShader4) {
                    var ds = shader as DefaultPhongShader4;
		    ds.lightScenePos1 = allLights[0];
                    ds.lightScenePos2 = allLights[1];
                    ds.lightScenePos3 = allLights[2];
                    ds.lightScenePos4 = allLights[3];
                    ds.lightMask = tuple(1,
					 if (sizeof allLights > 1) 1 else 0,
					 if (sizeof allLights > 2) 1 else 0,
					 if (sizeof allLights > 3) 1 else 0);
                }
		if (mn.toSceneTransform == null or camera.viewMatrix == null or camera.projectionMatrix == null) {
		    println("bad transform {mn} {mn.id} or {camera} {camera.id}");
                    return;
		}
		///println("applying shader {shader} to {mn.id}");
		shader.apply(mesh,
			     toSceneTransform,
                             camera.viewMatrix,
                             camera.projectionMatrix);
		if (disableDepth) {
		    gl.glDisable(GL.GL_DEPTH_TEST);
		}
            } catch (e is java.lang.Throwable) {
		println("Error drawing: {mn}");
                if (true) return;
                e.printStackTrace();
                (shader = phongShader).apply(mesh,
                                             mn.toSceneTransform,
                                             camera.viewMatrix,
                                             camera.projectionMatrix);
            }
            if (mesh.polygonMode <> polygonMode) {
                polygonMode = mesh.polygonMode;
                gl.glPolygonMode(GL.GL_FRONT_AND_BACK, if (mesh.polygonMode == PolygonMode.Line) GL2.GL_LINE else if (mesh.polygonMode == PolygonMode.Point) GL2.GL_POINT else GL2.GL_FILL);
            }
            const mode = if (mesh.indexMode == IndexMode.Lines) GL.GL_LINES else if (mesh.indexMode == IndexMode.Points) GL.GL_POINTS else GL.GL_TRIANGLES;
            if (vbo <> null) {
                gl.glBindBuffer(GL.GL_ELEMENT_ARRAY_BUFFER, vbo.indexBuffer);
                gl.glDrawElements(mode,
                                  indexBuffer.limit(),
                                  GL2.GL_UNSIGNED_INT,
                                  0);
            } else {
                indexBuffer.rewind();
                gl.glDrawElements(mode,
                                  indexBuffer.limit(),
                                  GL2.GL_UNSIGNED_INT,
                                  indexBuffer);
            }            
	    for (unit in [0..<texUnits]) {
		gl.glClientActiveTexture(GL.GL_TEXTURE0+unit);
		gl.glDisableClientState(GL2.GL_TEXTURE_COORD_ARRAY);
            }
            shader.reset();
            //mn.needsDraw = false;
            //shader.validate();
        }
    
}

// hack
public var THE_GL2 is GL2;

public class Listener is GLEventListener, DropTargetListener {

    var currentButtons is Integer[];
    var screenx is Number;
    var screeny is Number;
    //    var gl is GL2;
    var stage is JoglStage;
    var ctx is  GLContext;
    function makeDropEvent
	from (e is java.awt.dnd.DropTargetDropEvent) 
	to DropEvent
    {
        wakeup();
        var getData = function from () to String
	    {
		e.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE);
		var t = e.getTransferable();
		var flavors = [DataFlavor.stringFlavor, DataFlavor.javaFileListFlavor];
		var dataList is String[];
		for (i in t.getTransferDataFlavors()) {
		    for (j in flavors) {
			if (j == i) {
			    var td = t.getTransferData(j);
			    if (td instanceof java.util.List) {
				td = (td as java.util.List).get(0);
			    }
			    if (td instanceof java.io.File) {
				td = (td as java.io.File).toURL().toString();
			    }
			    insert td.toString() into dataList;
			}
		    }
		};
		dataList[0];
	    }
        DropEvent {
            screenx: e.getLocation().x;
            screeny: e.getLocation().y;
            url: bind getData();
            override function reject to () {
                e.rejectDrop();
            }
            override function accept to () {
                e.dropComplete(true);
            }
        }
    }
    
    function makeDragEvent
	from (e is java.awt.dnd.DropTargetDragEvent) 
	to DragEvent
    {
        DragEvent {
            screenx: screenx;
            screeny: screeny;
            override function reject to () {
                e.rejectDrag();
            }
            override function accept to () {
                e.acceptDrag(e.getSourceActions());
            }
        }
    }
    
    function makeDragEvent
	from (e is java.awt.dnd.DropTargetEvent) 
	to DragEvent
    {
        wakeup();
        DragEvent {
            screenx: screenx;
            screeny: screeny;
            override function reject to () {
                // error
            }
            override function accept to () {
                //error
            }
        }
    }

    function mouseMove
	from (x is Number, y is Number, 
	      controlDown is Boolean, 
	      altDown is Boolean, 
	      metaDown is Boolean, 
	      shiftDown is Boolean)
	to ()
    {
        wakeup();
        try {
            ctx.makeCurrent();
	    stage.injectMouseMove(MouseEvent {
		    screenx: screenx = x;
		    screeny: screeny = y;
		    altKey: altDown;
		    ctrlKey: controlDown;
		    metaKey: metaDown;
		    shiftKey: shiftDown;
                    buttons: currentButtons;
		});
	} finally {
	    ctx.release();
	}
    }

    function mouseDown
	from (button is Integer, 
	      controlDown is Boolean, 
	      altDown is Boolean, 
	      metaDown is Boolean, 
	      shiftDown is Boolean, 
	      clickCount is Integer)
	to ()
    {
        insert button into currentButtons;
        stage.injectMouseDown(MouseEvent {
                screenx:  screenx;
                screeny:  screeny;
                altKey:  altDown;
                ctrlKey:  controlDown;
                metaKey:  metaDown;
                shiftKey: shiftDown;
                clickCount:  clickCount;
                buttons: button;
            });
    }


    function mouseUp from (button is Integer, controlDown is Boolean, altDown is Boolean, metaDown is Boolean, shiftDown is Boolean) to () {
        delete button from currentButtons;
        stage.injectMouseUp(MouseEvent {
                screenx:  screenx;
                screeny:  screeny;
                ctrlKey:  controlDown;
                altKey:  altDown;
                metaKey:  metaDown;
                shiftKey: shiftDown;
                buttons:  button;
            });
    }

    function mouseWheel
	from (x is Number, y is Number, 
	      controlDown is Boolean, 
	      altDown is Boolean, 
	      metaDown is Boolean, 
	      shiftDown is Boolean,
	      rot is Integer,
	      amount is Integer)
	to ()
    {
    //	println("mouse wheel {rot} {amount}");
        stage.injectMouseWheel(MouseWheelEvent {
                screenx: screenx = x;
                screeny: screeny = y;
                altKey: altDown;
                ctrlKey: controlDown;
                metaKey: metaDown;
                shiftKey: shiftDown;
		scroll: tuple(0, rot);
                buttons: currentButtons;
            });
    }

    var dragging = false;

    override function dragEnter from (e is DropTargetDragEvent) to () {
        screenx = e.getLocation().x;
        screeny = e.getLocation().y;
        dragging = true;
        println("drag over: {java.lang.Thread.currentThread()}");
        try {
            ctx.makeCurrent();
            stage.injectDragEnter(makeDragEvent(e));
        } finally {
            ctx.release();
        }
    }

    override function dragOver from (e is DropTargetDragEvent) to () {
        screenx = e.getLocation().x;
        screeny = e.getLocation().y;
        try {
            ctx.makeCurrent();
            stage.injectDragOver(makeDragEvent(e));
        } finally {
            ctx.release();
        }
    }

    override function dragExit from (e is DropTargetEvent) to () {
        dragging = false;
        try {
            ctx.makeCurrent();
            stage.injectDragLeave(makeDragEvent(e));
        } finally {
            ctx.release();
        }
    }

    override function dropActionChanged from (e is DropTargetDragEvent) to () {
    }

    override function drop from (e is DropTargetDropEvent) to () {
        screenx = e.getLocation().x;
        screeny = e.getLocation().y;
        println("drop: {java.lang.Thread.currentThread()}");
        dragging = false;
        try {
            ctx.makeCurrent();
            const event = makeDropEvent(e);
            stage.injectDrop(event);
        } finally {
            ctx.release();
        }
    }

    function setup from (gl is GL2, width is Integer, height is Integer) to () {
        ctx = GLContext.getCurrent();
        gl.setSwapInterval(1);
	(ImageLoader_INSTANCE as JoglImageLoader).gl = gl; // hack
	stage.resize(width, height, frame.getWidth(), frame.getHeight());
        wakeup();
    }

    var mouseX is Number;
    var mouseY is Number;
    var setTitle is function from String to ();
    var setCursor is function from Cursor to ();
    var stageRenderer is StageRenderer;

    var opaque = 0;
    var transp = 0;

    var opaqueTris = 0;
    var transpTris = 0;
    var startTime is Long;

    var stageTitle is String;

    var prevTime is Long;

    const self = this;

    public function resizeWindow from (w is Integer, h is Integer) to () {
        frame.setSize(w, h);
    }

    var frameCount is Integer;
    var frameTime is Long;
    var fps is Integer;

    function render from (gl is GL2, width is Integer, height is Integer) to () {
        THE_GL2 = gl;
        const now = java.lang.System.currentTimeMillis();
        if (startTime == 0) {
	    startTime = now;
	    prevTime = now;
	}
        if (wakeupFrames > 0) {
            wakeupFrames--;
            trig = true;
        }
        if (not ALWAYS_SWAP_BUFFERS and not dragging and not trig and not frame.isActive()) {
            java.lang.Thread.sleep(128);
            trig = true;
            lastFrame = java.lang.System.currentTimeMillis();
            return;
        }
        MasterTimeline.paused = not frame.isActive();
        if (not frame.isActive()) {
            prevTime = now;
        }

        if (now - frameTime > 1000) {
            const elapsed is Double = (now - frameTime) / (1000.0 as Double);
            //println("frameCount: {frameCount}");
            //println("elapsed: {elapsed}");
            fps = Math.round(frameCount / elapsed);
            //println("fps={fps}");
            frameTime = now;
            frameCount = 0;
        }
	if (false) {
	    const rt = java.lang.Runtime.getRuntime();
	    const mem = rt.totalMemory();
	    const free = rt.freeMemory();
	    setTitle("mem({%,d mem-free}/{%,d mem}) {stage.title}");
	} else {
            if (stage.title.trim() == "") {
                setTitle("{fps} fps");
            } else {
                setTitle("{stage.title} - {fps} fps");
            }
	}
        const delta = 1ms * (now - prevTime);
	//	println("delta={delta}");
	MasterTimeline.advancePlayhead(delta);
	prevTime = now;

        if (stageRenderer == null) {
	    stageRenderer = StageRenderer {
                topLevel: true;
		stage: stage;
		activate: function from () to () {
                    var dummy = prevTime;
		    gl.glBindFramebuffer(gl.GL_FRAMEBUFFER, 0);
		}
		override function onDraw 
		from (transparent is Integer, 
		      transpTris is Integer, 
		      opaque is Integer, 
		      opaqueTris is Integer)
		to ()
		{
		    //println("draw {transparent}/{transpTris}, {opaque}/{opaqueTris}");
		    self.opaque += opaque;
		    self.transp_tris += transpTris;
		    self.transp += transparent;
		    self.opaque_tris += opaqueTris;
		}
	    }
	}
        opaque = 0;
        transp = 0;
        transp_tris = 0;
        opaque_tris = 0;
        for (scene in stage.content) {
	    scene.stage = stage;
	}
        for (scene in stage.content) {
            scene.update();
        }
	skip = true;
	if (stageRenderer.renderScenes(gl, stage.width, stage.height)) {
	    if (lastOpaque <> opaque or lastTransp <> transp) {
		lastTransp = transp;
		lastOpaque = opaque;
	    }
	    skip = false;
            frameCount++;
	} else {
            //println("nothing rendered");
        }
        trig = not skip;
        justInit = false;
	stage.flush();
        setCursor(stage.cursor);
        if (true) {
            var end = java.lang.System.currentTimeMillis();
            if (lastFrame == 0) {
                lastFrame = end;
            } 
            var d = lastFrame + sleepFrames - end;
            if (skip) {
                if (d > 0) {
                    java.lang.Thread.sleep(d);
                    sleepFrames = Math.min(sleepFrames*2, 32);
                } else {
                    sleepFrames = 16;
                }
                // keep the same buffer
            } else {
                //const x = java.lang.System.currentTimeMillis();
                canvas.swapBuffers();
                //const y = java.lang.System.currentTimeMillis();
                //println("swapped buffers {y-x}ms");
                sleepFrames = 16;
            }
            lastFrame = java.lang.System.currentTimeMillis();
        }
    }

    var skip = false;
    var trig = false;

    public var wakeupFrames = 0;

    function wakeup {
        trig = true;
        sleepFrames = 0;
        wakeupFrames = 120;
    }
    
    var sleepFrames = 32;

    var lastFrame is Long;

    var title is String;
    var opaque_tris = 0;
    var transp_tris = 0;
    var lastTransp = 0;
    var lastOpaque = 0;
    override function dispose from (drawable is GLAutoDrawable) to () {}
    override function display from (drawable is GLAutoDrawable) to () {
        render(drawable.getGL().getGL2(), drawable.getWidth(), drawable.getHeight());
        canvas.repaint();
    }

    var animator is com.jogamp.opengl.util.FPSAnimator;

    var justInit = true;
    override function init from (drawable is GLAutoDrawable) to () {
        animator = new com.jogamp.opengl.util.FPSAnimator(drawable, 60);
        //animator.start();
        justInit = true;
    }

    override function reshape 
	from (drawable is GLAutoDrawable, 
	      x is Integer, 
	      y is Integer, 
	      w is Integer, 
	      h is Integer)
	to () 
    {
        setup(drawable.getGL().getGL2(), w, h);
    }
}

const keyMap = new java.util.TreeMap of (Integer, Integer);

function map from (inkey is Integer, outkey is Integer) to () 
{
    keyMap.put(inkey, outkey);
}

function mapKeyCode from (k is Integer) to Integer 
{
    const k0 = keyMap.get(k); 
    if (k0 == null) {
        return 0;
    }
    return k0;
}

function buildKeyMap 
{
    map(KeyEvent.VK_MINUS, Keys.Minus);
    map(KeyEvent.VK_PLUS, Keys.Plus);
    map(KeyEvent.VK_PERIOD, Keys.Period);
    map(KeyEvent.VK_COMMA, Keys.Comma);
    map(KeyEvent.VK_BACK_SPACE, Keys.Backspace);
    map(KeyEvent.VK_SPACE, Keys.Spacebar);
    map(KeyEvent.VK_TAB, Keys.Tab);
    map(KeyEvent.VK_ENTER, Keys.Enter);
    map(KeyEvent.VK_SHIFT, Keys.Shift);
    map(KeyEvent.VK_CONTROL, Keys.Ctrl);
    map(KeyEvent.VK_ALT, Keys.Alt);
    map(KeyEvent.VK_PAUSE, Keys.PauseBreak);
    map(KeyEvent.VK_CAPS_LOCK, Keys.CapsLock);
    map(KeyEvent.VK_ESCAPE, Keys.Esc);
    map(KeyEvent.VK_PAGE_UP, Keys.PageUp);
    map(KeyEvent.VK_PAGE_DOWN, Keys.PageDown);
    map(KeyEvent.VK_END, Keys.End);
    map(KeyEvent.VK_HOME, Keys.Home);
    map(KeyEvent.VK_LEFT, Keys.Left); 
    map(KeyEvent.VK_UP, Keys.Up);
    map(KeyEvent.VK_RIGHT, Keys.Right);
    map(KeyEvent.VK_DOWN, Keys.Down);
    map(KeyEvent.VK_INSERT, Keys.Insert);
    //    map(KeyEvent.VK_DELETE, Keys.Delete);
    map(KeyEvent.VK_DELETE, Keys.Backspace);
    map(KeyEvent.VK_0, Keys._0);
    map(KeyEvent.VK_1, Keys._1);
    map(KeyEvent.VK_2, Keys._2);
    map(KeyEvent.VK_3, Keys._3);
    map(KeyEvent.VK_4, Keys._4);
    map(KeyEvent.VK_5, Keys._5);
    map(KeyEvent.VK_6, Keys._6);
    map(KeyEvent.VK_7, Keys._7);
    map(KeyEvent.VK_8, Keys._8);
    map(KeyEvent.VK_9, Keys._9);
    map(KeyEvent.VK_SEMICOLON, Keys.Semicolon);
    map(KeyEvent.VK_EQUALS, Keys.Equals);
    map(KeyEvent.VK_A, Keys.A);
    map(KeyEvent.VK_B, Keys.B);
    map(KeyEvent.VK_C, Keys.C);
    map(KeyEvent.VK_D, Keys.D);
    map(KeyEvent.VK_E, Keys.E);
    map(KeyEvent.VK_F, Keys.F);
    map(KeyEvent.VK_G, Keys.G);
    map(KeyEvent.VK_H, Keys.H);
    map(KeyEvent.VK_I, Keys.I);
    map(KeyEvent.VK_J, Keys.J);
    map(KeyEvent.VK_K, Keys.K);
    map(KeyEvent.VK_L, Keys.L);
    map(KeyEvent.VK_M, Keys.M);
    map(KeyEvent.VK_N, Keys.N);
    map(KeyEvent.VK_O, Keys.O);
    map(KeyEvent.VK_P, Keys.P);
    map(KeyEvent.VK_Q, Keys.Q);
    map(KeyEvent.VK_R, Keys.R);
    map(KeyEvent.VK_S, Keys.S);
    map(KeyEvent.VK_T, Keys.T);
    map(KeyEvent.VK_U, Keys.U);
    map(KeyEvent.VK_V, Keys.V);
    map(KeyEvent.VK_W, Keys.W);
    map(KeyEvent.VK_X, Keys.X);
    map(KeyEvent.VK_Y, Keys.Y);
    map(KeyEvent.VK_Z, Keys.Z);
    map(KeyEvent.VK_WINDOWS, Keys.Windows);
    map(KeyEvent.VK_CONTEXT_MENU, Keys.RightClick);

    map(KeyEvent.VK_F1, Keys.F1);
    map(KeyEvent.VK_F2, Keys.F2);
    map(KeyEvent.VK_F3, Keys.F3);
    map(KeyEvent.VK_F4, Keys.F4);
    map(KeyEvent.VK_F5, Keys.F5);
    map(KeyEvent.VK_F6, Keys.F6);
    map(KeyEvent.VK_F7, Keys.F7);
    map(KeyEvent.VK_F8, Keys.F8);
    map(KeyEvent.VK_F9, Keys.F9);
    map(KeyEvent.VK_F10, Keys.F10);
    map(KeyEvent.VK_F11, Keys.F11);
    map(KeyEvent.VK_F12, Keys.F12);
    
    map(KeyEvent.VK_NUM_LOCK, Keys.NumLock);
    map(KeyEvent.VK_SCROLL_LOCK, Keys.ScrollLock);
}


var lastKey is Integer;

function makeKeyEvent from (e is java.awt.event.KeyEvent) to KeyboardEvent {
    var keyCode = e.getKeyCode();
    if (keyCode == 0) {
        keyCode = lastKey;
    }
    lastKey = keyCode;
    keyCode = mapKeyCode(keyCode);
    var char = "{e.getKeyChar()}";
    KeyboardEvent {
        keyChar: char;
        keyCode: keyCode;
        altKey: e.isAltDown();
        ctrlKey: e.isControlDown();
        shiftKey: e.isShiftDown();
        metaKey: e.isMetaDown();
    }
}

class AWTDialogFactory is DialogFactory {
    public var frame is java.awt.Frame;
    var fd is java.awt.FileDialog;
    function getFD to java.awt.FileDialog
    {
	//java.lang.System.setProperty("apple.awt.fileDialogForDirectories", "true");
	if (fd == null) {
	    fd = new java.awt.FileDialog(frame);
	}
	return fd;
    }
    override public function openFileOpenDialog from (dialog is FileDialog.FileOpen) to String
    {
	const fd = getFD();
	println("file open {fd}");
	fd.setMode(fd.LOAD);
	fd.setTitle(dialog.title);
	var f = new java.io.File(dialog.fileName);
	fd.setFilenameFilter(java.io.FilenameFilter {
		override function accept from (dir is java.io.File, name is String) to Boolean 
		{
		    for (filterName in dialog.filterNames) {
			if (name == filterName) return true
		    }
		    for (filterName in dialog.filterExtensions) {
			if (name.endsWith(filterName)) return true
		    }
		    return false;
		}
	    });
	fd.setDirectory(f.getParentFile().toString());
	fd.setFile(f.getName());
	fd.setVisible(true); 
        if (fd.getFile() == null) {
            return null;
        }
	new java.io.File(fd.getDirectory(), fd.getFile()).toString();
    }

    override public function openFileSaveDialog from (dialog is FileDialog.FileSave) to String
    {
	const fd = getFD();
	println("file save {fd}");
	fd.setTitle(dialog.title);
	fd.setMode(fd.SAVE);
	fd.setFile(dialog.fileName);
	fd.setVisible(true); 
        if fd.getFile() == null then null else new java.io.File(fd.getDirectory(), fd.getFile()).toString();
    }

    override public function openYesNoCancelDialog from (dialog is Dialog.YesNoCancel) to ()
    {
        const r = 
            JOptionPane.showConfirmDialog(frame, dialog.message, dialog.title, JOptionPane.YES_NO_CANCEL_OPTION);     
        if (r == JOptionPane.YES_OPTION) {
            dialog.onYes();
        } else if (r == JOptionPane.NO_OPTION) {
            dialog.onNo();
        } else {
            dialog.onCancel();
        }
    }
}

// hack...
var TODO is (function from () to ())[];

public const TheDialogFactory = AWTDialogFactory {
}

class AwtMenuItem is MenuFactory.MenuItemImpl {
    public var ctx is GLContext;
    public var item is MenuItem;
    public var awtItem = new java.awt.MenuItem();
    
    public bound function getAwtItem to java.awt.MenuItem 
    {
	result
    }	

    public function update from () to () {
	result;
    }

    public function addTo from (parent is java.awt.Menu) to ()
    {
        println("adding {result} to {parent}");
	parent.add(result);
    }

    var action is function from () to ();
    postinit {
	awtItem.addActionListener(java.awt.event.ActionListener {
		override function actionPerformed 
		    from (e is java.awt.event.ActionEvent) 
		    to () 
		{
                    insert action into TODO;
		}
	    });
    }
    protected var result = 
	bind buildMenuItem(item.label,
			   item.enabled,
			   item.shortcut,
			   item.action);
    function buildMenuItem 
	from (label is String,
	      enabled is Boolean,
	      shortcut is MenuItem.Shortcut,
	      action is function from () to ())
	to java.awt.MenuItem
    {
	println("building item {this} {awtItem} {label} {enabled} {shortcut} {action}");
	awtItem.setLabel(label);
	awtItem.setEnabled(enabled);
	if (shortcut <> null) {
	    awtItem.setShortcut(new java.awt.MenuShortcut(shortcut.keyCode,
							  shortcut.shiftKey));
	} else {
	    awtItem.setShortcut(null);
	}
	this.action = action;
	return awtItem;
    }
}

class AwtSeparator is AwtMenuItem {
    override var awtItem = null;
    override public function addTo from (menu is java.awt.Menu) to ()
    {
	menu.addSeparator();
    }
}

class AwtCheckBox is AwtMenuItem {
    override var awtItem = new java.awt.CheckboxMenuItem();
    override var result = 
	bind buildMenuItem(item.label,
			   item.enabled,
			   item.shortcut,
			   function from () to () {
                               const ch = item as MenuItem.CheckBox;
                               ch.selected = (awtItem as java.awt.CheckboxMenuItem).getState();
                               item.action();
                           });
    postinit {
        (awtItem as java.awt.CheckboxMenuItem).setState((item as MenuItem.CheckBox).selected);
    }
}

class AwtMenu is AwtMenuItem {
    override var awtItem = new java.awt.Menu();
    bound var menuResult = 
	buildMenuItems(result as java.awt.Menu, 
                       foreach (m in (item as Menu).items) m.itemImpl as AwtMenuItem);


    override public bound function getAwtItem to java.awt.MenuItem 
    {
	getMenu()
    }		

    override function update from () to ()
    {
	menuResult;
    }

    bound function getMenu to java.awt.Menu {
	menuResult;
    }

    override public function addTo from (parent is java.awt.Menu) to ()
    {
	parent.add(menuResult);
    }

    function buildMenuItems
	from (parent is java.awt.Menu,
	      items is AwtMenuItem[]) 
	to java.awt.Menu
    {
	parent.removeAll();
	println("BUILDING {items.size()} items {item.label} parent={parent} awtItem={awtItem}");
	for (item in items) {
	    item.addTo(parent);
	    println("added {item} to parent={parent}, count={parent.getItemCount()}");
	}
	println("parent=>{parent} {parent.getItemCount()}");
	parent;
    }
}

class AWTMenuFactoryImpl is MenuFactory {

    override public bound function createItemImpl 
	from (item is MenuItem)
	to MenuItemImpl
	{
	    if (item is Menu.Separator) {
		AwtSeparator {
		}
	    } else if (item is Menu) {
		AwtMenu {
		    item: bind item;
		}	
	    } else if (item is MenuItem.CheckBox) {
                AwtCheckBox {
                    item: bind item;
                }
	    } else {
		AwtMenuItem {
		    item: bind item;
		}
	    }
	}
}

public const THE_MENU_FACTORY = AWTMenuFactoryImpl {}

public class JoglStage is Stage
{

    override public function showTooltip from (x is Integer, y is Integer, tooltip is String) to () 
    {
        tt.setToolTipText(tooltip);
        tt.showToolTip(x, y);
    }

    const awtmenu = new java.awt.PopupMenu();

    public override function showPopupMenu from (x is Integer, y is Integer, menu is Menu) to () {
        if (awtmenu.getParent() == null) {
            frame.add(awtmenu);
        }
        awtmenu.removeAll();
        const m is java.awt.Menu = (menu.itemImpl as AwtMenu).menuResult;
        println("m={m}");
        const items = foreach (i in [0..<m.countItems()]) m.getItem(i);
        for (item in items) {
            awtmenu.add(item);
        }
        println("showing popup menu at {x}, {y} {awtmenu}");
        awtmenu.show(frame, x, y);
    }

    public function setFullscreen from (b is Boolean) to ()
    {
	const ge = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment();
	const vc = ge.getDefaultScreenDevice();
	if (b) {
	    vc.setFullScreenWindow(frame);
	} else {
	    vc.setFullScreenWindow(null);
	}
    }

    public var listener is  Listener;
    public var title is String;

    public function invoke from (fun is function from () to ()) to () {
        insert fun into TODO;
    }

    function flush {
        var funs = TODO;
        TODO = [];
        for (fun in funs) fun();
        java.awt.EventQueue.invokeLater(java.lang.Runnable {
                override function run {
                    doUpdate();
                }
            });
    }

    postinit {
	println("setup");
	setup();
	for (scene in content) {
	    scene.stage = this;
	}
    }

    var awt_menubar is java.awt.MenuBar = new java.awt.MenuBar();

    var awt_menus = bind createMenus(awt_menubar, menubar.menus);
    
    function createMenus from 
	(menubar is java.awt.MenuBar,
	 menus is Menu[]) 
	to java.awt.MenuBar
    {
	if (menubar <> null) {
	    while (menubar.getMenuCount() > 0) {
		menubar.remove(0);
	    }
	    println("BUILDING MENU BAR {menus}");
	    for (m in menus) {
		const i = m.itemImpl as AwtMenu;
		const menu = i.menuResult;
		println("CREATED {i} {menu} {menu.getItemCount()}");
		menubar.add(menu);
		for (j in [0..<menu.getItemCount()]) {
		    const mi = menu.getItem(j);
		    println(mi);
		}
	    }
	}
	menubar;
    }

    function buildMenus from (frame is java.awt.Frame) to () 
    {
	if (menubar <> null) {
	    frame.setMenuBar(awt_menus);
	} else {
	    frame.setMenuBar(null);
	}
    }

    //override var width: Integer = 640;
    // override var height: Integer = 480;
    function doUpdate {
	menubar.foldLeft((), function from (_ is (), m is MenuItem) to () {
		const awtItem = m.itemImpl as AwtMenuItem;
		awtItem.update();
	    });
	buildMenus(frame);
	updateCursor();
        if (updateSubject <> null) {
            updateSubject.onNext(());
        }
    }

    var frame is Frame;
    var canvas is GLCanvas;

    public var onClose is function from () to Boolean = function { yes };

    public function resizeWindow (w is Integer, h is Integer) to ()
    {
        frame.resize(w, h);
    }

    var cursors = new java.util.HashMap of (String, java.awt.Cursor);

    var tt is ToolTipListener;

    function setup {
        const glp = GLProfile.get("GL2");
        const caps = new GLCapabilities(glp);
        println("samples={SAMPLE_BUFFERS} numSamples={NUM_SAMPLES} depthBits={DEPTH_BITS}");
        caps.setDepthBits(DEPTH_BITS);
        caps.setSampleBuffers(SAMPLE_BUFFERS);
        caps.setNumSamples(NUM_SAMPLES);
        canvas = new GLCanvas(caps);
        frame = Frame {};
        tt = new ToolTipListener(canvas, frame);
	TheDialogFactory.frame = frame;
        frame.setSize(width, height);
	canvas.setAutoSwapBufferMode(false);
        frame.add(canvas);
        frame.addWindowListener(java.awt.event.WindowAdapter {
                override public function windowClosing from (e is java.awt.event.WindowEvent) to () {
                    if (onClose()) {
                       java.lang.System.exit(0);
                    }
                }
            });
        buildKeyMap();
        listener = Listener { stage: this }
        listener.setTitle = function from (title is String) to () {
            java.awt.EventQueue.invokeLater(java.lang.Runnable {
                    override function run {
                        frame.setTitle(title);
                    }
                });
        }
        listener.setCursor = function from (cursor is Cursor) to () {
            java.awt.EventQueue.invokeLater(java.lang.Runnable {
                    override function run {
                        if (cursor.type == CursorType.POINTER) {
                            frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.DEFAULT_CURSOR));
                        } else if (cursor.type == CursorType.HAND) {
                            frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.HAND_CURSOR));
                        } else if (cursor.type == CursorType.IBEAM) {
                            frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.TEXT_CURSOR));
                        } else if (cursor.type == CursorType.SOUTH_RESIZE) {
                            frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.S_RESIZE_CURSOR));
                        } else if (cursor.type == CursorType.SOUTHEAST_RESIZE) {
                            frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.SE_RESIZE_CURSOR));
                        } else if (cursor.type == CursorType.EAST_RESIZE) {
                            frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.E_RESIZE_CURSOR));
                        } else if (cursor is Cursor.CustomCursor) {
                            var cc = cursor as Cursor.CustomCursor;
                            var u = cc.image.url;
                            var c = cursors.get(u);
                            if (c == null) {
                                c = java.awt.Toolkit.getDefaultToolkit().createCustomCursor(new javax.swing.ImageIcon(new java.net.URL(u)).getImage(), new java.awt.Point(cc.x, cc.y), cc.id);
                                cursors.put(u, c);
                            }
                            frame.setCursor(c);
                        } else {
                            frame.setCursor(java.awt.Cursor.getPredefinedCursor(java.awt.Cursor.DEFAULT_CURSOR));
                        }
                    }
                });
            };
                

	
	var x = Integer.MAX_VALUE;
	var y = Integer.MAX_VALUE;
        canvas.addMouseListener(java.awt.event.MouseAdapter {
                override function mousePressed from (e is java.awt.event.MouseEvent) to () {
                    listener.wakeup();
		    if (x <> e.getX() or y <> e.getY()) {
			x = e.getX(); y = e.getY();
			listener.mouseMove(e.getX(), e.getY(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown());
		    }
                    listener.mouseDown(e.getButton(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown(), e.getClickCount());
                }
                override function mouseReleased from (e is java.awt.event.MouseEvent) to () {
                    listener.mouseUp(e.getButton(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown());
                }
            });
        canvas.addMouseWheelListener(java.awt.event.MouseWheelListener {
		override function mouseWheelMoved from (e is java.awt.event.MouseWheelEvent) to () {
                    listener.wakeup();
                    listener.mouseWheel(e.getX(), e.getY(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown(), e.getWheelRotation(), e.getScrollAmount());
                }
	    });
        canvas.addMouseMotionListener(java.awt.event.MouseMotionAdapter {
                override function mouseMoved from (e is java.awt.event.MouseEvent) to () {
                    listener.wakeup();
		    x = e.getX(); y = e.getY();
                    listener.mouseMove(e.getX(), e.getY(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown());
                }
                override function mouseDragged from (e is java.awt.event.MouseEvent) to () {
                    listener.wakeup();
		    x = e.getX(); y = e.getY();
                    listener.mouseMove(e.getX(), e.getY(), e.isControlDown(), e.isAltDown(), e.isMetaDown(), e.isShiftDown());
                }
            });
        canvas.addKeyListener(java.awt.event.KeyAdapter {
                override function keyPressed from (e is java.awt.event.KeyEvent) to () {
                    listener.wakeup();
                    injectKeyDown(makeKeyEvent(e));
                }
                override function keyReleased from (e is java.awt.event.KeyEvent) to () {
                    listener.wakeup();
                    injectKeyUp(makeKeyEvent(e));
                }
                override function keyTyped from (e is java.awt.event.KeyEvent) to () {
                    listener.wakeup();
                    injectKeyInput(makeKeyEvent(e));
                }
            });
        canvas.addGLEventListener(listener);
        new DropTarget(canvas, listener);
        frame.setVisible(true);
        canvas.requestFocus();
        frame.requestFocus();
    }
}

public const CGEffectLoader_INSTANCE is CGEffectLoader = JoglCGEffectLoader{};
public const ImageLoader_INSTANCE is ImageLoader = JoglImageLoader {};

var currentCamera is Camera on replace {
    println("currentCamera=>{currentCamera}");
}

public var TheWebBrowserFactory is AbstractWebBrowserFactory;
public var TheMovieLoader is MovieLoader;

function readTextFile from (url is String) to (String, Integer)
{
    const u = new java.net.URL(url);
    const reader = new java.io.BufferedReader(new java.io.InputStreamReader(u.openStream()));
    var line is Object;
    var buf = new java.lang.StringBuffer;
    var lineCount = 0;
    while ((line = reader.readLine()) <> null) {
	buf.append(line);
	buf.append("\n");
	lineCount++;
    }
    return (buf.toString(), lineCount);
}

public function run from (args is String[]) to ()
{

    try {
	const clazz = 
	    java.lang.Class.forName("f3.media.web.awesomium.AwesomiumWebBrowserFactory") as java.lang.Class of AbstractWebBrowserFactory;
	TheWebBrowserFactory = clazz.newInstance();
	    
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't create awesomium web browser factory");
    }

    try {
	const clazz = 
	    java.lang.Class.forName("org.f3.media.video.macos.MovieLoaderImpl") as java.lang.Class of MovieLoader;
	TheMovieLoader = clazz.newInstance();
    } catch (e is java.lang.Exception) {
	println("NOTE: couldn't create corevideo movie loader");
    }

    println("args={args}");

    var playerUrl is String;
    readonly var model is Ma.Model = 
	bind if (not playerUrl.endsWith(".ma")) then null else Ma.Model {
		effectLoader: the CGEffectLoader;
		imageLoader: the ImageLoader;
		url: playerUrl;
	    };

    var clipIndex is Integer;

    const getClips = function from (libs is TimeGroup[]) to TimeNode[] {
	foreach (lib in libs) lib.content;
    }

    readonly var allClips = bind getClips(model.getClipLibraries());
    readonly var clips is TimeNode[] = bind [model.getTemporalRoot(), allClips];

    readonly var currentClip is TimeNode = bind clips[clipIndex];

    const player = Timeline {
	content: TimeLayer {
	    content: bind currentClip;
	    playCount: -1;
	}
    }

    const cameraLight = PointLight { id: "free.light" };

    const camera = PerspectiveCamera {
        id: "free";
	ty: 3.0;
	tz: 13;
	near: 1;
	far: 100;
	content: cameraLight;
    }

    const viewer = DefaultExaminerViewer {
	camera: camera;
    }

    const browser = if TheWebBrowserFactory == null then null else WebBrowser {
	//factory: TheWebBrowserFactory;
	//effectLoader: CGEffectLoader_INSTANCE;
	//pathFactory: ThePath2DFactory;
    }

    const pointLight1 = PointLight {
    }


    const wb is WebBrowser = WebBrowser {
    	transform: translate(512, 0, 0);
        url: "chrome://plugins/";
	//factory: TheWebBrowserFactory;
	//effectLoader: CGEffectLoader_INSTANCE;
	//pathFactory: ThePath2DFactory;
    };
    const www = wb.observePageLoaded().subscribe(function from (url is String) to () {
            println("page loaded: {url}");
            println(wb.executeJavascript("window"));
    });
    var currentModel is Node = XHTML.Text {
        content: "<div style='color:green;'><p>This text contains <sup>superscript</sup> text.</p></div>";
    };
    const prog = function from (mouseDown is Observable of MouseEvent) to Disposable
    {
	mouseDown.toggle(&currentModel.visible);
    }

    const disp is Disposable = prog(currentModel.observeMouseDown());


    readonly var svgModel = bind if (not playerUrl.endsWith(".svg")) then null else SVG {
		url: playerUrl;
		factory: ThePath2DFactory
	    };

    readonly var xhtmlModel = bind if (not playerUrl.endsWith(".xhtml")) then null else XHTML.Document {
		url: playerUrl;
	    };

    readonly var imageModel = bind if (playerUrl.endsWith(".jpg") or 
			      playerUrl.endsWith(".png") or
			      playerUrl.endsWith(".tiff") or
			      playerUrl.endsWith(".tif") or 
			      playerUrl.endsWith(".tga")) 
	Image { 
	    url: playerUrl;
	} else null;

    readonly var textModel = bind if (playerUrl.endsWith(".txt")) then 
	Text.Area {
	    //pathFactory: ThePath2DFactory;
	    //layoutEngine: TheLayoutEngine;
	    override var height = bind font.height() * 24;
            font: bind TheLayoutEngine.createFont("font-family:Lucida Grande;font-size:10;font-weight:bold");
	} else null;

    function doDrop from (url is String) to () 
    {
	stage.title = url;
	playerUrl = url;
	if (url.endsWith(".ma")) {
	    viewer.focusCamera(currentModel = model.getSpatialRoot());
	} else if (url.endsWith(".svg")) {
	    viewer.focusCamera(currentModel = svgModel.root)
	} else if (url.endsWith(".xhtml")) {
	    viewer.focusCamera(currentModel = xhtmlModel)
	} else if (url.endsWith(".png") or url.endsWith(".jpg") or url.endsWith(".tif") or url.endsWith(".tiff") or url.endsWith(".tga")) {
	    viewer.focusCamera(currentModel = imageModel);
        } else if (url.endsWith(".mp4")) {
            viewer.focusCamera(currentModel = Movie {url: url});
	} else if (url.endsWith(".txt")) {
	    textModel.setText(readTextFile(url).first);
	    viewer.focusCamera(currentModel = TransformNode {
		    tx: 150;
		    ty: 150;
		    content: textModel;
		});
	} else {
	    if (browser <> null) {
		browser.url = url;
		currentModel = browser;
		viewer.focusCamera(currentModel = browser);
	    }
	}
    }
    
    currentCamera = camera;

    const mainScene = Scene {
	id: "Main Scene";
	background: Color.GRAY;
	override var camera = bind currentCamera on invalidate {
	    println("scene camera invalidated {currentCamera}");
	}
	content: bind currentModel;
    }

    const stage = JoglStage {
	title: new java.io.File(args[0]).getName();
	content: [mainScene,
		  if (true) null else Scene {
                    background: null;
                    camera: Camera2D {}; 
		    content: bind foreach (i in [0..<model.getCameras().size()]) StageNode {
		        var cam = bind model.getCameras()[i];
                        factory: ThePath2DFactory;
			height: 80;
			width: 100;
                        override var transform = bind translate(25+125*i, 25);
			content: Scene {
			    background: Color.WHITE;
			    camera: bind cam;
			    content: AbstractNode {
				override var internalContent = bind mainScene.root;
				override function updateParent {
				    internalContent.updateParent();
				    update();
				}
			    }
			}
		    }
		    }]
    }

    operation setCamera from (i is Integer) to ()
    {
	if (i == 0) {
	    currentCamera = camera;
	} else if (i == 9) {
	    currentCamera = Camera2D {};
	} else {
	    const cam = model.getCameras()[i-1];
	    if (cam <> null) {
		currentCamera = cam;
	    }
	}
	println("camera={camera.tx}, {camera.ty}, {camera.tz}");
    }

    const setClip = function from (i is Integer) to ()
    {
	clipIndex = Math.min(clips.size()-1, i);
	println("clip={clips[clipIndex]}");
    }

    stage.addMouseInputHandler(viewer);
    stage.addKeyboardInputHandler(KeyboardInputHandler {
	    override function onKeyDown from (event is KeyboardEvent) to () 
	    {
		if (event.propagate) {
		    if (event.keyCode == Keys.F) {
			viewer.focusCamera(currentModel);
		    } else if (event.keyCode >= Keys._0 and event.keyCode <= Keys._9) {
			const index = event.keyCode - Keys._0;
			if (event.metaKey) {
			    setClip(index);
			} else {
			    setCamera(index);
			}
		    } else if (event.keyCode == Keys.G) {
			java.lang.System.gc();
			//showMemory = not showMemory;
		    } else if (event.keyCode == Keys.B) {
			DISABLE_DEFORMERS = not DISABLE_DEFORMERS;
		    } else if (event.keyCode == Keys.D) {
			//DEBUG_USE_DEFAULT_SHADER = not DEBUG_USE_DEFAULT_SHADER;
			CGFXShader.DEBUG = not CGFXShader.DEBUG;
		    }
		}
	    }
	});
    stage.addDnDInputHandler(DnDInputHandler {
	    override function onDrop from (event is DropEvent) to () 
	    {
		const url = event.url;
		event.accept();
		try {
                    if (not url.startsWith("chrome:") and
                        not url.startsWith("javascript:")) {
                        const checkProtocol = new java.net.URL(url);
                    }
		    doDrop(url);
		} catch (exception is java.lang.Exception) {
		    exception.printStackTrace();
		}
	    }
	});

    stage.invoke(function {
	    viewer.focusCamera(currentModel);
	});

}




