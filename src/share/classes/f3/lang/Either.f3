package f3.lang;

public abstract class Either of (a, b) is org.f3.runtime.Monad of (Either, b)
{
    public abstract function case of _ 
	from (f is function from a to _, 
	      g is function from b to _) 
	to _;

    override abstract public function map of c 
	from (f is function from b to c) 
	to Either of (a, c);

    abstract public function flatmap of c 
	from (f is function from b to Either of (a, c)) 
	to Either of (a, c);

    public function case of (c, _) 
	from (this is Either of (Either of (a, b), c),
	      f is function from a to _,
	      g is function from b to _,
	      h is function from c to _) to _
    {
	this.case(function from (y is Either of (a, b)) to _ 
		  {
		      y.case(f, g);
		  },
		  h)
    }

    public function case of (c, d, _) 
	from (this is Either of (Either of (Either of (a, b), c), d),
	      f is function from a to _,
	      g is function from b to _,
	      h is function from c to _,
	      i is function from d to _) to _
    {
	this.case(function from (y is Either of (Either of (a, b), c)) to _ 
		  {
		      y.case(function from (z is Either of (a, b)) to _ 
			     {
				 z.case(f, g);
			     },
			     h);
		  },
		  i)
    }

    public function swap to Either of (b, a) 
    {
	const self = this;
	Either of (b, a) 
	{
	    override public function map of c 
		from (f is function from a to c) 
		to Either of (b, c)
	    {
		self.case(function from (x is a) to Either of (b, c) 
			  {
			      Latter of (b, c) (f(x))
			  },
			  function from (y is b) to Either of (b, c) 
			  {
			      Former of (b, c) (y);
			  });
	    }

	    override public function flatmap of c 
		from (f is function from a to Either of (b, c)) 
		to Either of (b, c)
	    {
		self.case(function from (x is a) to Either of (b, c) 
			  {
			      f(x);
			  },
			  function from (y is b) to Either of (b, c) 
			  {
			      Former of (b, c) (y);
			  });
		
	    }

	    override function case of _ from (f is function from b to _, 
					      g is function from a to _) to _
	    {
		self.case(g, f)
	    }
	}
    }

    public function getFormer to java.lang.Iterable of a 
    {
	java.util.Collections.emptySet of a()
    }

    public function getLatter to java.lang.Iterable of b 
    {
	java.util.Collections.emptySet of b()
    }
}

public function Former of (a, b) from (x is a) to Either of (a, b) 
{
    Either of (a, b) {

	override function toString to String 
	{
	    "Former: {x}";
	}

	override function case of _ 
	    from (f is function from a to _, 
		  g is function from b to _) 
	    to _
	{
	    f(x);
	}

	override public function map of c from (f is function from b to c) to Either of (a, c)
	{
	    Former of (a, c) (x);
	}

	override public function flatmap of c from (f is function from b to Either of (a, c)) to Either of (a, c)
	{
	    Former of (a, c) (x);
	}
	
	override function getFormer to java.lang.Iterable of a 
	{
	    java.lang.Iterable of a {
		override function iterator to java.util.Iterator of a 
		{
		    java.util.Iterator of a {
			var flag = true;
			override function hasNext to Boolean 
			{
			    return flag;
			}
			override function next to a 
			{
			    flag = false; return x;
			}
			override function remove {}
		    }
		}
	    }
	}
    }
}

public function Latter of (a, b) from (y is b) to Either of (a, b) 
{
    Either of (a, b) {

	override function toString to String 
	{
	    "Latter: {y}";
	}

	override function case of _ 
	    from (f is function from a to _, 
		  g is function from b to _) 
	    to _
	{
	    g(y);
	}

	override public function map of c 
	    from (f is function from b to c) 
	    to Either of (a, c)
	{
	    Latter of (a, c) (f(y));
	}

	override public function flatmap of c 
	    from (f is function from b to Either of (a, c)) 
	    to Either of (a, c)
	{
	    f(y);
	}

	override function getLatter to java.lang.Iterable of b 
	{
	    java.lang.Iterable of b {
		override function iterator to java.util.Iterator of b 
		{
		    java.util.Iterator of b {
			var flag = true;
			override function hasNext to Boolean 
			{
			    return flag;
			}
			override function next to b 
			{
			    flag = false; return y
			}
			override function remove {}
		    }
		}
	    }
	}
    }
}