package f3.util;
import org.f3.runtime.*;

public class List of a is Foldable of a, Monad of (List, a)
{
    public const length is Integer = 0;

    public function reverse to List of a 
    {
	foldLeft(List of a {}, (List of a).prepend)
    }

    public function concat 
	from (xs is List of a) 
	to List of a 
    {
        foldRight(xs, (List of a).prepend.flip())
    }

    override function toString to String 
    {
        var count = 0;
        foldLeft("",
                 function from (y is String, x is a) to String
                 {
                     if (count++ == 0) then "{x}" else "{y}, {x}";
                 })
    }

    override function foldLeft of b 
        from (z is b, 
              f is function from (b, a) to b)
        to b
    {
        z
    }

    override function foldRight of b 
        from (z is b, f is function from (a, b) to b)
        to b
    {
        z
    }

    public function flatmap of b 
        from (f is function from a to List of b) to List of b
    {
        List of b {}
    }

    override public function map of b 
        from (f is function from a to b) to List of b
    {
        foldLeft(List of b {}, (List of b).append * f);
    }

    public function append from (x is a) to List of a
    {
        unit(x)
    }

    public function prepend from (x is a) to List of a
    {
        unit(x)
    }
}

class Unit of a is List of a 
{

    const x is a;

    override const length = 1;

    override public function flatmap of b 
        from (f is function from a to List of b) to List of b
    {
        f(x)
    }

    override public function map of b 
        from (f is function from a to b) to List of b
    {
        unit(f(x))
    }

    override public function prepend from (x is a) to List of a
    {
        join(unit(x), this)
    }

    override public function append from (x is a) to List of a
    {
        join(this, unit(x))
    }

    override function foldLeft of b 
        from (z is b, 
              f is function from (b, a) to b)
        to b
    {
        f(z, x)
    }

    override function foldRight of b 
        from (z is b, f is function from (a, b) to b)
        to b
    {
        f(x, z)
    }

}

class Join of a is List of a 
{
    const prefix is List of a;
    const suffix is List of a;
    
    override const length = bind prefix.length + suffix.length;

    override function foldLeft of b 
        from (z is b, 
              f is function from (b, a) to b)
        to b
    {
        suffix.foldLeft(prefix.foldLeft(z, f), f);
    }

    override function foldRight of b 
        from (z is b, f is function from (a, b) to b)
        to b
    {
        prefix.foldRight(suffix.foldRight(z, f), f);
    }

    override public function flatmap of b 
        from (f is function from a to List of b) to List of b
    {
        join(prefix.flatmap(f), suffix.flatmap(f))
    }

    override public function map of b 
        from (f is function from a to b) to List of b
    {
        join(prefix.map(f), suffix.map(f))
    }

    override public function prepend from (x is a) to List of a
    {
        join(join(unit(x), prefix), suffix)
    }

    override public function append from (x is a) to List of a
    {
        join(prefix, join(suffix, unit(x)))
    }
}

function empty of a () to List of a 
{ 
    List of a {} 
}

function unit of a from (x is a) to List of a 
{ 
    Unit of a { x: x } 
}

function join of a (xs is List of a, ys is List of a) to List of a 
{ 
    Join of a {
        prefix: xs;
        suffix: ys;
    }
}

public function toList of a from (x is a) to List of a { unit(x) }
public function asList of a from (xs is a[]) to List of a 
{
    var ys = List of a {};
    for (x in xs) {
        ys = ys.append(x)
    }
    return ys
}

function run {
    var xs = asList([1..5]);
    println(xs);
    println(xs.reverse());
    foreach (x in xs, y in xs) {
        println(x * y)
    }
}
