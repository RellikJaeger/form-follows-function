package f3.util;
import org.f3.runtime.*;

public class List of a is Foldable of a, Monad of (List, a)
{
    public const length is Integer = 0;

    public function reverse to List of a 
    {
	foldLeft(List of a {}, (List of a).prepend)
    }

    public function concat 
	from (xs is List of a) 
	to List of a 
    {
        foldRight(xs, (List of a).prepend.flip())
    }

    override function toString to String 
    {
        var count = 0;
        foldLeft("",
                 function from (y is String, x is a) to String
                 {
                     if (count++ == 0) then "{x}" else "{y}, {x}";
                 })
    }

    override function foldLeft of b 
        from (z is b, 
              f is function from (b, a) to b)
        to b
    {
        z
    }

    override function foldRight of b 
        from (z is b, f is function from (a, b) to b)
        to b
    {
        z
    }

    public function flatmap of b 
        from (f is function from a to List of b) to List of b
    {
        List of b {}
    }

    override public function map of b 
        from (f is function from a to b) to List of b
    {
        foldLeft(List of b {}, (List of b).append * f);
    }

    public function append from (x is a) to List of a
    {
        unit(x)
    }

    public function prepend from (x is a) to List of a
    {
        unit(x)
    }
}

class Unit of a is List of a 
{

    const x is a;

    override const length = 1;

    override public function flatmap of b 
        from (f is function from a to List of b) to List of b
    {
        f(x)
    }

    override public function map of b 
        from (f is function from a to b) to List of b
    {
        unit(f(x))
    }

    override public function prepend from (x is a) to List of a
    {
        join(unit(x), this)
    }

    override public function append from (x is a) to List of a
    {
        join(this, unit(x))
    }

    override function foldLeft of b 
        from (z is b, 
              f is function from (b, a) to b)
        to b
    {
        f(z, x)
    }

    override function foldRight of b 
        from (z is b, f is function from (a, b) to b)
        to b
    {
        f(x, z)
    }

}

class Join of a is List of a 
{

    const  left is List of a;
    const right is List of a;
    
    override const length = bind left.length + right.length;

    override function foldLeft of b 
        from (z is b, 
              f is function from (b, a) to b)
        to b
    {
        right.foldLeft(left.foldLeft(z, f), f);
    }

    override function foldRight of b 
        from (z is b, f is function from (a, b) to b)
        to b
    {
        left.foldRight(right.foldRight(z, f), f);
    }

    override public function flatmap of b 
        from (f is function from a to List of b) to List of b
    {
        join(left.flatmap(f), right.flatmap(f))
    }

    override public function map of b 
        from (f is function from a to b) to List of b
    {
        join(left.map(f), right.map(f))
    }

    override public function prepend from (x is a) to List of a
    {
        join(join(unit(x), left), right)
    }

    override public function append from (x is a) to List of a
    {
        join(left, join(right, unit(x)))
    }
}

function empty of a () to List of a 
{ 
    List of a {} 
}

function unit of a from (x is a) to List of a 
{ 
    Unit of a { x: x } 
}

function join of a (xs is List of a, ys is List of a) to List of a 
{ 
    Join of a {
        left: xs;
        right: ys;
    }
}

public function toList of a from (x is a) to List of a { unit(x) }
public function asList of a from (xs is a[]) to List of a {
    var ys = List of a {};
    for (x in xs) {
        ys = ys.append(x)
    }
    return ys
}

function run {
    var xs = asList([1..5]);
    println(xs);
    println(xs.reverse());
    foreach (x in xs, y in xs) {
        println(x * y)
    }
}
