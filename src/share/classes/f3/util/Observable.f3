package f3.util;
import f3.util.Observer.DefaultObserver;
import f3.lang.Ref;

public interface Observable of a, is org.f3.runtime.Monad of (Observable, a) 
{
    public function toggle from (p is Ref of Boolean) to Disposable
    {
	accumulate(p.get(),
		   function from (b is Boolean, _ is a) to Boolean
		   {
		       not b;
		   }).subscribe(p);
    }

    public function subscribe 
	from (p is Ref of a) 
	to Disposable 
    {
	subscribe(p.set);
    }

    public function subscribe of b 
	from (f is function from a to b) 
	to Disposable 
    {
	subscribe(DefaultObserver of a 
		  {
		      override function onNext from (x is a) to ()
		      {
			  f(x);
		      }
		  });
    }

    /*
    public function subscribe of b 
	from (this is Observable of (()),
	      f is function from () to b) 
	to Disposable 
    {
	subscribe(DefaultObserver of (()) 
		  {
		      override function onNext from (x is ()) to ()
		      {
			  f();
		      }
		  });
    }
    */

    public abstract function subscribe from (observer is Observer of a) to Disposable;

    override public function map of b from (f is function from a to b) to Observable of b 
    {
	const self = this;
	DefaultObservable of b 
	{
	    override function subscribe from (observer is Observer of b) to Disposable 
	    {
		self.subscribe(DefaultObserver of a {
			override public function onNext from (x is a) to () 
			{
			    const y = f(x);
			    println("{self} map {f}: {x} => {y}");
			    observer.onNext(y);
			}
			override public function onError from (e is java.lang.Exception) to () 
			{
			    observer.onError(e);
			}
			override public function onCompleted from () to () 
			{
			    observer.onCompleted();
			}
		    });
	    }
	}
    }

    public function flatmap of b from (f is function from a to Observable of b) to Observable of b 
    {
	const self = this;
	DefaultObservable of b 
	{
	    override function subscribe from (observer is Observer of b) to Disposable 
	    {
		var toDispose is Disposable[];
		function terminateWithError from (e is java.lang.Exception) to () {
		    alive = -1;
		    observer.onError(e);
		    terminate();
		}
		var alive = 0;
		function terminate {
		    if (--alive == 0) {
			observer.onCompleted();
		    }
		    var tmp = toDispose;
		    toDispose = [];
		    for (x in tmp) x.dispose();
		}
		const d = self.subscribe(DefaultObserver of a {
			override public function onNext from (x is a) to () 
			{
			    const observable = f(x);
			    insert observable.subscribe(observer) into toDispose; // !!
			    alive++;
			}
			override public function onError from (e is java.lang.Exception) to () 
			{
			    terminateWithError(e);
			}
			override public function onCompleted from () to () 
			{
			    terminate();
			}
		    });
		insert d into toDispose;
		Disposable {
		    override function dispose to () 
		    {
			for (x in toDispose) x.dispose()
		    }
		}
	    }
	}
    }

    public function takeUntil of b (sig is Observable of b) to Observable of a 
    {
	until(sig, true);
    }

    public function dropUntil of b (sig is Observable of b) to Observable of a 
    {
	until(sig, false);
    }

    function until of b (sig is Observable of b, taking is Boolean) to Observable of a 
    {
	const self = this;
	DefaultObservable of a {
	    override function subscribe from (ob is Observer of a) to Disposable {
		var enabled is Boolean = taking;
		const sub1 = self.subscribe(Observer of a {
			override public function onNext from (x is a) to () 
			{
			    if (enabled) {
				ob.onNext(x)
			    }
			}
			override public function onError from (e is java.lang.Exception) to () 
			{
			    ob.onError(e);
			}
			override public function onCompleted from () to () 
			{
			    ob.onCompleted();
			}
		    });
		var sub2 is Disposable;
		const unSub2 = function from () to () {
		    if (sub2 <> null) {
			sub2.dispose();
		    }
		    sub2 = null;
		}
		sub2 = sig.subscribe(DefaultObserver of b {
			override public function onNext from (x is b) to () {
			    enabled = not taking;
			    unSub2();
			}
			override public function onError from (e is java.lang.Exception) to () {
			    unSub2();
			}
			override public function onCompleted from () to () {
			    unSub2();
			}
		    });
		Disposable {
		    override function dispose {
			sub1.dispose();
			unSub2();
		    }
		}
	    }
	}
    }

    public function take from (n is Integer) to Observable of a 
    {
	const self = this;
	DefaultObservable of a {
	    override function subscribe from (observer is Observer of a) to Disposable {
		self.subscribe(Observer of a {
			var taken = 0;
			var completed = false;
			override function onNext from (x is a) to () {
			    if (++taken <= n) {
				observer.onNext(x);
			    }
			    if (not completed) {
				if (completed = taken > n) {
				    observer.onCompleted();
				}
			    }
			}
			override function onError from (e is java.lang.Exception) to ()
			{
			    observer.onError(e);
			}
			override function onCompleted from () to ()
			{
			    if (not completed) {
				completed = true;
				observer.onCompleted();
			    }
			}
		    });
	    }
	}
    }

    public function drop from (n is Integer) to Observable of a 
    {
	const self = this;
	DefaultObservable of a {
	    override function subscribe from (observer is Observer of a) to Disposable {
		self.subscribe(Observer of a {
			var pos = 0;
			override function onNext from (x is a) to () {
			    if (pos == n) {
				observer.onNext(x);
			    } else pos++;
			}
			override function onError from (e is java.lang.Exception) to ()
			{
			    observer.onError(e);
			}
			override function onCompleted from () to ()
			{
			    observer.onCompleted();
			}
		    });
	    }
	}
    }

    public function followedBy from (xs is Observable of a) to Observable of a 
    {
	take(1).concat(xs);
    }

    public function concat from (xs is Observable of a) to Observable of a 
    {
	const self = this;
	DefaultObservable of a {
	    override function subscribe from (observer is Observer of a) to Disposable {
		var d2 is Disposable;
		const d1 = self.subscribe (Observer of a {
			/*
			override function onNext from (x is a) to () {
			    observer.onNext(x);
			}
			override function onError from (e is java.lang.Exception) to ()
			{
			    observer.onError(e);
			}
			override function onCompleted from () to ()
			{
			    d2 = xs.subscribe(observer);
			}
			*/
			onNext: observer.onNext;
			onError: observer.onError;
			onCompleted: function { xs.subscribe(observer) }
		    });
		Disposable {
		    override function dispose {
			d1.dispose();
			d2.dispose();
		    }
		}
	    }
	}
    }

    public function merge from (xs is Observable of a) to Observable of a 
    {
	const self = this;
	DefaultObservable of a {
	    override function subscribe from (observer is Observer of a) to Disposable {
		const ob = Observer of a {
		    var completed is Integer = 0;
		    override function onNext from (x is a) to () {
			if (completed < 2) {
			    observer.onNext(x);
			}
		    }
		    override function onError from (e is java.lang.Exception) to ()
		    {
			completed = 2;
			observer.onError(e);
		    }
		    override function onCompleted from () to ()
		    {
			if (++completed == 2) {
			    observer.onCompleted();
			}
		    }
		}
		const d1 = self.subscribe(ob);
		const d2 = xs.subscribe (ob);
		Disposable {
		    override function dispose {
			d1.dispose();
			d2.dispose();
		    }
		}
	    }
	}
    }

    public function buffer from (duration is Duration) to Observable of a 
    {
	buffer(Integer.MAX_VALUE, duration);
    }

    public function buffer from (count is Integer) to Observable of a 
    {
	buffer(count, Duration.INDEFINITE);
    }

    public function buffer from (count is Integer, duration is Duration) to Observable of a 
    {
	const self = this;
	DefaultObservable of a {
	    override function subscribe from (observer is Observer of a) to Disposable 
	    {
		var xs is (..a)[];
		var expiry is Duration = 1ms * java.lang.System.currentTimeMillis() + duration;
		const flush = function from (force is Boolean) to () 
		{
		    if (not force) {
			const now = 1ms * java.lang.System.currentTimeMillis();
			if (expiry < now and not force) {
			    return;
			}
			expiry = now + duration;
		    }
		    const j = if (force) then xs.size() else count;
		    const batch = xs[0..<j];
		    xs[0..<j] = [];
		    for (x in batch) {
			observer.onNext(x);
		    }
		}
		self.subscribe(Observer of a {
			override function onNext from (x is a) to () {
			    insert x into xs;
			    flush(false);
			}
			override function onError from (e is java.lang.Exception) to ()
			{
			    flush(true);
			    observer.onError(e);
			}
			override function onCompleted from () to ()
			{
			    flush(true);
			    observer.onCompleted();
			}
		    });
	    }
	}
    }

    public function zip of b 
	from (xs is Observable of b) to
	Observable of ((a, b))
    {
	zip(xs, function from (x is a, y is b) to (a, b) { (x, y) })
    }

    public function zip of (b, c) 
	from (xs is Observable of b, 
	      f is function from (a, b) to c) 
	to Observable of c 
    {
	const self = this;
	DefaultObservable of c {
	    var ys is (..a)[];
	    var zs is (..b)[];
	    var completed = false;
	    override function subscribe from (observer is Observer of c) to Disposable {
		function flush {
		    if (not completed) {
			const j = java.lang.Math.min(ys.size(), zs.size());
			const left = ys[0..<j];
			const right = zs[0..<j];
			ys[0..<j] = [];
			zs[0..<j] = [];
			for (i in [0..<j]) {
			    observer.onNext(f(left[i], right[i]));
			}
		    }
		}
		function err from (e is java.lang.Exception) to () {
		    completed = true;
		    observer.onError(e);
		}
		function complete {
		    completed = true;
		    observer.onCompleted();
		}
		const d1 = self.subscribe(DefaultObserver of a {
			override function onNext from (x is a) to () {
			    if (not completed) {
				insert x into ys;
				flush();
			    }
			}
			override function onError from (e is java.lang.Exception) to ()
			{
			    if (not completed) {
				err(e);
			    }
			}
			override function onCompleted from () to ()
			{
			    if (not completed) {
				complete();
			    }
			}
		    });
		const d2 = xs.subscribe(DefaultObserver of b {
			override function onNext from (x is b) to () {
			    if (not completed) {
				insert x into zs;
				flush();
			    }
			}
			override function onError from (e is java.lang.Exception) to ()
			{
			    if (not completed) {
				err(e);
			    }
			}
			override function onCompleted from () to ()
			{
			    if (not completed) {
				complete();
			    }
			}
		    });
		Disposable {
		    override function dispose {
			d1.dispose();
			d2.dispose();
		    }
		}
	    }
	}
    }

    public function accumulate of b 
	from (z is b, f is function from (b, a) to b) 
	to Observable of b 
    {
	fold(z, f)
    }

    public function fold of b 
	from (z is b, f is function from (b, a) to b) 
	to Observable of b 
    {
	const self = this;
	DefaultObservable of b {
	    override function subscribe from (observer is Observer of b) to Disposable {
		self.subscribe(Observer of a {
			var r = z;
			override function onNext from (x is a) to () {
			    observer.onNext(r = f(r, x));
			}
			override function onError from (e is java.lang.Exception) to ()
			{
			    observer.onError(e);
			}
			override function onCompleted from () to ()
			{
			    observer.onCompleted();
			}
		    });
	    }
	}
    }

    public function always of b from (x is b) to Observable of b 
    {
	map(function from (_ is a) to b 
	    {
		x
	    })
    }

    public function apply from () to Observable of (()) 
    {
	always(())
    }

    public function partition from (f is function from a to Boolean) 
	to (Observable of a)[]
    {
	var d0 is Disposable;
	var d1 is Disposable;
	const y = Subject of a {
	    override function onNext from (x is a) to () {
		if (f(x)) super.onNext(x);
	    }
	    override function onError from (e is java.lang.Exception) to ()
	    {
		d0.dispose();
		super.onError(e);
	    }
	    override function onCompleted from () to ()
	    {
		d0.dispose();
		super.onCompleted();
	    }
	};
	const n = Subject of a {
	    override function onNext from (x is a) to () {
		if (f(x)) super.onNext(x);
	    }
	    override function onError from (e is java.lang.Exception) to ()
	    {
		d1.dispose();
		super.onError(e);
	    }
	    override function onCompleted from () to ()
	    {
		d1.dispose();
		super.onCompleted();
	    }
	}
	d0 = subscribe(y);
	d1 = subscribe(n);
	[y, n]
    }

}

public abstract class DefaultObservable of a is Observable of a, org.f3.runtime.Monad of (Observable, a) 
{
}


public function observe of a
    from (xs is (..a)[]) 
    to Observable of a 
{
    DefaultObservable of a {
	override public function subscribe 
	    from (observer is Observer of a) 
	    to Disposable 
	{
	    foreach (x in xs) {
		observer.onNext(x);
	    }
	    observer.onCompleted();
	    Disposable.empty();
	}
    }
}

public function observe of (f is org.f3.runtime.Functor, a) 
    from (xs is org.f3.runtime.Functor of (f, a)) 
    to Observable of a 
{
    DefaultObservable of a {
	override public function subscribe from (observer is Observer of a) to Disposable 
	{
	    foreach (x in xs) {
		observer.onNext(x);
	    }
	    observer.onCompleted();
	    Disposable.empty();
	}
    }
}

public function observe of (class F of _, a) 
    from (xs is F of a) 
    to Observable of a 
    with (_ is the Functor of F)
{
    DefaultObservable of a {
	override public function subscribe from (observer is Observer of a) to Disposable 
	{
	    foreach (x in xs) {
		observer.onNext(x);
	    }
	    observer.onCompleted();
	    Disposable.empty();
	}
    }
}

public function return of a from (x is a) to Observable of a 
{
    DefaultObservable of a {
	override public function subscribe from (observer is Observer of a) to Disposable 
	{
	    observer.onNext(x);
	    observer.onCompleted();
	    Disposable.empty();
	}
    }
}

public function error of a 
       from (e is java.lang.Exception) 
       to Observable of a 
{
    DefaultObservable of a {
	override public function subscribe 
	from (observer is Observer of a) 
	to Disposable 
	{
	    observer.onError(e);
	    Disposable.empty();
	}
    }
}

public function never of a to Observable of a 
{
    DefaultObservable of a {
	override public function subscribe from (observer is Observer of a) to Disposable 
	{
	    Disposable.empty();
	}
    }
}

public function empty of a to Observable of a 
{
    DefaultObservable of a {
	override public function subscribe from (observer is Observer of a) to Disposable 
	{
	    observer.onCompleted();
	    Disposable.empty();
	}
    }

}

/*
public function every from (dur is Duration) to Observable of Integer {

    DefaultObservable of Integer {
	public override function subscribe from (observer is Observer of Integer) to Disposable {
	    var nextTime is Duration;
	    var counter = 0;
	    const timeline = f3.media.scene.Timeline {
		override function setPlayhead from (t is Duration) to () {
		    if (nextTime == 0s) nextTime = t;
		    if (not paused) {
			if (nextTime <= t) {
			    nextTime += dur;
			    observer.onNext(counter++);
			}
		    }
		}
	    }
	    Disposable {
		override function dispose {
		    timeline.paused = true;
		}
	    }
	}
    }
}

*/

class Println of a is DefaultObserver of a
{
    override function onNext from (x is a) to () {
	println(x);
    }
}

function Println of a to Println of a 
{
    Println of a {}
}

public function run 
{
    const j =
	foreach (x in Observable.return(1), y in Observable.return(2)) x + y;
    const d = j.subscribe(Println of Integer());
    d.dispose();
    /*    
    const k = observe([1..10]);
    k.take(6).subscribe(new Println of Integer());

    const l = foreach (x in observe(List.asList([1..10]))) "#{x}";
    l.drop(3).subscribe(Println of String());
    const e = every(1s);
    e.subscribe(Println of Integer());

    for (i in [1..100]) {
	f3.media.scene.MasterTimeline.setPlayhead(0.5s * i);
    }
    */
}

