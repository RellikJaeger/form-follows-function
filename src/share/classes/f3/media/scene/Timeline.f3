package f3.media.scene;
import f3.util.*;
import f3.math.*;
import java.lang.Math;
import f3.lang.Ref;
import f3.util.*;

public class Timeline 
{
    init {
	MasterTimeline.timelines.put(this, ());
    }

    function interpolateChannels from (channels is (Channel of (?))[],
				       sceneTime is Duration) to () 
    {
	const map is java.util.Map of (Ref of Object, (Channel of Object)[]) = 
	    new java.util.HashMap of (Ref of Object, (Channel of Object)[])();
	if (Channel.DEBUG) {
	    println("interpolating {foreach (x in channels) "{x}, "}");
	}
	for (ch in channels where ch.sceneBlendWeight > 0.0) 
	{
	    for (target0 in ch.targets) {
		const target = target0 as Ref of Object;
		const chs = map.get(target);
		map.put(target, [chs, ch as Channel of Object]);
	    }
	}
	for (ent in map.entrySet()) {
	    const target = ent.getKey();
	    const chs = ent.getValue();
	    var weight = 0.0;
	    for (ch in chs) {
		weight += ch.sceneBlendWeight;
	    }
	    var r;
	    var first = true;
	    for (ch in chs) {
		const w = ch.blendWeight / weight;
		r = interpolateChannel(ch, sceneTime, r, w);
	    }
	    target.set(r);
	}
    }

    var positionSubject is Subject of Duration;

    public function observePlayhead to Observable of Duration {
	if (positionSubject == null) then positionSubject = Subject of Duration {} else positionSubject;
    }

    function interpolateChannel
	from (ch is Channel of Object, 
	      sceneTime is Duration,
	      r is Object, 
	      weight is Number) 
	to Object 
    {
	ch.interpolate(sceneTime, weight, r);
    }

    public var paused is Boolean = false;
    public var content is TimeNode[];
    public const root is TimeGroup = 
    {
	const timeline = this;
	TimeGroup { 
	    content: bind content; 
	    override var toSceneTransform = TimeMat.<<1>>;
	    override var pausedInScene = bind timeline.paused;
	}
    }

    public readonly var underPlayhead is TimeNode[];

    public function advancePlayhead from (delta is Duration) to ()
    {
	setPlayhead(playhead + delta);
    }

    public function setPlayhead
	from (sceneTime is Duration) 
	to () 
    {
	playhead = sceneTime;
	root.updateParent();
        underPlayhead = pick(sceneTime);
	const chs = foreach (n in underPlayhead where n is Channel of ?) n as Channel of ?;
	interpolateChannels(chs, sceneTime);
        root.visit(function from (n is TimeNode) to () 
		   { 
		       n.update(sceneTime);
		   });
	positionSubject.onNext(playhead);
    }

    public readonly var playhead is Duration;

    public function pick
	from (point is Duration)
	to TimeNode[] 
    {
        var result is TimeNode[];
        root.doPick(point, 
		    point, 
		    point,
		    function from (n is TimeNode) to ()
		    {
			insert n into result;
		    });
        return result;
    }

}




