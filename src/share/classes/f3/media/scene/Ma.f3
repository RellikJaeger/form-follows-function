package f3.media.scene;
import f3.math.*;
import f3.util.*;
import f3.math.LinearMath.*;
import f3.media.scene.*;
import f3.lang.Ref;
import f3.lang.ConstRef;
import f3.lang.AbstractRef;
import f3.lang.MemberRef;
import org.f3.runtime.F3Object;
import org.f3.runtime.Pointer;
import f3.lang.AbstractConstRef;
import java.lang.Math;
import f3.media.scene.meshdeform.BlendShape;
import f3.media.scene.meshdeform.SkinCluster;
import f3.media.scene.meshdeform.MeshDeformer;
import f3.util.Bits;
import f3.media.scene.Constraint.*;

public const DEBUG_LINKS = Boolean.getBoolean("f3.ma.debug.links");

function rotate 
    from (rx is Number, ry is Number, rz is Number, ro is Integer) 
    to Mat4 
{
    qrotate(rx, ry, rz, ro).toMat4();
}

function qrotate 
    from (rx is Number, ry is Number, rz is Number, ro is Integer) 
    to Quat
{
    const angles = [rx, ry, rz];
    var q = Quat.<<1>>;
    const rots = foreach (i in [0..2]) { 
        const j = RotateOrder[ro*3+i]; 
        Quat.Quat(angles[j], axes[j]);
    }
    for (r in rots.reverse()) {
        q *= r;
    }
    return q;
}

class MAttr {
    const longName is String;
    const shortName is String;
    const type is String;
    var value is Object;
    const parent is MAttr;
}

class MaModel 
{
    public var dynamicsWorld is DynamicsWorld;

    const nodeMap is java.util.Map of (String, MNode) = 
        new java.util.HashMap of (String, MNode);

    function findNode from (name is String) to MNode 
    {
        nodeMap.get(name);
    }

    function recordResource from (url is String) to ()
    {
        resourceUrls.add(url);
    }

    var resourceUrls = new java.util.HashSet of (String);

    var current is MNode; 

    var effectLoader is CGEffectLoader;
    var imageLoader is ImageLoader;

    function createNode from (cmd is Command) to () 
    {
        const nodeType = cmd.getString(0);
        const name = cmd.getString("n");
        const parent = cmd.getString("p");

        current = 
            if (nodeType == "transform") 
                then MTransform {name: name, parent: findNode(parent)}
            else if (nodeType == "joint") 
                then MJoint {name: name, parent: findNode(parent)}
            else if (nodeType == "camera") 
                then MCamera {name: name, parent: findNode(parent)}
            else if (nodeType == "mesh") 
                then MMesh {name: name, parent: findNode(parent)}
            else if (nodeType == "phong" or nodeType == "blinn" or nodeType == "lambert") 
                then MShader {type: nodeType, name: name  parent: findNode(parent)}
            else if (nodeType == "cgfxShader") 
                then MCGFXShader {name: name parent: findNode(parent) }
            else if (nodeType == "cgfxVector") 
                then MCGFXVector {name: name parent: findNode(parent) }
            else if (nodeType == "file") 
                then MFile {name: name parent: findNode(parent) }
            else if (nodeType == "shadingEngine") 
                then MShadingEngine {name: name parent: findNode(parent) }
            else if (nodeType == "pointLight") 
                then MLight { name: name, parent: findNode(parent), type: nodeType }
            else if (nodeType.startsWith("animCurve")) 
                then MAnimCurve__ {type: nodeType, name: name, parent: findNode(parent)}
            else if (nodeType == "character") 
                then MCharacter {name: name parent: findNode(parent) }
            else if (nodeType == "animClip") 
                then MAnimClip {name: name  parent: findNode(parent)}
            else if (nodeType == "clipLibrary") 
                then MClipLibrary {name: name  parent: findNode(parent)}
            else if (nodeType == "addDoubleLinear") 
                then MAddDoubleLinear {name: name  parent: findNode(parent)}
            else if (nodeType == "plusMinusAverage") 
                then MPlusMinusAverage {name: name parent: findNode(parent)}
            else if (nodeType == "multiplyDivide" ) 
                then MMultiplyDivide {name: name parent: findNode(parent)}
            else if (nodeType == "pairBlend" ) 
                then MPairBlend {name: name parent: findNode(parent)}
            else if (nodeType == "clamp") 
                then MClamp {name: name  parent: findNode(parent)}
            else if (nodeType == "reverse") 
                then MReverse {name: name  parent: findNode(parent)}
            else if (nodeType == "blendShape") 
                then MBlendShape {name: name  parent: findNode(parent)}
            else if (nodeType == "skinCluster") 
                then MSkinCluster {name: name  parent: findNode(parent)}
            else if (nodeType == "groupParts") 
                then MGroupParts {name: name  parent: findNode(parent)}
            else if (nodeType == "pointConstraint") 
                then MPointConstraint {name: name  parent: findNode(parent)}
            else if (nodeType == "parentConstraint") 
                then MParentConstraint {name: name  parent: findNode(parent)}
            else if (nodeType == "orientConstraint") 
                then MOrientConstraint {name: name  parent: findNode(parent)}
            else if (nodeType == "aimConstraint") 
                then MAimConstraint {name: name  parent: findNode(parent)}
            else if (nodeType == "poleVectorConstraint") 
                then MPoleVectorConstraint {name: name  parent: findNode(parent)}
            else if (nodeType == "ikHandle") 
                then MIKHandle {name: name  parent: findNode(parent)}
            else if (nodeType == "ikEffector") 
                then MIKEffector {name: name  parent: findNode(parent)}
            else if (nodeType == "tweak") 
                then MTweak {name: name  parent: findNode(parent)}
            else if (nodeType == "rigidBody") 
                then MLegacyRigidBody {name: name  parent: findNode(parent)}
            else if (nodeType == "rigidConstraint") 
                then MLegacyRigidConstraint {name: name  parent: findNode(parent)}
            else if (nodeType == "bulletRigidBodyShape") 
                then MBulletRigidBodyShape {name: name  parent: findNode(parent)}
            else if (nodeType == "bulletRigidBodyConstraintShape") 
                then MBulletRigidBodyConstraintShape {name: name  parent: findNode(parent)}
            else if (nodeType == "gravityField") 
                then MGravityField {name: name  parent: findNode(parent)}
            else if (nodeType == "radialField") 
                then MRadialField {name: name  parent: findNode(parent)}
            else if (nodeType == "vortexField") 
                then MVortexField {name: name  parent: findNode(parent)}
            else if (nodeType == "choice") 
                then MChoice {name: name  parent: findNode(parent)}
            else if (nodeType == "script") {
                if (name == "sceneConfigurationScriptNode") then MSceneConfig {model: this} else null
            }
            else null;
        if (current <> null) {
            nodeMap.put(current.name, current);
            nodeMap.put(current.getFullName(), current);
        }
    }

    var lastSetAttr is Command;
    function mergeSetAttr from (next is Command) to () 
    {
        const c = lastSetAttr;
        lastSetAttr = null;
        if (c <> null) {
            next.namedArgs.putAll(c.namedArgs);
        }
    }

    function processCommand from (cmd is Command) to () 
    {
        const n = cmd.name;
        if (n == "createNode") {
            lastSetAttr = null;
            createNode(cmd);
        } else if (n == "setAttr") {
            if (cmd.args.size() > 1) {
                mergeSetAttr(cmd);
                setAttr(cmd);
            } else {
                lastSetAttr = cmd;
            }
        } else if (n == "select") {
            const name = cmd.getString(0);
            current = if name == null then null else nodeMap.get(name);
            lastSetAttr = null;
        } else if (n == "addAttr") {
            addAttr(cmd);
        } else if (n == "connectAttr") {
            connectAttr(cmd)
        } else if (n == "parent") {
            const src = cmd.getString("add");
            const target = cmd.getString(0);
            const srcNode = findNode(src);
            const targetNode = findNode(target);
            if (srcNode instanceof MMesh) {
                insert targetNode into (srcNode as MMesh).parents;
            }
        }
    }

    function addAttr from (cmd is Command) to () 
    {
        if (current != null) {
            current.addAttr(cmd);
        }
    }

    function setAttr from (cmd is Command) to () 
    {
        if (current != null) {
            current.setAttr(cmd);
        }
    }
    
    function connectAttr from (cmd is Command) to () 
    {
        const source = cmd.getString(0);
        var dot = source.indexOf(".");
        const sourceName = source.substring(0, dot);
        const sourcePath = source.substring(dot+1);
        const target = cmd.getString(1);
        dot = target.indexOf(".");
        const targetName = target.substring(0, dot);
        const targetPath = target.substring(dot+1);
        const sourceNode = findNode(sourceName);
        const targetNode = findNode(targetName);
        if (sourceNode == null or targetNode == null) return;
        println("connectAttr {sourceNode} => {targetNode} from {sourceName}.{sourcePath} to {targetName}.{targetPath}");
        const conn = 
            Connection 
            {
                sourceNode: sourceNode;
                sourcePath: sourcePath;
                targetNode: targetNode;
                targetPath: targetPath;
            }
        sourceNode.addConnectionFrom(conn);
        targetNode.addConnectionTo(conn);
    }

    const spatialMap is java.util.Map of (MNode, Node) = 
        new java.util.HashMap of (MNode, Node) ();

    const constraintMap is java.util.Map of (MNode, Constraint) = 
        new java.util.HashMap of (MNode, Constraint) ();

    const temporalMap is java.util.Map of (MNode, TimeNode) = 
        new java.util.HashMap of (MNode, TimeNode) ();

    const shaderMap is java.util.Map of (MNode, Shader) = 
        new java.util.HashMap of (MNode, Shader) ();

    const clipLibMap is java.util.Map of (MNode, TimeGroup) = 
        new java.util.HashMap of (MNode, TimeGroup) ();

    const linkMap is java.util.Map of (MNode, (Link of ?)[]) = 
        new java.util.HashMap of (MNode, (Link of ?)[]) ();

    const deformerMap is java.util.Map of (MNode, MeshDeformer) = 
        new java.util.HashMap of (MNode, MeshDeformer) ();

    const rigidBodyMap is java.util.Map of (MNode, Collider) = 
        new java.util.HashMap of (MNode, Collider) ();

    const rigidBodyConstraintMap is java.util.Map of (MNode, RigidBodyConstraint) = 
        new java.util.HashMap of (MNode, RigidBodyConstraint) ();

    const forceFieldMap is java.util.Map of (MNode, ForceField) = 
        new java.util.HashMap of (MNode, ForceField) ();

    public var url is String;

    public var spatialRoot is Group;
    public var temporalRoot is TimeGroup;
    public var startFrame is Number;
    public var endFrame is Number;
    var channels is TimeNode[];
    var clipLibs is TimeGroup[];
    var shaders is Shader[];

    function checkDeformers() {
        /*
        const disable = temporalRoot.bounds.duration() == 0s;
        if (disable) {
            spatialRoot.foldLeft((), function from (_ is (), n is Node) to ()
                                 {
                                     if (n is MeshNode) {
                                         const mn = n as MeshNode;
                                         for (x in mn.deformers) { x.enabled = false; }
                                     }
                                 });
        }
        */
    }


    function getCameras to Camera[] 
    {
        foreach (n in spatialMap.values() where n is Camera) n as Camera;
    }

    function getShaders to Shader[] 
    {
        f3.util.Sequences.sort(foreach (x in shaderMap.values() where x.id <> "") x, java.util.Comparator of Shader {
                override function compare from (x is Shader, y is Shader) to Integer {
                    x.id.compareTo(y.id)
                }
            });
    }

    function toNode from (n is MSpatial) to Node 
    {
        if spatialMap.containsKey(n)
            then spatialMap.get(n) 
            else spatialMap.put(n, n.toNode(this))
    }

    function toConstraint from (n is MConstraint) to Constraint 
    {
        if constraintMap.containsKey(n)
            then constraintMap.get(n) 
            else constraintMap.put(n, n.toConstraint(this))
    }

    function resolveInput 
        from (n is MNode, 
              attr is String, 
              i is Integer,
              value is Number) 
        to ConstRef of Number
    {
        var result is ConstRef of Number;
        const key = if (n.connectionsToThis.containsKey(attr)) then attr else {
                const xyz = "xyz";
                const rgb = "rgb";
                const abc = "012";
                const k1 = "{attr}{xyz.charAt(i)}";
                if (n.connectionsToThis.containsKey(k1)) then k1 else {
                        const k2 = "{attr}{rgb.charAt(i)}";
                        if (n.connectionsToThis.containsKey(k2)) then k2 else "{attr}[{abc.charAt(i)}]";
                    }
            }
        println("key={key}");
        for (c in n.connectionsToThis.get(key)) {
            if (c.sourceNode is MUtilityOfNumber) {
                const src = c.sourceNode as MUtilityOfNumber;
                result = src.getOutput(this, c.sourcePath);
            } else {
                result = resolveSourcePointer(c) as Ref of Number;
            }
        }
        if (result == null) {
            result = AbstractConstRef of Number {
                override function get to Number { value }
            }
        }
        return result;
    }

    function resolveInput 
        from (n is MNode, 
              attr is String, 
              value is Number) 
        to ConstRef of Number
    {
        resolveInput(n, attr, 0, value);
    }

    function resolveInput 
        from (n is MUtility, 
              attr is String, 
              value is Tuple3) 
        to ConstRef of Tuple3
    {
        var result is ConstRef of Tuple3;
        for (c in n.connectionsToThis.get(attr)) {
            if (c.sourceNode is MUtility of Tuple3) {
                const src = c.sourceNode as MUtilityOfTuple3;
                result = src.getOutput(this, c.sourcePath);
            } else {
                result = resolveSourcePointer(c) as ConstRef of Tuple3;
            }
        }
        if (result == null) {
            const fx = resolveInput(n, "{attr}", 0, value.x);
            const fy = resolveInput(n, "{attr}", 1, value.y);
            const fz = resolveInput(n, "{attr}", 2, value.z);
            result = AbstractConstRef of Tuple3 {
                override function get to Tuple3 {
                    tuple(fx.get(), fy.get(), fz.get());
                }
            }
        }
        return result; 
    }

    function resolveTargetPointer from (c is Connection) to Ref of ?
    {
        const target = c.targetNode;
        var key = c.targetPath;
        const attr = if (target is MConstraint) then null else target.attrs.get(key); 
        var attrType is String;
        var parentAttrType is String;
        if (attr <> null) {
            attrType = attr.type;
            if (attr.parent <> null) {
                parentAttrType = attr.parent.type;
                key = attr.parent.shortName;
            }
            for (c1 in target.connectionsFromThis.get(key)) {
                const p = resolveTargetPointer(c1);
                if (p <> null) {
                    println("resolved {c} via {c1} to {p}");
                    return p;
                }
            }
        }
        var ptr = 
        if (target instanceof MCharacter) {
            (target as MCharacter).resolveTargetPointer(this, c)
        } else if (target instanceof MBlendShape) {
            (target as MBlendShape).resolveTargetPointer(this, c)
        } else if (target instanceof MSpatial) {
            const resolved = toNode(target as MSpatial);
            target.getPointer(key, resolved);
        } else if (target instanceof MConstraint) {
            const resolved = toConstraint(target as MConstraint);
            target.getPointer(key, resolved);
        } else if (target instanceof MAbstractShader) {
            const resolved = toShader(target as MAbstractShader);
            println("resolved shader {target.name} to {resolved}");
            target.getPointer(key, resolved);
        } else if (target instanceof MChoice) {
            const conns = target.connectionsFromThis.get("o");
            //println("resolve choice conns=>{conns}");
            var rptr is Ref of ?;
            for (conn in conns) {
                rptr = resolveTargetPointer(conn);
                //println("conn={conn}, ptr=>{rptr}");
            }
            rptr;
        } else if (target instanceof MAnimCurve) {
            const ch = toChannel(target as MAnimCurve, false) as Channel of ?;
            ch.targets[0];
        } else null;
        if (ptr == null and attr <> null) { // hack: assume user defined attr
            if (attr.parent <> null) {
                ptr = &attr.parent.value as Ref of ?;
            } else {
                ptr = &attr.value as Ref of ?;
            }
        }
        if (attr.parent <> null) {
            const v is Object = ptr.get();
            var t = parentAttrType; // can be wrong...
            if (v is Tuple4) {
                t = "float4";
            }
            if (t == "float4") { // these hacks needed at least for cgfx shaders
                const name = attr.shortName.toUpperCase();
                const ptrv = ptr as Ref of Tuple4;
                if (name.endsWith("X")) {
                    ptr = AbstractRef of Number {
                        override function get to Number {
                            ptrv.get().x;
                        }
                        override function set from (n is Number) to () {
                            const t = ptrv.get();
                            ptrv.set(tuple(n, t.y, t.z, t.w));
                        }
                    } as Ref of ?;
                } else if (name.endsWith("Y")) {
                    ptr = AbstractRef of Number {
                        override function get to Number {
                            ptrv.get().y;
                        }
                        override function set from (n is Number) to () {
                            const t = ptrv.get();
                            ptrv.set(tuple(t.x, n, t.z, t.w));
                        }
                    } as Ref of ?;
                } else if (name.endsWith("Z")) {
                    ptr = AbstractRef of Number {
                        override function get to Number {
                            ptrv.get().z;
                        }
                        override function set from (n is Number) to () {
                            const t = ptrv.get();
                            ptrv.set(tuple(t.x, t.y, n, t.w));
                        }
                    } as Ref of ?;
                } else if (name.endsWith("W")) {
                    ptr = AbstractRef of Number {
                        override function get to Number {
                            ptrv.get().w;
                        }
                        override function set from (n is Number) to () {
                            const t = ptrv.get();
                            ptrv.set(tuple(t.x, t.y, t.z, n));
                        }
                    } as Ref of ?;
                }
            }
        }
        return ptr;
    }

    function resolveSourcePointer
        from (c is Connection) to Ref of ?
    {
        const target = c.sourceNode;
        println("resolve source pointer {c} in {target}");
        if (target instanceof MCharacter) {
            (target as MCharacter).resolveSourcePointer(this, c)
        } else if (target instanceof MSpatial) {
            const resolved = toNode(target as MSpatial);
            target.getPointer(c.sourcePath, resolved);
        } else if (target instanceof MConstraint) {
            const resolved = toConstraint(target as MConstraint);
            target.getPointer(c.sourcePath, resolved);
        } else if (target instanceof MAbstractShader) {
            const resolved = toShader(target as MAbstractShader);
            println("resolved shader: {resolved}");
            target.getPointer(c.sourcePath, resolved);
        } else null
    }

    function getNumberTargets 
        from (n is MNode, sourcePath is String) to (Ref of Number)[]
    {
        println("attempting to resolve {n.name} {sourcePath} in {n.connectionsFromThis}");
        foreach (c in n.connectionsFromThis.get(sourcePath)) {
            println(c);
            const ptr = resolveTargetPointer(c) as Ref of Number;
            println("resolved {n.name} {sourcePath} to {ptr}");
            ptr;
        }
    }

    function toParentNode from (n is MSpatial) to Group
    {
        const node = toNode(n);
        if (node == null) then spatialRoot else node as Group;
    }

    function toChannel from (n is MAnimCurve, clip is Boolean) to TimeNode
    {
        var ch is TimeNode;
        if (temporalMap.containsKey(n)) {
            ch = temporalMap.get(n);
        } else {
            ch = n.toChannel(this, clip);
            if (ch <> null) {
                if (not clip) {
                    insert ch into channels;
                } else {
                    delete ch from channels;
                }
                println("created channel: {ch}");
                temporalMap.put(n, ch);
            }
        }
        return ch;
    }

    function toForceField from (n is MField) to ForceField
    {
        if (forceFieldMap.containsKey(n)) then forceFieldMap.get(n) else {
                const f = n.toForceField(this);
                forceFieldMap.put(n, f);
                f;
            };
    }

    function toRigidBody from (n is MRigidBody) to Collider
    {
        if (rigidBodyMap.containsKey(n)) then rigidBodyMap.get(n) else {
                const rb = n.toRigidBody(this);
                rigidBodyMap.put(n, rb);
                rb;
            };
    }

    function toRigidBodyConstraint from (n is MRigidBodyConstraint) to RigidBodyConstraint
    {
        if (rigidBodyConstraintMap.containsKey(n)) then rigidBodyConstraintMap.get(n) else {
                const rbc = n.toRigidBodyConstraint(this);
                rigidBodyConstraintMap.put(n, rbc);
                rbc;
            };
    }

    var defaultShader is Shader;
    function getDefaultShader to Shader {
        if (defaultShader == null) {
            defaultShader = 
                effectLoader.loadDefaultShader(null,
                                               Color.GRAY,
                                               Color.BLACK,
                                               Color.BLACK,
                                               Color.BLACK,
                                               0);
        }
        return defaultShader;
    }


    function toShader from (n is MAbstractShader) to Shader
    {
        if (n == null) {
            getDefaultShader();
        } else {
            if (shaderMap.containsKey(n)) then shaderMap.get(n) else {
                    const shader = n.toShader(this);
                    shaderMap.put(n, shader);
                }
        }
    }

    function toBlendShape from (n is MBlendShape) to BlendShape {
        if (deformerMap.containsKey(n)) then deformerMap.get(n) as BlendShape else {
                const blendShape = n.toBlendShape(this);
                deformerMap.put(n, blendShape) as BlendShape;
            }
    }

    function toSkinCluster from (n is MSkinCluster) to SkinCluster {
        if (deformerMap.containsKey(n)) then deformerMap.get(n) as SkinCluster else {
                const skinCluster = n.toSkinCluster(this);
                deformerMap.put(n, skinCluster) as SkinCluster;
            }
    }

    function toLink from (n is MUtility) to (Link of ?)[]
    {
        if (linkMap.containsKey(n)) then linkMap.get(n) else {
                const link = n.toLink(this);
                linkMap.put(n, link);
            }
    }

    function toClipLibrary from (n is MClipLibrary) to TimeNode 
    {
        var r is TimeGroup = clipLibMap.get(n);
        if (r == null) {
            println("converting clip library {n.name}");
            const clipMap = new java.util.TreeMap of (Integer, TimeGroup);
            println("connections={n.connectionsToThis.get("sc")}");
            for (conn in n.connectionsToThis.get("sc")) {
                const path = parsePath(conn.targetPath).path;
                const i = (path[1] as Index).index;
                const sourceClip = conn.sourceNode as MAnimClip;
                var clip is MNode; 
                for (targ in sourceClip.connectionsFromThis.get("cl")) {
                    if (targ.targetNode is MAnimClip) {
                        clip = targ.targetNode;
                        break;
                    }
                }
                const start = 1s/24 * (sourceClip.sf-1);
                const end = 1s/24 * (sourceClip.se);
                println("creating clip {clip.name} {start}..{end}");
                const tg = TimeGroup {
                    playTime: start;
                    id: clip.name;
                }
                clipMap.put(i, tg);
            }
            for (conn in n.connectionsToThis.get("cel")) {
                const path = parsePath(conn.targetPath).path;
                const celIndex = (path[1] as Index).index;
                const clip = clipMap.get(celIndex);
                //const cevIndex = (path[3] as Index).index;
                const animCurve = conn.sourceNode as MAnimCurve;
                const ch = toChannel(animCurve, true);
                if (ch <> null and ch.bounds.duration() > 0s) {
                    println("adding channel {ch.id} {ch.bounds} to {clip.id}");
                    insert ch into clip.content;
                } else {
                    println("didn't create channel {animCurve.name} for {clip.id}: {ch}");                    
                }
            }
            const clips = foreach (clip in clipMap.values()) clip;
            for (clip in clips) {
                println("created clip: {clip.id} with {clip.content.size()} channels");
            }
            r = TimeGroup {
                id: n.name;
                content: clips;
            }
            clipLibMap.put(n, r);
            insert r into clipLibs;
        }
        return r;
    }
    function generateScene 
    {
        for (n in nodeMap.values() where n instanceof MCharacter) {
            (n as MCharacter).applyAlias(this);
        }
        spatialRoot = Group {id: url};
        var rigidBodies is MRigidBody[];
        var rigidConstraints is MRigidBodyConstraint[];
        for (n in nodeMap.values()) {
            if (n is MSpatial) {
                toNode(n as MSpatial);
            } else if (n is MConstraint) {
                toConstraint(n as MConstraint);
            } else if (n is MAnimCurve) {
                toChannel(n as MAnimCurve, false);
            } else if (n instanceof MClipLibrary) {
                toClipLibrary(n as MClipLibrary);
            } else if (n instanceof MUtility) {
                toLink(n as MUtility);
            } else if (n instanceof MBlendShape) {
                toBlendShape(n as MBlendShape);
            } else if (n instanceof MSkinCluster) {
                const skinCluster = toSkinCluster(n as MSkinCluster);
                skinCluster.root = spatialRoot;
            } else if (n instanceof MRigidBody) {
                //toRigidBody(n as MRigidBody);
                insert n as MRigidBody into rigidBodies;
            } else if (n instanceof MRigidBodyConstraint) {
                //toRigidBodyConstraint(n as MRigidBodyConstraint);
                insert n as MRigidBodyConstraint into rigidConstraints;
            }
        }
        const startFrame = this.startFrame;
        const endFrame = this.endFrame;
        const linkMap = this.linkMap;
        var links is Link[];
        for (link in linkMap.values()) insert link into links;
        const playRange = Interval { start: FPS * startFrame, end: FPS * endFrame };
        temporalRoot = finishGenerateScene(startFrame, endFrame, links, playRange, channels, url, spatialRoot);
        for (link in links) {
            link.apply();
        }
        for (rb in rigidBodies) {
            toRigidBody(rb);
        }
        for (rc in rigidConstraints) {
            toRigidBodyConstraint(rc);
        }
    }

}

// this is a hack to avoid a memory leak of the MaModel - due to compiler code generation design bugs
function finishGenerateScene from (startFrame is Number, endFrame is Number, links is Link[], playRange is Interval, channels is TimeNode[], url is String, spatialRoot is Node) to TimeGroup
{
    const temporalRoot = TimeGroup {
        id: url
        // playRange: if (playRange.duration <> 0s) playRange else null;
        override function update from (sceneTime is Duration) to () {
            super.update(sceneTime);
            for (link in links) link.apply();
        }
    };
    var j = 0;
    var g = TimeGroup {id: "{temporalRoot.id}#{j++}"};
    for (ch in channels) {
        if (g.content.size() > 50) { // hack
            insert g into temporalRoot.content;
            g = TimeGroup {id: "{temporalRoot.id}#{j++}"};
        }
        insert ch into g.content;
    }
    insert g into temporalRoot.content;
    println(spatialRoot.foldLeft("", function from (y is String, x is Node) to String 
                                 {
                                     if (y == "") then "{x.id}" else "{y} -> {x.id}";
                                 }));
    /*
      println(temporalRoot.foldLeft("", function from (y is String, x is TimeNode) to String 
      {
      if (y == "") then "{x.id}" else "{y} => {x.id}";
      }));
    */
    return temporalRoot;
}

function makeRefX from (ref is Ref of Number) to Ref of Tuple3 
{
    AbstractRef of Tuple3 {
        override public function get to Tuple3 {
            tuple(ref.get(), 0, 0);
        }
        override public function set from (tuple is Tuple3) to () {
            ref.set(tuple.x);
        }
    }
}

function makeRefY from (ref is Ref of Number) to Ref of Tuple3 
{
    AbstractRef of Tuple3 {
        override public function get to Tuple3 {
            tuple(0, ref.get(), 0);
        }
        override public function set from (tuple is Tuple3) to () {
            ref.set(tuple.y);
        }
    }
}

function makeRefZ from (ref is Ref of Number) to Ref of Tuple3 
{
    AbstractRef of Tuple3 {
        override public function get to Tuple3 {
            tuple(0, 0, ref.get());
        }
        override public function set from (tuple is Tuple3) to () {
            ref.set(tuple.z);
        }
    }
}

abstract class AbstractMemberRef of (b is F3Object, a) is AbstractRef of a, MemberRef of b {
}

function makeMemberRef from (name is String, ptr is String, result is Pointer of (MaTransform, Number)) to Ref of Number
{
    AbstractMemberRef of (MaTransform, Number) {

        override function getF3Object to MaTransform { result.getF3Object() }
    
        override function toString to String 
        {
            "{name}.{ptr} = {get()}";
        }
        override function get to Number
        {
            result.get();
        }
        override function set from (x is Number) to () 
        {
            result.set(x);
        }
        override function hashCode to Integer 
        {
            result.hashCode();
        }
        override function equals from (obj is Object) to Boolean
        {
            super.equals(obj) or obj.equals(result)
        }
    }
}

function makeRef of a from (name is String, ptr is String, result is Ref of a) to Ref of a 
{
    AbstractRef of a {
        override function toString to String 
        {
            "{name}.{ptr} = {get()}";
        }
        override function get to a
        {
            result.get();
        }
        override function set from (x is a) to () 
        {
            result.set(x);
        }
        override function hashCode to Integer 
        {
            result.hashCode();
        }
        override function equals from (obj is Object) to Boolean
        {
            super.equals(obj) or obj.equals(result)
        }
    }
}


class Connection {
    const sourceNode is MNode;
    const sourcePath is String;
    const targetNode is MNode;
    const targetPath is String;
    override function toString to String {
        "{sourceNode.name} {sourcePath} => {targetNode.name} {targetPath}"
    }
}

abstract class MNode {
    public const dynamicsWorld is DynamicsWorld = the DynamicsWorld;
    const connectionsFromThis is java.util.Map of (String, Connection[]) =
        new java.util.HashMap of (String, Connection[]);
    const connectionsToThis is java.util.Map of (String, Connection[]) =
        new java.util.HashMap of (String, Connection[]);
    const attrs is java.util.Map of (String, MAttr) =
        new java.util.HashMap of (String, MAttr);
    const name is String;
    const parent is MNode;
    function getFullName to String {
        "{if (parent == null) then "" else parent.getFullName()}|{name}";
    }

    function getPointer 
        from (path is String, target is Object) 
        to Ref of ?
    {
        null
    }

    function resolveInput from (m is MaModel, p is String) to ConstRef of ? {
        println("{name} can't resolve: {p}");
        null;
    }

    function addConnectionTo from (c is Connection) to () 
    {
        const field = parsePath(c.targetPath).path[0] as Field;
        const conns = connectionsToThis.get(field.name);
        connectionsToThis.put(field.name, [c, conns])
    }

    function addConnectionFrom from (c is Connection) to () 
    {
        const field = parsePath(c.sourcePath).path[0] as Field;
        const conns = connectionsFromThis.get(field.name);
        connectionsFromThis.put(field.name, [c, conns])
    }

    function addAttr from (cmd is Command) to () 
    {
        const shortName = cmd.getString("sn");
        const longName = cmd.getString("ln");
        const t = cmd.getString("at");
        const parent = cmd.getString("p");
        const attr = MAttr {
            shortName: shortName;
            longName: longName;
            type: t;
            parent: attrs.get(parent);
        }
        attrs.put(attr.shortName, attr);
        attrs.put(attr.longName, attr);
    }

    function setAttr from (cmd is Command) to () 
    {
        const attr = attrs.get(cmd.getAttr());
        if (attr <> null) {
            const t = attr.type;
            const value = 
                if (t == "bool") {
                    cmd.getBoolean();
                } else if (t == "float") {
                    cmd.getFloat();
                } else if (t == "float2") {
                    cmd.getVec2();
                } else if (t == "float3") {
                    cmd.getVec3();
                } else if (t == "int") {
                    cmd.getInt()
                } else if (t == "long") {
                    cmd.getInt()
                } else if (t == "fltMatrix" or t == "matrix") {
                    cmd.getMatrix();
                } else null;
            //println("setAttr {attr.shortName} {attr.type} = {value}");
            if (attr.parent <> null) {
                const suffix = attr.shortName.substring(attr.parent.shortName.length()).toLowerCase();
                if (attr.parent.type == "float3") {
                    var v = attr.parent.value as Tuple3;
                    var n = value as Number;
                    if (suffix == "x") {
                        v = tuple(n, v.y, v.z);
                    } else if (suffix == "y") {
                        v = tuple(v.x, n, v.z);
                    } else if (suffix == "z") {
                        v = tuple(v.x, v.y, n);
                    }
                    attr.parent.value = v;
                }
            }
            attr.value = value;
        }
    }
}

public class MParticle is MSpatial {
    public var rad is Number = 1.0;
    public var lfm is Integer; // life span mode
    public var lfr is Number; // life span random
    public var eiw is Boolean = true; // emission to world
    public var ifc is Vec3; // input force
    override function setAttr from (cmd is Command) to () {
        const n = cmd.getAttr();
        if (n == "rad") {
            rad = cmd.getFloat();
        } else if (n == "lfm") {
            lfm = cmd.getInt();
        } else if (n == "lfr") {
            lfr = cmd.getFloat();
        } else if (n == "eiw") {
            eiw = cmd.getBoolean();
        } else if (n == "ifc") {
            ifc = cmd.getVec3();
        } else super.setAttr(cmd);
    }
    
    override public function toNode from (m is MaModel) to Node 
    {
        var r is ParticleSystem;
        m.spatialMap.put(this, r);
        const p = m.toParentNode(parent as MSpatial);
        insert r into p.content;
        return r;
    }
}

public class MPointEmitter is MNode {
    public var emt is Integer; // emitter type
    public var rat is Number = 100; // rate
    public var spd is Number; // speed
    public var d is Vec3 = Vec3.X_AXIS; // direction
    public var pcr is Number; // particle color x
    public var pcg is Number; // particle color y
    public var pcb is Number; // particle color z
    public var spr is Number; // spread
    override function setAttr from (cmd is Command) to () {
        const n = cmd.getAttr();
        if (n == "emt") {
            emt = cmd.getInt();
        } else if (n == "rat") {
            rat = cmd.getInt();
        } else if (n == "spr") {
            spr = cmd.getInt();
        } else if (n == "spd") {
            rat = cmd.getInt();
        } else if (n == "d") {
            d = cmd.getVec3();
        } else if (n == "pc") {
            const pc = cmd.getVec3();
            pcr = pc.x;
            pcg = pc.y;
            pcb = pc.z;
        } else if (n == "pcr") {
            pcr = cmd.getFloat();
        } else if (n == "pcg") {
            pcg = cmd.getFloat();
        } else if (n == "pcb") {
            pcb = cmd.getFloat();
        } else super.setAttr(cmd);
    }
}

class MSceneConfig is MNode {
    var min is Number;
    var max is Number;
    public var model is MaModel;
    override function setAttr from (cmd is Command) to () {
        const n = cmd.getAttr();
        if (n == "b") {
            const script = cmd.getString();
            const parser = MaParser {};
            for (c in parser.parseString(script)) {
                min = c.getFloat("min");
                max = c.getFloat("max");
                model.startFrame = min-1;
                model.endFrame = max-1;
            }
        } else super.setAttr(cmd);
    }
}

class MChoice is MNode {
}

abstract class MSpatial is MNode {
    public var visible is Boolean = true;
    abstract function toNode from (m is MaModel) to Node;
    override function setAttr from (cmd is Command) to () {
        const n = cmd.getAttr();
        if (n == "v") {
            visible = cmd.getBoolean();
        }
        else super.setAttr(cmd);
    }

    override function resolveInput from (m is MaModel, p is String) to ConstRef of ? 
    {
        const ptr = getPointer(p, m.toNode(this));
        if (ptr <> null) then ptr else super.resolveInput(m, p);
    }

    override function getPointer 
        from (path is String, target is Object) 
        to Ref of ?
    {
        if (path == "v") {
            const tn = target as Node;
            AbstractRef of Number {
                override public function set from (n is Number) to () {
                    tn.visible = n <> 0.0;
                }
                override public function get to Number {
                    if tn.visible then 1.0 else 0.0
                }
            }
        } else super.getPointer(path, target);
    }
}

class MPairBlend is MUtilityOfTuple3 {
    public var it1 is Tuple3;
    public var it2 is Tuple3;
    public var ir1 is Tuple3;
    public var ir2 is Tuple3;

    public var txm is Number;
    public var tym is Number;
    public var tzm is Number;

    public var rm is Integer = 0;
    public var ri is Integer = 0;

    public var w is Number = 1.0;
    public var ro is Integer = 0;

    override function setAttr from (cmd is Command) to () {
        println(cmd);
        const n = cmd.getAttr();
        if (n == "w") {
            w = cmd.getFloat();
        } else if (n == "it1") {
            it1 = cmd.getTuple3();
        } else if (n == "it2") {
            it2 = cmd.getTuple3();
        } if (n == "ir1") {
            ir1 = cmd.getTuple3() * (180.0 / Math.PI as Number);
        } else if (n == "ir2") {
            ir2 = cmd.getTuple3() * (180.0 / Math.PI as Number);
        } else if (n == "ro") {
            ro = cmd.getInt();
        } else if (n == "rm") {
            rm = cmd.getInt();
        } else if (n == "ri") {
            ri = cmd.getInt();
        } else if (n == "txm") {
            txm = cmd.getInt();
        } else if (n == "tym") {
            tym = cmd.getInt();
        } else if (n == "tzm") {
            tzm = cmd.getInt();
        } else if (n == "tx") {
            const tx = cmd.getPoint3();
            txm = tx.x;
            tym = tx.y;
            tzm = tx.z;
        } else super.setAttr(cmd);
    }

    override function resolveInput from (m is MaModel, p is String) to ConstRef of ? 
    {
        if (p.startsWith("it1")) {
            const t = m.resolveInput(this, "it1", it1);
            if (p == "it1x") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().x;
                    }
                }
            } else if (p == "it1y") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().y;
                    }
                }
            } else if (p == "it1z") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().z;
                    }
                }
            } else null
        } else if (p.startsWith("it2")) {
            const t = m.resolveInput(this, "it2", it2);
            if (p == "it2x") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().x;
                    }
                }
            } else if (p == "it2y") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().y;
                    }
                }
            } else if (p == "it2z") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().z;
                    }
                }
            } else null
        } 
        else if (p.startsWith("ir1")) {
            const t = m.resolveInput(this, "ir1", ir1);
            if (p == "ir1x") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().x;
                    }
                }
            } else if (p == "ir1y") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().y;
                    }
                }
            } else if (p == "ir1z") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().z;
                    }
                }
            } else null
        } else if (p.startsWith("ir2")) {
            const t = m.resolveInput(this, "ir2", ir2);
            if (p == "ir2x") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().x;
                    }
                }
            } else if (p == "ir2y") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().y;
                    }
                }
            } else if (p == "ir2z") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().z;
                    }
                }
            } else null
        } else null;
        
    }

    override function toLink from (m is MaModel) to (Link of ?)[] {
        if (true) {
            return [];
        }
        const name = this.name;
        const f1 = getOutput(m, "ot");
        const f2 = getOutput(m, "or");
        [Link of Tuple3 {
            input: AbstractConstRef of Tuple3 { 
                override function toString to String {
                    "{name}.ot {f1.get()}"
                }
                override function get to Tuple3 { f1.get() } 
            }
            output: foreach (conn in connectionsFromThis.get("ot")) {
                const ptr = m.resolveTargetPointer(conn);
                ptr as Ref of Tuple3;
            }
        },
        Link of Tuple3 {
            input: AbstractConstRef of Tuple3 { 
                override function toString to String {
                    "{name}.or {f2.get()}"
                }
                override function get to Tuple3 { f2.get() } 
            }
            output: foreach (conn in connectionsFromThis.get("or")) {
                const ptr = m.resolveTargetPointer(conn);
                ptr as Ref of Tuple3;
            }
        }]
    }

    override function getOutput from (m is MaModel, attr is String) to ConstRef of Tuple3
    {
        if (attr == "ot") {
            const input1 = m.resolveInput(this, "it1", it1) as ConstRef of Tuple3;
            const input2 = m.resolveInput(this, "it2", it2) as ConstRef of Tuple3;
            const w1 = new Tuple3(if txm == 0 then 0.0 else if txm == 1 then 0.0 else this.w,
                                  if tym == 0 then 0.0 else if tym == 1 then 0.0 else this.w,
                                  if tzm == 0 then 0.0 else if tzm == 1 then 0.0 else this.w);
            const w2 = Tuple3.<<1>>-w1;
            AbstractConstRef of Tuple3 {
                override function get to Tuple3 {
                    const t1 is Tuple3 = input1.get();
                    const t2 is Tuple3 = input2.get();
                    //println("multiply {input1} {input2} {t1} {t2}");
                    t1 * w1 + t2 * w2;
                }
            }
        } else if (attr == "or") {
            const input1 = m.resolveInput(this, "ir1", ir1) as ConstRef of Tuple3;
            const input2 = m.resolveInput(this, "ir2", ir2) as ConstRef of Tuple3;
            const euler is Boolean = ri == 0;
            const w = if (rm == 0) then 0.0 else if rm == 1 then 1.0 else this.w;
            AbstractConstRef of Tuple3 {
                override function get to Tuple3 {
                    const t1 is Tuple3 = input1.get();
                    const t2 is Tuple3 = input2.get();
                    const r = 
                        if (not euler) {
                            qrotate(t1.x, t1.y, t1.z, ro).slerp(qrotate(t2.x, t2.y, t2.z, ro), w).toAngles();
                        } else {
                            t1*(1.0-w)+t2*w;
                        }
                    if (DEBUG_LINKS) {
                        println("{name}: ir1={t1}, ir2={t2}, w={w} => {r}");
                    }
                    r;
                }
            }
        } else null;
    }
}

abstract class MUtility is MNode
{
    public function toLink from (m is MaModel) to (Link of ?)[] {
        null
    }
}

abstract class MUtilityOfNumber is MUtility {
    abstract function getOutput from (m is MaModel, attr is String) to ConstRef of Number;
}

abstract class MUtilityOfTuple3 is MUtility {
    abstract function getOutput from (m is MaModel, attr is String) to ConstRef of Tuple3;
}

public class Link of a 
{
    public const input is ConstRef of a;
    public const output is (Ref of a)[];
    public function apply from () to () 
    {
        if (DEBUG_LINKS) println("applying input {input}");
        for (o in output) {
            if (DEBUG_LINKS) println("applying {input} to {o}");
            o.set(input.get());
        }
    }
}

class MUnitConversion is MUtilityOfTuple3 {

    var cf is Number;
    var i is Tuple3;

    override function setAttr from (cmd is Command) to () {
        const n = cmd.getAttr();
        if (n == "cf") {
            cf = cmd.getFloat();
        } else if (n == "i") {
            i = cmd.getTuple3();
        } else super.setAttr(cmd);
    }

    override function toLink from (m is MaModel) to (Link of ?)[] {
        null; //@TODO
    }

    override function getOutput from (m is MaModel, attr is String) to ConstRef of Tuple3
    {
        null; //@TODO
    }
}

class MPlusMinusAverage is MUtilityOfTuple3 {

    var op is Integer = 1;

    override function toLink from (m is MaModel) to (Link of ?)[] {
        const f = getOutput(m, "o3");
        const name = this.name;
        Link of Tuple3 {
            input: AbstractConstRef of Tuple3 { 
                override function toString to String {
                    "{name}.op {f.get()}"
                }
                override function get to Tuple3 { f.get() } 
            }
            output: foreach (conn in connectionsFromThis.get("o3")) {
                const ptr = m.resolveTargetPointer(conn);
                println("{conn} ==> {ptr}");
                ptr as Ref of Tuple3;
            }
        }
    }

    override function getOutput from (m is MaModel, attr is String) to ConstRef of Tuple3
    {
        //const conns1 = connectionsToThis.get("i1");
        //const conns2 = connectionsToThis.get("i2");
        const conns3 = connectionsToThis.get("i3");
        println("conns3={conns3}");
        if (attr == "o1") {
            if (op == 0) {
                // select first
                null
            } else if (op == 1) {
                // sum
                null
            } else if (op == 2) {
                // subtract
                null
            } else if (op == 3) {
                // avg
                null
            } else null
        } else if (attr == "o2") {
            if (op == 0) {
                // select first
                null
            } else if (op == 1) {
                // sum
                null
            } else if (op == 2) {
                // subtract
                null
            } else if (op == 3) {
                // avg
                null
            } else null
        } else if (attr == "o3") {
            const funs = 
                foreach (c in conns3) 
                {
                    const g = c.sourceNode.resolveInput(m, c.sourcePath);
                    g as ConstRef of Tuple3;
                }
            if (op == 0) {
                // select first
                null
            } else if (op == 1) {
                // sum
                AbstractConstRef of Tuple3 {
                    override function get to Tuple3 {
                        var x = 0.0;
                        var y = 0.0;
                        var z = 0.0;
                        for (f in funs) { const t = f.get(); x += t.x; y += t.y; z += t.z }
                        tuple(x, y, z);
                    }
                }
            } else if (op == 2) {
                // subtract
                AbstractConstRef of Tuple3 {
                    override function get to Tuple3 {
                        const t0 = funs[0].get();
                        var x = t0.x;
                        var y = t0.y;
                        var z = t0.z;
                        for (f in funs[1..]) { 
                            const t = f.get(); x -= t.x; y -= t.y; z -= t.z; 
                        }
                        tuple(x, y, z);
                    }
                }
            } else if (op == 3) {
                // avg
                AbstractConstRef of Tuple3 {
                    override function get to Tuple3 {
                        var x = 0.0;
                        var y = 0.0;
                        var z = 0.0;
                        for (f in funs) { 
                            const t = f.get(); 
                            x += t.x; 
                            y += t.y; 
                            z += t.z; 
                        }
                        x /= funs.size();
                        y /= funs.size();
                        z /= funs.size();
                        tuple(x, y, z);
                    }
                }
            } else null
        } else null
    }

    override function setAttr from (cmd is Command) to () {
        const n = cmd.getAttr();
        if (n == "op") {
            op = cmd.getInt();
        } else super.setAttr(cmd);
    }
}

class MMultiplyDivide is MUtilityOfTuple3
{
    var i1 is Tuple3;
    var i2 is Tuple3;
    var op is Integer = 1;

    override function getPointer from (path is String, _ is Object) to Ref of ?
    {
        null;
    }


    override function toLink from (m is MaModel) to (Link of ?)[]
    {
        const f = getOutput(m, "o");
        const name = this.name;
        Link of Tuple3 {
            input: AbstractConstRef of Tuple3 { 
                override function toString to String {
                    "{name}.o3 {f.get()}"
                }
                override function get to Tuple3 { f.get() } 
            }
            output: 
            [foreach (conn in connectionsFromThis.get("ox")) 
             {
                 const ptr = m.resolveTargetPointer(conn) as Ref of Number;
                 makeRefX(ptr)
             },
             foreach (conn in connectionsFromThis.get("oy")) 
             {
                 const ptr = m.resolveTargetPointer(conn) as Ref of Number;
                 makeRefY(ptr)
             },
             foreach (conn in connectionsFromThis.get("oz")) 
             {
                 const ptr = m.resolveTargetPointer(conn) as Ref of Number;
                 makeRefZ(ptr)
             },
             foreach (conn in connectionsFromThis.get("o")) 
             {
                const ptr = m.resolveTargetPointer(conn);
                println("{conn} ==> {ptr}");
                ptr as Ref of Tuple3;
            }]
        }
    }

    override function resolveInput from (m is MaModel, p is String) to ConstRef of ? 
    {
        if (p.startsWith("i1")) {
            const t = m.resolveInput(this, "i1", i1);
            if (p == "i1x") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().x;
                    }
                }
            } else if (p == "i1y") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().y;
                    }
                }
            } else if (p == "i1z") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().z;
                    }
                }
            } else null
        } else if (p.startsWith("i2")) {
            const t = m.resolveInput(this, "i2", i2);
            if (p == "i2x") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().x;
                    }
                }
            } else if (p == "i2y") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().y;
                    }
                }
            } else if (p == "i2z") {
                AbstractConstRef of Number {
                    override function get to Number {
                        t.get().z;
                    }
                }
            } else null
        } else null;
    }

    override function getOutput from (m is MaModel, attr is String) to ConstRef of Tuple3
    {
        if (attr == "o") {
            const input1 = m.resolveInput(this, "i1", i1) as ConstRef of Tuple3;
            const input2 = m.resolveInput(this, "i2", i2) as ConstRef of Tuple3;
            if (op == 0) {
                // select first
                input1
            } else if (op == 1) {
                // multiply
                AbstractConstRef of Tuple3 {
                    override function get to Tuple3 {
                        const t1 is Tuple3 = input1.get();
                        const t2 is Tuple3 = input2.get();
                        //println("multiply {input1} {input2} {t1} {t2}");
                        tuple(t1.x*t2.x, 
                              t1.y*t2.y,
                              t1.z*t2.z);
                    }
                }
            } else if (op == 2) {
                // divide
                AbstractConstRef of Tuple3 {
                    override function get to Tuple3 {
                        const t1 is Tuple3 = input1.get();
                        const t2 is Tuple3 = input2.get();
                        tuple(t1.x/t2.x, 
                              t1.y/t2.y,
                              t1.z/t2.z);
                    }
                }
            } else if (op == 3) {
                // pow
                AbstractConstRef of Tuple3 {
                    override function get to Tuple3 {
                        const t1 is Tuple3 = input1.get();
                        const t2 is Tuple3 = input2.get();
                        tuple(Math.pow(t1.x,t2.x), 
                              Math.pow(t1.y,t2.y),
                              Math.pow(t1.z,t2.z));
                    }
                }
            } else null
        } else null
    }

    override function setAttr from (cmd is Command) to () 
    {
        super.setAttr(cmd);
        const n = cmd.getAttr();
        if (n == "i1") {
            i1 = cmd.getVec3();
        } else if (n == "i2") {
            i2 = cmd.getVec3();
        } else if (n == "op") {
            op = cmd.getInt();
        }
    }
}

class MClamp is MUtilityOfTuple3 {

    var mn is Tuple3;
    var mx is Tuple3;
    var ip is Tuple3;

    override function getPointer from (path is String, _ is Object) to Ref of ?
    {
        null
    }

    override function toLink from (m is MaModel) to (Link of ?)[]
    {
        const name = this.name;
        Link of Tuple3 {
            input: getOutput(m, "op");
            output: 
            [foreach (conn in connectionsFromThis.get("opr")) 
             {
                 const ptr = m.resolveTargetPointer(conn) as Ref of Number;
                 makeRefX(ptr)
             },
             foreach (conn in connectionsFromThis.get("opg")) 
             {
                 const ptr = m.resolveTargetPointer(conn) as Ref of Number;
                 makeRefY(ptr)
             },
             foreach (conn in connectionsFromThis.get("opb")) 
             {
                 const ptr = m.resolveTargetPointer(conn) as Ref of Number;
                 makeRefZ(ptr)
             },
             foreach (conn in connectionsFromThis.get("op")) 
             {
                 m.resolveTargetPointer(conn) as Ref of Tuple3;
             }]
        }
    }

    override function getOutput from (m is MaModel, attr is String) to ConstRef of Tuple3
    {
        if (attr == "op") {
            const mnp = m.resolveInput(this, "mn", mn);
            const mxp = m.resolveInput(this, "mx", mx);
            const ipp = m.resolveInput(this, "ip", ip);
            AbstractConstRef of Tuple3 {
                override function get to Tuple3 {
                    const minv = mnp.get();
                    const maxv = mxp.get();
                    const iv = ipp.get();
                    println("clamp {minv} {maxv} {iv}");
                    tuple(Math.min(maxv.x, Math.max(minv.x, iv.x)),
                          Math.min(maxv.y, Math.max(minv.y, iv.y)),
                          Math.min(maxv.z, Math.max(minv.z, iv.z)));
                }
            }
        } else null
    }

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "mn") {
            mn = cmd.getVec3();
        } else if (n == "mx") {
            mx = cmd.getVec3();
        } else if (n == "ip") {
            ip = cmd.getVec3();
        } else super.setAttr(cmd);
    }
}

class MReverse is MUtilityOfTuple3 {

    var i is Tuple3;

    override function toLink from (m is MaModel) to (Link of ?)[]
    {
        const name = this.name;
        Link of Tuple3 {
            input: getOutput(m, "o");
            output: 
            [foreach (conn in connectionsFromThis.get("ox")) 
             {
                 const ptr = m.resolveTargetPointer(conn) as Ref of Number;
                 makeRefX(ptr)
             },
             foreach (conn in connectionsFromThis.get("oy")) 
             {
                 const ptr = m.resolveTargetPointer(conn) as Ref of Number;
                 makeRefY(ptr)
             },
             foreach (conn in connectionsFromThis.get("oz")) 
             {
                 const ptr = m.resolveTargetPointer(conn) as Ref of Number;
                 makeRefZ(ptr)
             },
             foreach (conn in connectionsFromThis.get("o")) 
             {
                 m.resolveTargetPointer(conn) as Ref of Tuple3;
             }]
        }
    }

    override function getOutput from (m is MaModel, attr is String) to ConstRef of Tuple3
    {
        if (attr == "o") {
            const ip = m.resolveInput(this, "i", i);
            //println("ip={ip}");
            AbstractConstRef of Tuple3 {
                override function get to Tuple3 {
                    const iv = ip.get();
                    //println("reverse {iv}");
                    tuple(1.0-iv.x, 1.0-iv.y, 1.0-iv.z);
                }
            }
        } else null
    }

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "i") {
            i = cmd.getVec3();
        } else super.setAttr(cmd);
    }
}


class MAddDoubleLinear is MUtilityOfNumber
{
    var i1 is Number;
    var i2 is Number;

    override function getOutput from (m is MaModel, attr is String) to ConstRef of Number
    {

        if (attr == "o") {
            const input1 = m.resolveInput(this, "i1", i1);
            const input2 = m.resolveInput(this, "i2", i2);
            AbstractConstRef of Number {
                override function get to Number {
                    input1.get() + input2.get();
                }
            }
        } else null
    }

    override function setAttr from (cmd is Command) to () {
        const n = cmd.getAttr();
        if (n == "i1") {
            i1 = cmd.getFloat();
        } else if (n == "i2") {
            i2 = cmd.getFloat();
        } else super.setAttr(cmd);
    }
}

class MTemporal is MNode {
}

class MTransform is MSpatial {

    var t is Vec3;
    var r is Vec3;
    var s is Vec3 = Vec3.<<1>>;
    var rp is Vec3;
    var rpt is Vec3;
    var sp is Vec3;
    var spt is Vec3;
    var tmrp is Vec3;
    var ro is Integer;
    
    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "t") {
            t = cmd.getVec3();
        } else if (n == "r") {
            r = cmd.getVec3();
        } else if (n == "s") {
            s = cmd.getVec3();
        } else if (n == "rp") {
            rp = cmd.getVec3();
        } else if (n == "rpt") {
            rpt = cmd.getVec3();
        } else if (n == "sp") {
            sp = cmd.getVec3();
        } else if (n == "spt") {
            spt = cmd.getVec3();
        } else if (n == "tmrp") {
            tmrp = cmd.getVec3();
        } else if (n == "ro") {
            ro = cmd.getInt();
        } else super.setAttr(cmd);
    }

    override public function getPointer
        from (ptr is String, target is Object) 
        to Ref of ?
    {
        println("get pointer {name} attr={ptr} target={target}");

        const n = target as MaTransform;

        if (ptr == "t") {
            return AbstractRef of Tuple3 {
                override function toString to String {
                    "{n.id}.t = {n.t}";
                }
                override public function get to Tuple3 {
                    tuple(n.tx, n.ty, n.tz);
                }
                override public function set from (t is Tuple3) to () {
                    n.tx = t.x; n.ty = t.y; n.tz = t.z;
                }
            }
        }

        if (ptr == "s") {
            return AbstractRef of Tuple3 {
                override function toString to String {
                    "{n.id}.s = {n.s}";
                }
                override public function get to Tuple3 {
                    tuple(n.sx, n.sy, n.sz);
                }
                override public function set from (t is Tuple3) to () {
                    n.sx = t.x; n.sy = t.y; n.sz = t.z;
                }
            }
        }

        if (ptr == "r") {
            return AbstractRef of Tuple3 {
                override function toString to String {
                    "{n.id}.r = {n.r}";
                }
                override public function get to Tuple3 {
                    tuple(n.rx, n.ry, n.rz);
                }
                override public function set from (t is Tuple3) to () {
                    n.rx = t.x; n.ry = t.y; n.rz = t.z;
                }
            }
        }

        const rptr is Pointer of (MaTransform, Number) =
        if ptr == "tx" 
        then &n.tx 
        else if ptr == "ty"
        then &n.ty 
        else if ptr == "tz"
        then &n.tz 

        else if ptr == "sx" 
        then &n.sx 
        else if ptr == "sy"
        then &n.sy 
        else if ptr == "sz"
        then &n.sz 

        else if ptr == "rx" 
        then &n.rx 
        else if ptr == "ry"
        then &n.ry 
        else if ptr == "rz"
        then &n.rz 

        else if ptr == "rpx" 
        then &n.rpx 
        else if ptr == "rpy"
        then &n.rpy 
        else if ptr == "rpz"
        then &n.rpz 

        else if ptr == "spx" 
        then &n.spx 
        else if ptr == "spy"
        then &n.spy 
        else if ptr == "spz"
        then &n.spz 

        else if ptr == "rptx" 
        then &n.rptx 
        else if ptr == "rpty"
        then &n.rpty 
        else if ptr == "rptz"
        then &n.rptz 

        else if ptr == "sptx" 
        then &n.sptx 
        else if ptr == "spty"
        then &n.spty 
        else if ptr == "sptz"
        then &n.sptz 

        else if ptr == "tmrpx" 
        then &n.tmrpx 
        else if ptr == "tmrpy"
        then &n.tmrpy 
        else if ptr == "tmprz"
        then &n.tmrpz 
        else null;
        if (rptr == null) then super.getPointer(ptr, target) as Ref of Number else makeMemberRef(n.id, ptr, rptr);
    }


    override function toNode from (m is MaModel) to Node 
    {
        const tn = MaTransform {

            visible: visible;

            id: name

            tx: t.x;
            ty: t.y;
            tz: t.z;

            sx: s.x;
            sy: s.y;
            sz: s.z;

            rx: r.x;
            ry: r.y;
            rz: r.z;

            ro: ro;

            rpx: rp.x;
            rpy: rp.y;
            rpz: rp.z;

            spx: sp.x;
            spy: sp.y;
            spz: sp.z;

            rptx: rpt.x;
            rpty: rpt.y;
            rptz: rpt.z;

            sptx: spt.x;
            spty: spt.y;
            sptz: spt.z;

            tmrpx: tmrp.x;
            tmrpy: tmrp.y;
            tmrpz: tmrp.z;
        }
        m.spatialMap.put(this, tn);
        const p = m.toParentNode(parent as MSpatial);
        insert tn into p.content;
        p.updateParent();
        return tn;
    }
}

class MCamera is MSpatial 
{
    var ortho is Boolean = false;
    var hfa is Number = 2.4;
    var vfa is Number = 3.6;
    var fcp is Number = 1000;
    var ncp is Number = .1;
    var fl is Number = 35.0;
    var ow is Number = 10.0;
    var lsr is Number = 1.0;
    var ff is Number = 1.0;

    override function setAttr from (cmd is Command) to () 
    {
        const attr = cmd.getAttr();
        if (attr == "o") {
            ortho = cmd.getBoolean();
        } else if (attr == "cap") {
            const v = cmd.getVec3();
            vfa = v.x;
            hfa = v.y;
        } else if (attr == "hfa") {
            hfa = cmd.getFloat();
        } else if (attr == "vfa") {
            vfa = cmd.getFloat()
        } else if (attr == "fcp") {
            fcp = cmd.getFloat()
        } else if (attr == "ncp") {
            ncp = cmd.getFloat()
        } else if (attr == "ow") {
            ow = cmd.getFloat()
        } else if (attr == "fl") {
            fl = cmd.getFloat()
        } else if (attr == "lsr") {
            lsr = cmd.getFloat()
        } else if (attr == "ff") {
            ff = cmd.getFloat();
        } else super.setAttr(cmd);
    }

    override function toNode from (m is MaModel) to Node 
    {
        const n is Camera = 
            if (ortho) {
                const ow = this.ow;
                OrthographicCamera {
                    far: fcp; 
                    near: ncp;
                    id: name
                    override var viewHeight = bind ow / aspectRatio;
                }
            } else {
                if (ff == 1) {
                    const horizontalAngle = Math.toDegrees(2.0*Math.atan(25.4 * hfa*lsr / 2.0 / fl));
                    PerspectiveCamera {
                        id: name;
                        near: ncp;
                        far: fcp;
                        override var widthAngle = horizontalAngle;
                        override var heightAngle = bind PerspectiveCamera.widthAngleToHeightAngle(widthAngle, aspectRatio);
                    }
                } else {
                    const verticalAngle = Math.toDegrees(2.0*Math.atan(25.4 * vfa / 2.0 / fl));
                    PerspectiveCamera {
                        id: name;
                        near: ncp;
                        far: fcp;
                        heightAngle: verticalAngle;
                    }
                }
            }
        //println("camera {name} => {n}");
        m.spatialMap.put(this, n);
        const p = m.toParentNode(parent as MSpatial);
        insert n into p.content;
        return n;
    }
}

class MGroupParts is MNode {
}

class MTweak is MNode {
}

abstract class MMeshDeformer is MNode {
    protected function getGroupParts to MGroupParts {
        for (c in connectionsToThis.get("ip")) {
            const path = parsePath(c.targetPath).path;
            if (path[1] is Index) {
                const i = path[1] as Index;
                if (i.index == 0) {
                    if (path[2] is Field) {
                        const f = path[2] as Field;
                        if (f.name == "ig") {
                            if (c.sourceNode is MGroupParts) {
                                return c.sourceNode as MGroupParts;
                            }
                        }
                    }
                }
            }
        }
        return null;
    }

    protected function getTweak from (gp is MGroupParts) to MTweak {
        for (c in gp.connectionsToThis.get("ig")) {
            if (c.sourceNode is MTweak) {
                return c.sourceNode as MTweak;
            }
        }
        return null;
    }
    
    protected var sourceMesh is MMesh;
    protected var targetMesh is MMesh;

    protected function resolveSourceMesh from () to MMesh {
        var gp = getGroupParts();
        println("group parts {name} => {gp.name}");
        const tweak = getTweak(gp);
        if (tweak <> null) {
            println("tweak {name} => {tweak}");
            for (c in tweak.connectionsToThis.get("ip")) {
                if (c.sourceNode instanceof MGroupParts and c.targetPath == "ip[0].ig") {
                    gp = c.sourceNode as MGroupParts;
                    break;
                }            
            }
        }
        println("gp {name} => {gp.name}");
        var done = false;
        while (not done) {
            const conns = gp.connectionsToThis.get("ig");
            if (conns.size() == 0) break;
            for (c in conns) {
                println(c);
                const sp = parsePath(c.sourcePath).path;
                const name = (sp[0] as Field).name;
                if (c.sourceNode is MMesh and c.sourcePath == "w") {
                    sourceMesh = c.sourceNode as MMesh;
                    done = true;
                    break;
                } else if (c.sourceNode is MGroupParts and c.sourcePath == "og") {
                    gp = c.sourceNode as MGroupParts;
                    break;
                } else if (c.sourceNode is MMeshDeformer and name == "og") {
                    const d = c.sourceNode as MMeshDeformer;
                    sourceMesh = d.resolveSourceMesh();
                    println("source mesh => {sourceMesh} from {c}");
                    sourceIsStatic = false;
                    done = true;
                    break;
                } else {
                    done = true;
                }
            }
        }
        return sourceMesh;
    }

    protected function resolveTargetMesh from () to MMesh {
        for (c in connectionsFromThis.get("og")) {
            println("resolve target mesh {c}");
            if (c.targetNode is MMesh and c.targetPath == "i") {
                targetMesh = c.targetNode as MMesh;
                break;
            } else if (c.targetNode is MMeshDeformer) {
                const next = (c.targetNode as MMeshDeformer);
                next.sourceIsStatic = false;
                targetMesh = next.resolveSourceMesh();
                break;
            } else {
            }
        }
        return targetMesh;
    }

    protected var sourceIsStatic is Boolean = true;

    function resolveMeshes {
        resolveSourceMesh();
        resolveTargetMesh();
    }
}

class WeightList {
    var w is Number[];
}

class MSkinCluster is MMeshDeformer {
    var wl is WeightList[];
    var pm is Mat4[];
    var gm is Mat4;
    public override function setAttr from (cmd is Command) to ()
    {
        const attr = cmd.getAttr();
        if (attr == "wl") {
            const path = cmd.getPath();
            const values = cmd.getFloatArray();
            const i = (path.path[1] as Index).index;
            while (this.wl.size() <= i) {
                insert WeightList {} into this.wl;
            }
            var wl = this.wl[i];
            const wi = path.path[3];
            if (wi instanceof Range) {
                const r = wi as Range;
                for (_ in [wl.w.size()..r.startIndex]) {
                    insert 0.0 into wl.w;
                }
                wl.w[r.startIndex..r.endIndex] = values;
            } else if (wi instanceof Index) {
                const j = (wi as Index).index;
                for (_ in [wl.w.size()..j]) {
                    insert 0.0 into wl.w;
                }
                wl.w[j] = values[0];
            }
            //println("weight list {i} = {wl.w}");
        } else if (attr == "pm") {
            const path = cmd.getPath();
            const i = (path.path[1] as Index).index;
            while (pm.size() < i) {
                insert Mat4.<<1>> into pm;
            }
            pm[i..i] = cmd.getMatrix();
        } else if (attr == "gm") {
            gm = cmd.getMatrix();
        } else super.setAttr(cmd);
    }

    public function toSkinCluster from (m is MaModel) to SkinCluster {
        resolveMeshes();
        println("pm={this.pm.size()}");
        println("gm={gm}");
        println("Source Mesh={sourceMesh.name}");
        println("Target Mesh={targetMesh.name}");
        if (false) {
            for (x in wl) {
                for (y in x.w) {
                    println("wl[{indexof x}].w[{indexof y}] = {y}");
                }
            }
        }
        const resolvedSource = m.toNode(sourceMesh) as MeshNode;
        const resolvedTarget = m.toNode(targetMesh) as MeshNode;
        println("Source Mesh={resolvedSource}");
        println("Target Mesh={resolvedTarget}");
        const jointMap = new java.util.TreeMap of (Integer, Node);
        //var bps is Mat4[];
        for (j in connectionsToThis.get("ma")) {
            println(j);
            if (j.sourcePath == "wm" and j.sourceNode instanceof MJoint) {
                const mj = j.sourceNode as MJoint;
                //insert mj.bps.inverse() into bps;
                const jn = m.toNode(mj);
                const p = parsePath(j.targetPath).path;
                const i = (p[1] as Index).index;
                jointMap.put(i, jn);
            }
        }
        const jointIndexMap = new java.util.TreeMap of (Integer, Integer);
        var joints is Node[];
        var pm is Mat4[];
        for (ent in jointMap.entrySet()) {
            const k = ent.getKey();
            const v = ent.getValue();
            insert v into joints;
            jointIndexMap.put(k, indexof ent); 
            insert this.pm[k] into pm;
        }
        const vertIndices = sourceMesh.vertIndices;
        var weights is Number[];
        for (vertIndex in vertIndices) {
            const list = wl[vertIndex];
            //println("vert={vertIndex} wl={foreach (x in list.w) "{x},"}");
            if (list.w.size() > 0) {
                var influences is Number[];
                for (w in list.w) {
                    if (w <> 0) {
                        const v = jointIndexMap.get(indexof w);
                        if (v <> null) {
                            insert v into influences;
                            insert w into influences;
                        }
                    }
                }
                if (influences.size() > 0) {
                    const vert = indexof vertIndex;
                    insert vert into weights;
                    insert influences.size() / 2 into weights;
                    insert influences into weights;
                }
            }
        }
        if (resolvedSource.mesh.getVertexBuffer() == null) {
            println("No resolvedSource buffer: {resolvedSource.mesh}");
        }
        if (resolvedTarget.mesh.getVertexBuffer() == null) {
            println("No resolvedTarget buffer: {resolvedTarget.mesh}");
        }
        var sourceVertices = resolvedSource.mesh.getVertexBuffer();
        var sourceNormals = resolvedSource.mesh.getNormalBuffer();
        if (sourceIsStatic) {
            sourceVertices = BufferUtils.clone(sourceVertices);
            sourceNormals = BufferUtils.clone(sourceNormals);
        }
        resolvedTarget.mesh = resolvedSource.mesh;
        println("resolved source shader: {resolvedSource.shader}");
        println("resolved target shader: {resolvedTarget.shader}");
        if (resolvedTarget.shader == null or resolvedTarget.shader == m.getDefaultShader()) {
            println("using source shader");
            resolvedTarget.shader = resolvedSource.shader; // hack?
            if (resolvedTarget.shader == null) {
                resolvedTarget.shader = m.getDefaultShader();
            }
        } 
        if (sourceIsStatic) {
            resolvedSource.visible = false;
            resolvedTarget.visible = true;
        }
        println("CREATING SKIN CLUSTER with {joints.size()} joints {weights.size()} weights");
        const result = SkinCluster {
            indexBuffer: resolvedTarget.mesh.getIndexBuffer();
            sourceVertices: sourceVertices;
            sourceNormals: sourceNormals;
            targetVertices: resolvedTarget.mesh.getVertexBuffer();
            targetNormals: resolvedTarget.mesh.getNormalBuffer();
            joints: joints;          
            weights: weights;
            bindPreMatrices: pm;
            geomMatrix: gm;
            target: resolvedTarget.mesh;
        }
        insert result into resolvedTarget.deformers;
        return result;
    }
}

class MBlendShape is MMeshDeformer {

    public override function setAttr from (cmd is Command) to ()
    {
        super.setAttr(cmd);
    }

    public function resolveTargetPointer 
        from (m is MaModel, 
              c is Connection) 
        to Ref of Number 
    {
        const p = parsePath(c.targetPath).path;
        var resolved = m.toBlendShape(this);
        if (p[0] is Field) {
            const f = p[0] as Field;
            if (f.name == "w") {
                if (p[1] is Index) {
                    const p1 = p[1] as Index;
                    const i = p1.index;
                    return AbstractRef of Number {
                        override function toString to String {
                            "{name}.w[{i}]";
                        }
                        public override function get to Number {
                            resolved.weights[i];
                        }
                        public override function set from (n is Number) to () {
                            //println("setting {this} => {n}");
                            resolved.weights[i] = n;
                        }
                    }
                }
            }
        }
        return null;
    }

    public function toBlendShape from (m is MaModel) to BlendShape 
    {
        resolveMeshes();
        const blendMeshes = 
            foreach (c in connectionsToThis.get("it")) 
            {
                if (c.sourceNode is MMesh) {
                    c.sourceNode as MMesh;
                } else null;
            };
        const resolvedSource = m.toNode(sourceMesh) as MeshNode;
        const resolvedTarget = m.toNode(targetMesh) as MeshNode;
        const resolvedBlendShapes = foreach (mesh in blendMeshes) {
            m.toNode(mesh) as MeshNode;
        }
        const weights = foreach (x in resolvedBlendShapes) 1.0;
        var sourceVertices = BufferUtils.clone(resolvedSource.mesh.getVertexBuffer());
        var sourceNormals = BufferUtils.clone(resolvedSource.mesh.getNormalBuffer());
        resolvedTarget.mesh = resolvedSource.mesh;
        resolvedTarget.shader = resolvedBlendShapes[0].shader; // hack?
        resolvedSource.visible = false;
        var result = BlendShape {
            sourceVertices: sourceVertices;
            sourceNormals: sourceNormals;
            targetVertices: resolvedTarget.mesh.getVertexBuffer();
            targetNormals: resolvedTarget.mesh.getNormalBuffer();
            weights: weights;
            blendTargetVertices: foreach (n in resolvedBlendShapes) n.mesh.getVertexBuffer();
            blendTargetNormals: foreach (n in resolvedBlendShapes) n.mesh.getNormalBuffer();
            target: resolvedTarget.mesh;
        }
        insert result into resolvedTarget.deformers;
        return result;
    }
}

class MIKHandle is MSpatial {
    public var pv is Vec3;
    public var rol is Number;
    public var tw is Number;
    override function setAttr from (cmd is Command) to () 
    {
        const attr = cmd.getAttr();
        if (attr == "pv") {
            pv = cmd.getVec3();
        } else if (attr == "rol") {
            rol = cmd.getFloat();
        } else if (attr == "tw") {
            tw = cmd.getFloat();
        } else super.setAttr(cmd);
    }
    override function toNode from (m is MaModel) to Node
    {
        /*
        var hsj is Joint;
        var hee is Node;
        var poleVectorConstraint is Node;
        for (c in connectionsToThis.get("hsj")) {
            hsj = m.toNode(c.targetNode as MSpatial) as Joint;
        }
        for (c in connectionsToThis.get("hee")) {
            hee = m.toNode(c.targetNode as MSpatial) as Node;
        }
        for (c in connectionsToThis.get("pvx")) {
            poleVectorConstraint = m.toNode(c.targetNode as MSpatial) as Node;
        }
        IKHandleNode {
            pv: pv;
            joint: hsj;
            effector: hee;
            roll: rol;
            twist: tw;
        }
        */
        return null;
    }
}

class MPoleVectorConstraint is MPointConstraint {
}

class MIKEffector is MNode {
}

class MJoint is MTransform {

    var jox is Number;
    var joy is Number;
    var joz is Number;
    var jo is Integer;
    var ssc is Boolean;

    var bps is Mat4;

    override function setAttr from (cmd is Command) to () 
    {
        const attr = cmd.getAttr();
        if (attr == "jox") {
            jox = cmd.getFloat();
        } else if (attr == "joy") {
            joy = cmd.getFloat();
        } else if (attr == "joz") {
            joz = cmd.getFloat();
        } else if (attr == "bps") {
            bps = cmd.getMatrix();
        } else if (attr == "jo") {
            const jo = cmd.getFloat3();
            jox = jo.x;
            joy = jo.y;
            joz = jo.z;
        } else if (attr == "jot") {
            const jot = cmd.getString();
            for (s in RotateOrders) {
                if (s == jot) {
                    jo = indexof s;
                    println("jot={jot} jo={jo}");
                    break;
                }
            }
        } else if (attr == "ssc") {
            ssc = cmd.getBoolean();
        } else super.setAttr(cmd);
    }

    override function toNode from (m is MaModel) to Node 
    {
        const tn = Joint {
            visible: visible;
            id: name

            ssc: ssc;
            jox: jox;
            joy: joy;
            joz: joz;
            jo: jo;

            tx: t.x;
            ty: t.y;
            tz: t.z;

            sx: s.x;
            sy: s.y;
            sz: s.z;

            rx: r.x;
            ry: r.y;
            rz: r.z;

            ro: ro;

            rpx: rp.x;
            rpy: rp.y;
            rpz: rp.z;

            spx: sp.x;
            spy: sp.y;
            spz: sp.z;

            rptx: rpt.x;
            rpty: rpt.y;
            rptz: rpt.z;

            sptx: spt.x;
            spty: spt.y;
            sptz: spt.z;

            tmrpx: tmrp.x;
            tmrpy: tmrp.y;
            tmrpz: tmrp.z;
        }
        m.spatialMap.put(this, tn);
        const p = m.toParentNode(parent as MSpatial);
        insert tn into p.content;
        return tn;
    }
}

class MCharacter is MNode {

    var aal is java.util.Map of (String, String);
    var am is java.util.Map of (String, String);

    function resolveTargetPointer from (m is MaModel, toThis is Connection) to Ref of ?
    {
        // toThis connects to one of my inputs; forward to the corresponding connection 
        //println("{name} trying to resolve {toThis} in {connectionsFromThis}");
        const path = parsePath(toThis.targetPath).path[0] as Field;
        for (conn in connectionsFromThis.get(path.name)) {
            if (conn.sourcePath == toThis.targetPath) {
                const ptr = m.resolveTargetPointer(conn);
                //println("conn={conn} ptr={ptr}");
                if (ptr <> null) return ptr;
                println("failed to resolve target {toThis.targetPath} using {conn}");
            }
        }
        println("failed to resolve target {toThis.targetPath}");
        return null;
    }

    function resolveSourcePointer from (m is MaModel, toThis is Connection) to Ref of ?
    {
        // toThis connects to one of my inputs; forward to the corresponding connection 
        const path = parsePath(toThis.targetPath).path[0] as Field;
        for (conn in connectionsToThis.get(path.name)) {
            const ptr = m.resolveSourcePointer(conn);
            if (ptr <> null) return ptr;
            println("failed to resolve source {toThis.targetPath} using {conn}");
        }
        println("failed to resolve source {toThis.targetPath}");
        return null;
    }

    function applyAlias from (m is MaModel) to () 
    {
        if (true) return;
        for (ent in aal.entrySet()) {
            const k = ent.getKey();
            const v = ent.getValue();
            var animCurve = m.findNode(k);
            if (animCurve == null) {
                animCurve = m.findNode("{name}_{k}");
            }
            println("{name} applying alias {k} {v} => {animCurve}");
            animCurve.connectionsFromThis.put("o", 
                                              Connection { 
                                                  sourceNode: animCurve;
                                                  sourcePath: "o";
                                                  targetNode: this;
                                                  targetPath: v;
                                              });
        }
    }

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "aal") {
            println("cmd={cmd}");
            aal = cmd.getAttributeAlias();
        } else if (n == "am") {
            am = cmd.getCharacterMapping();
        } else super.setAttr(cmd);
    }
}

class UVData {
    public var uvSet is Integer;
    public var uvIndices is Integer[]; 
    override function toString to String {
        "UVData: {uvSet}, uvIndices: {uvIndices}";
    }
}

class PolyfaceData {
    public var faceEdges is Integer[];
    public var holes is Integer[];
    public var mu is UVData[];

    function getUV from (uvIndex is Integer) to Integer[] {
        foreach (m in mu) {
            m.uvIndices[uvIndex];
        }
    }

    override function toString to String {
        "faceEdges: {faceEdges}, holes: {holes}, mu: {mu}";
    }
}

// attribute structure paths
class PathNode {
}

class Index is PathNode {
    const index is Integer;
    override function toString to String {
        "[{index}]"
    }
    function asRange to Range {
        Range {
            startIndex: index;
            endIndex: index;
        }
    }
}

class Field is PathNode {
    const name is String;
    override function toString to String {
        ".{name}"
    }
}

class Range is PathNode {
    const startIndex is Integer;
    const endIndex is Integer;
    override function toString to String {
        "[{startIndex}:{endIndex}]"
    }
}

class Path {
    const path is PathNode[];
    override function toString to String {
        "{path}"
    }
}

function parsePath from (path is String) to Path
{
    const izer = new java.util.StringTokenizer(path, ".[]:", true);
    var result is PathNode[];
    while (izer.hasMoreTokens()) {
        const elem = izer.nextToken();
        var pnode is PathNode;
        if (elem == "[") {
            const i1 = izer.nextToken();
            const t = izer.nextToken();
            var i2 is String = null;
            if (t == ":") { 
                i2 = izer.nextToken();
                pnode = Range {
                    startIndex: Integer.parseInt(i1);
                    endIndex: Integer.parseInt(i2);
                }
            } else if (i1 == "*") {
                continue;
            } else {
                pnode = Index {
                    index: Integer.parseInt(i1);
                }
            }
        } else if (elem == ".") {
            pnode = Field {
                name: izer.nextToken()
            }
        } else {
            pnode = Field {
                name: elem;
            }
        }
        insert pnode into result;
    }
    return Path {path: result};
}

class UVSet {
    public const uvIndex is Integer;
    public var uvs is Number[];
    override function toString to String {
        "uvSet: {uvIndex}, uvs: {uvs}";
    }
}

class ComponentList {
    const faceStart is Integer;
    const faceEnd is Integer;
}

class FaceVertex is java.lang.Comparable of FaceVertex {
    const face is Integer;
    const vertex is Integer;
    override function compareTo from (other is FaceVertex) to Integer {
        var cmp = face - other.face;
        if (cmp == 0) {
            cmp = vertex - other.vertex;
        }
        return cmp
    }
}

class MMesh is MSpatial 
{
    public var parents is MNode[];
    var components is ComponentList[];
    var verts is Number[];
    var pointTweaks is Number[];
    var normals is Number[];
    var edges is Integer[];
    var polyfaces is PolyfaceData[];
    var uvSets is UVSet[];
    var faceNormals is Vec3[];

    function faceEdgeIndex from (i is Integer) to Integer 
    {
        if (i < 0) then -i-1 else i;
    }
    
    function edgeStart from (faceEdge is Integer) to Integer {
        faceEdgeToEdge(faceEdge, true);
    }

    function edgeEnd from (faceEdge is Integer) to Integer {
        faceEdgeToEdge(faceEdge, false);
    }

    function faceEdgeToEdge(faceEdge is Integer, 
                            fromStart is Boolean) to Integer 
    {
        const bwd = faceEdge < 0;
        if (bwd) {
            const i = faceEdgeIndex(faceEdge); 
            edges[i*3+(if fromStart then 1 else 0)];
        } else {
            edges[faceEdge*3+(if fromStart then 0 else 1)];
        }
    }
    
    function isSmooth from (faceEdge is Integer) to Boolean 
    {
        const i = faceEdgeIndex(faceEdge);
        edges[i*3+2] <> 0
    }

    function uv from (uvSet is Integer, uvIndex is Integer) to Point2
    {
        const uvs = uvSets[u | u.uvIndex == uvSet][0].uvs;
        const i0 = uvIndex * 2;
        const i1 = i0+1;
        point(uvs[i0], uvs[i1]);
    }
    
    function vertex from (i is Integer) to Point3 
    {
        const i0 = 3*i;
        const i1 = i0+1;
        const i2 = i1+1;
        point(verts[i0] + pointTweaks[i0],
              verts[i1] + pointTweaks[i1],
              verts[i2] + pointTweaks[i2])
    }

    function normal from (i is Integer) to Vec3 
    {
        const i0 = 3*i;
        const i1 = i0+1;
        const i2 = i1+1;
        const x = normals[i0];
        const y = normals[i1];
        const z = normals[i2];
        const imag = 1.0/Math.sqrt(x*x+y*y+z*z);
        vector(imag * x, imag * y, imag * z);
    }

    const vertToNormal = new java.util.TreeMap of (Integer, Vec3);
    function buildMesh
    {
	for (v in normals) {
	    if (v > 1e10) { // bogus normals
		normals = [];
		break;
	    }
	}
	if (normals <> []) {
	   return;
	}
	for (polyface in polyfaces) {
	    var norm = Vec3.<<0>>;
	    const faceEdges = polyface.faceEdges;
	    for (faceEdge in faceEdges) {
		const i = indexof faceEdge;
		const edge = edgeStart(faceEdge);
		const next = edgeEnd(faceEdge);
		const prev = edgeStart(faceEdges[(i + faceEdges.size()-1) mod faceEdges.size()]);
		const v0 = vertex(edge);
		const v1 = vertex(next);
		const v2 = vertex(prev);
		norm += (v1 - v0).cross(v2 - v0);
	    }
	    norm = norm.normalize();
	    insert norm into faceNormals;
	}
	const vertexToFace1 = new java.util.TreeMap of (Integer, Integer[]);
	for (f in polyfaces) {
	    const faceIndex = indexof f;
	    for (faceEdge in f.faceEdges) {
		if (isSmooth(faceEdge)) {
                //                    println("isSmooth: {faceIndex}, {indexof faceEdge} => {faceEdge}");
                    const i = faceEdgeIndex(faceEdge);
		    const e0 = edgeStart(faceEdge);
		    const e1 = edgeEnd(faceEdge);
                    var m = vertexToFace1.get(e0);
                    if (m == null) m = [];
		    vertexToFace1.put(e0, [m, i, faceIndex]);
                    m = vertexToFace1.get(e1);
                    if (m == null) m = [];
		    vertexToFace1.put(e1, [m, i, faceIndex]);
		}
	    }
	}
        // println("vertexToFace1 => {vertexToFace1.size()}");
	const stack = new java.util.Stack of Integer;
	const vertexToFace2 = new java.util.TreeMap of (Integer, Integer[]);
	while (vertexToFace1.size() > 0) {
	    const ent = vertexToFace1.pollFirstEntry();
	    const vert1 = ent.getKey();
	    var indices1 = ent.getValue();
	    var faces is Integer[];
            vertexToFace1.remove(vert1);
            const faceEdge = indices1[0];
            const faceIndex = indices1[1];
            stack.push(faceIndex);
            stack.push(faceEdge);
            var j = 2;
            while (not stack.isEmpty()) {
                const faceEdge1 = stack.pop();
                const faceIndex1 = stack.pop();
                insert faceIndex1 into faces;
                while (j < indices1.size()) {
                    const faceEdge2 = indices1[j];
                    const faceIndex2 = indices1[j+1];
                    if (faceEdge1 == faceEdge2 or faceIndex1 == faceIndex2) {
                        //println("found match {faceEdge2}, {faceIndex2}");
                        stack.push(faceIndex2);
                        stack.push(faceEdge2);
                        delete indices1[j..j+1];
                    } else {
                        j += 2;
                    }
                }
            }
            vertexToFace2.put(vert1, faces);
	}
	for (f in polyfaces) {
	    const faceIndex = indexof f;
	    for (faceEdge in f.faceEdges) {
                for (vert in [edgeStart(faceEdge), edgeEnd(faceEdge)]) {
                    const faces = vertexToFace2.get(vert);
                    if (faces == []) {
                    } else {
                        var norm = Vec3.<<0>>;
                        for (j in faces) {
                            const faceNorm = faceNormals[j];
                            norm += faceNorm;
                        }
                        //println("face normal: {faceIndex}, {faceEdge}, {edge} faces=({faces}) => {norm}");
                        vertToNormal.put(vert, norm.normalize());
                    }
                }
            }
	}
    }


    function getMesh to AbstractMesh[]
    {
        if (components == []) {
            components = [ComponentList 
                          {
                              faceStart: 0;
                              faceEnd: polyfaces.size();
                          }];
        }
        // for now we merge these

/*
        foreach (comp in components) {
            this.ib.clear();
            this.vb.clear();
            this.nb.clear();
            this.uvbs = [];
*/
        println("get mesh {name}");
        println("verts: {verts.size()}");
        println("normals: {normals.size()}");
        println("vertToNormal: {vertToNormal.size()}");
        println("faceNormals: {faceNormals.size()}");
        for (comp in components) {
            const startIndex = comp.faceStart;
            const endIndex = comp.faceEnd;
            for (i in [startIndex..endIndex]) {
                const f = polyfaces[i];
                if (f == null) {
                   continue;
                }
                const edge0 = edgeStart(f.faceEdges[0]);
                const uv0 = f.getUV(0);
                var edge1 = edgeStart(f.faceEdges[1]);
                var uv1 = f.getUV(1);
                for (j in [2..<f.faceEdges.size()]) {
                    insertVertex(edge0, i, uv0);
                    insertVertex(edge1, i, uv1);
                    const edge2 = edgeStart(f.faceEdges[j]);
                    const uv2 = f.getUV(j);
                    insertVertex(edge2, i, uv2);
                    edge1 = edge2;
                    uv1 = uv2;
                }
            }
        }
	const ib = this.ib.getBuffer();
	const vb = this.vb.getBuffer();
	const nb = this.nb.getBuffer();
	if (uvbs <> []) {
	    const tanb = BufferUtils.createVector3Buffer(ib.limit());
	    const binb = BufferUtils.createVector3Buffer(ib.limit());
	    const uvbb = foreach (uvb in uvbs) uvb.getBuffer();
	    var additional is MeshBuffer.VertexAttributeBuffer[];
	    if (ImportUtils.addTangentBinormalStreams(ib, vb, uvbb[0], nb, tanb, binb)) {
		additional =
		    [MeshBuffer.VertexAttributeBuffer {id: "TANGENT", coordsPerVertex: 3, buffer: tanb },
		     MeshBuffer.VertexAttributeBuffer {id: "BINORMAL", coordsPerVertex: 3, buffer: binb }];
	    }
	    MeshBuffer {
		indexBuffer: ib;
		vertexBuffer: MeshBuffer.VertexAttributeBuffer {id: "POSITION", coordsPerVertex: 3, buffer: vb };
		normalBuffer: MeshBuffer.VertexAttributeBuffer {id: "NORMAL", coordsPerVertex: 3, buffer: nb };
		textureBuffers: [foreach (uvb in uvbb) MeshBuffer.VertexAttributeBuffer {id: "TEXCOORD{indexof uvb}", coordsPerVertex: 2, buffer: uvb },
				 additional];
	    }.toMesh();
	} else MeshBuffer {
		indexBuffer: ib;
		vertexBuffer: MeshBuffer.VertexAttributeBuffer {id: "POSITION", coordsPerVertex: 3, buffer: vb };
		normalBuffer: MeshBuffer.VertexAttributeBuffer {id: "NORMAL", coordsPerVertex: 3, buffer: nb };
	    }.toMesh();
	//}
    }

    const ib = new IntBufferBuilder();
    const vb = new FloatBufferBuilder();
    const nb = new FloatBufferBuilder();
    var uvbs is FloatBufferBuilder[];
    var normalIndex = 0;
    const faceVertexToNormal is java.util.Map of (FaceVertex, Vec3) = 
        new java.util.TreeMap of (FaceVertex, Vec3);

    function getFaceVertexNormal 
        from (face is Integer, vertex is Integer) 
        to Vec3
        {  
            const key = FaceVertex { face: face, vertex: vertex };
            var v = faceVertexToNormal.get(key);
            if ((v as Object) == null) {
                v = this.normal(normalIndex++);
                faceVertexToNormal.put(key, v);
            }
            return v;
        }

    public var vertIndices is Integer[];

    function insertVertex
        from (vert is Integer, face is Integer, uvIndex is Integer[]) 
        to ()
    {
        const v = this.vertex(vert);
        insert vert into vertIndices;
        const n = 
            if (this.normals <> []) 
                then (if this.normals.size() <> this.verts.size() then getFaceVertexNormal(face, vert) else this.normal(vert))
                else {
                    if ({
                        const y = vertToNormal.containsKey(vert);
                        //println("face: {face}");
                        //println("vertToNormal contains {face}, {vert} => {y}");
                        y
                    }) 
                    then vertToNormal.get(vert) 
                    else faceNormals[face];
                }
        ib.add(ib.getBufferSize());
        vb.add(v.x, v.y, v.z);
        const nn = n.normalize();
        nb.add(nn.x, nn.y, nn.z);
        while (uvIndex.size() > uvbs.size()) {
            insert new FloatBufferBuilder into uvbs;
        }
        for (i in uvIndex) {
            const uvSet = indexof i;
            const uv = this.uv(uvSet, i);
            uvbs[uvSet].add(uv.x, uv.y);
        }
    }

    override function setAttr from (cmd is Command) to () 
    {
        super.setAttr(cmd);
        const n = cmd.getAttr();
        if (n == "vt") {
            const path = cmd.getPath();
            const values = cmd.getFlatFloat3Array();
            if (path.path[1] instanceof Range) {
                const r = path.path[1] as Range;
                verts[r.startIndex*3..r.endIndex*3] = values;
            } else if (path.path[1] instanceof Index) {
                const r = path.path[1] as Index;
                verts[r.index*3..r.index*3] = values;
            } else {
                verts = values;
            }
        } else if (n == "pt") {
            const path = cmd.getPath();
            const values = cmd.getFlatFloat3Array();
            if (path.path[1] instanceof Range) {
                const r = path.path[1] as Range;
                pointTweaks[r.startIndex*3..r.endIndex*3] = values;
            } else if (path.path[1] instanceof Index) {
                const r = path.path[1] as Index;
                pointTweaks[r.index*3..r.index*3] = values;
            } else {
                pointTweaks = values;
            }
        } else if (n == "n") {
            const path = cmd.getPath();
            const values = cmd.getFlatFloat3Array();
            if (path.path[1] instanceof Range) {
                const r = path.path[1] as Range;
                normals[r.startIndex*3..r.endIndex*3] = values;
            } else if (path.path[1] instanceof Index) {
                const r = path.path[1] as Index;
                normals[r.index*3..r.index*3] = values;
            } else {
                normals = values;
            }
        } else if (n == "ed") {
            const path = cmd.getPath();
            const values = cmd.getFlatInt3Array();
            if (path.path[1] instanceof Range) {
                const r = path.path[1] as Range;
                edges[r.startIndex*3..r.endIndex*3] = values;
            } else if (path.path[1] instanceof Index) {
                const r = path.path[1] as Index;
                edges[r.index*3..r.index*3] = values;
            } else {
                edges = values;
            }
        } else if (n == "fc") {
            const path = cmd.getPath();
            const values = cmd.getPolyfaceData();
            if (path.path[1] instanceof Range) {
                const r = path.path[1] as Range;
                polyfaces[r.startIndex..r.endIndex] = values;
            } else if (path.path[1] instanceof Index) {
                const r = path.path[1] as Index;
                polyfaces[r.index..r.index] = values;
            } else {
                polyfaces = values;
            }
        } else if (n == "iog") {
            const path = cmd.getPath();
            const index = path.path[1] as Index;
            const field = path.path[2] as Field;
            if (field.name == "og") {
                const ogIndex = path.path[3] as Index;
                const gcl = path.path[4] as Field;
                if (gcl.name == "gcl") {
                    const componentList = cmd.getStringArray();
                    for (comp in componentList) {
                        const compPath = parsePath(comp);
                        if (compPath.path[0] is Field) {
                            const f = compPath.path[0] as Field;
                            if (f.name == "f") {
                                const compList is ComponentList = 
                                    if (compPath.path[1] instanceof Range) {
                                        const fr = compPath.path[1] as Range;
                                        ComponentList {
                                            faceStart: fr.startIndex;
                                            faceEnd: fr.endIndex;
                                        } 
                                    } else {
                                        const fi = compPath.path[1] as Index;
                                        ComponentList {
                                            faceStart: fi.index;
                                            faceEnd: fi.index;
                                        } 
                                    };
                                insert compList into components;
                            }
                        }
                    }
                }
            }
        } else if (n == "uvst") {
            // uv sets
            const path = cmd.getPath();
            const index = path.path[1] as Index;
            const field = path.path[2] as Field;
            if (field.name == "uvsp") {
                var startIndex is Integer;
                var endIndex is Integer;
                if (path.path[3] is Range) {
                    const range = path.path[3] as Range;
                    startIndex = range.startIndex;
                    endIndex = range.endIndex;
                } else {
                    const ind = path.path[3] as Index;
                    startIndex = endIndex = ind.index;
                }
                const uvIndex = index.index;
                const values = cmd.getFlatFloat2Array();
                if (uvSets[uvIndex] == null) {
                    insert UVSet {
                        uvIndex: uvIndex;
                        uvs: values;
                    } into uvSets;
                } else {
                    uvSets[uvIndex].uvs[startIndex*2..endIndex*2] = values;
                }
            }
        }
    }

    override function toNode from (m is MaModel) to Node 
    {
        buildMesh();
        var id = "";
        var r0 is Node;
        for (mesh in getMesh()) {
            const shaderConn = connectionsFromThis.get("iog");
            const mshaderNode = 
                if (shaderConn <> null) {
                    //println("shaderConn={shaderConn}");
                    //println("shaderConn={shaderConn[0].targetNode}");
                    //println("shaderConn={shaderConn[0].targetNode.connectionsToThis}");
                    // println("shader = {shaderConn[0].targetNode.connectionsToThis.get("ss")}");
                    const shaderNode = shaderConn[0].targetNode.connectionsToThis.get("ss");
                    if shaderNode == null then null else shaderNode[0].sourceNode as MAbstractShader;
                } else null;
            const shader = m.toShader(mshaderNode);
            println("model {m}, shaderNode [{mshaderNode}] for {this.getFullName()} ={mshaderNode.getFullName()} for {name} => {shader}");
            for (i in [0..<shader.uvMap.size()]) {
                const unit = shader.uvMap[i];
                if (unit == -2) { // tangent
                    shader.uvMap[i] = mesh.textureCoordinates.size()-2;
                } else if (unit == -1) {// binormal 
                    shader.uvMap[i] = mesh.textureCoordinates.size()-1;
                }
            }
            for (pn in [parent, parents]) {
                const r = MeshNode {
                    visible: visible;
                    id: "{name}{id}";
                    mesh: mesh;
                    shader: shader;
                }
                m.spatialMap.put(this, r);
                const p = m.toParentNode(pn as MSpatial);
                id = "#{indexof mesh +1}";
                insert r into p.content;
                r0 = r;
            }
        }
        const conns = connectionsFromThis.get("msg");
        println("RIGID BODY conns=>{conns}");
        for (conn in conns) {
            println("RIGID BODY conn=>{conn}");
            if (conn.targetNode is MLegacyRigidBody) {
                const rigidBody = conn.targetNode as MLegacyRigidBody;
                const chc = rigidBody.connectionsFromThis.get("chc");
                println("RIGID BODY chc=>{chc}");
                var target is Collider;
                var targetNode is MaTransform;
                for (c in chc) {
                    const chc_n = c.targetNode;
                    const chc_o = chc_n.connectionsFromThis.get("o");
                    for (x in chc_o) {
                        println("RIGID BODY x=>{x}");
                        const tn = m.toNode(x.targetNode as MSpatial);
                        println("RIGID BODY tn=>{tn}");
                        if (tn <> null) {
                            targetNode = tn as MaTransform;
                        }
                    }
                }
                target = dynamicsWorld.createCollider(targetNode);
                target.bodyType = if (rigidBody.act) then RigidBodyType.Dynamic else RigidBodyType.Kinematic;
                target.mass = rigidBody.mas;
                const ip = rigidBody.ip; 
                const com = rigidBody.com;
                const iv = rigidBody.iv;
                const isp = rigidBody.isp;
                const ior = rigidBody.ior;
                //targetNode.tx = ip.x;
                //targetNode.ty = ip.y;
                //targetNode.tz = ip.z;
                target.collisionInitialVelocity = iv;
                target.collisionInitialSpin = isp;
                target.collisionInitialOrientation = ior;
                target.collisionInitialPosition = ip;
                target.friction = rigidBody.sf;
                target.restitution = rigidBody.b;
                target.centerOfMass = rigidBody.com;
                targetNode.collider = target;
            }
        }
        return r0;
    }
}

class MLegacyRigidBody is MNode {
    public var act is Boolean = true; // active
    public var mas is Number = 1; // mass
    public var ip is Point3; // initial position
    public var iv is Vec3; // initial velocity
    public var isp is Vec3; // initial spin
    public var ior is Vec3; // initial orientation
    public var sf is Number = .2; // friction
    public var df is Number = .2; // friction
    public var b is Number = .6; // restitution
    public var com is Point3; // center of mass
    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "ip") {
            ip = cmd.getPoint3();
        } else if (n == "iv") {
            iv = cmd.getVec3();
        } else if (n == "isp") {
            isp = cmd.getVec3();
        } else if (n == "ior") {
            ior = cmd.getVec3();
        } else if (n == "sf") {
            sf = cmd.getFloat();
        } else if (n == "b") {
            b = cmd.getFloat();
        } else if (n == "com") {
            com = cmd.getPoint3();
        } else if (n == "mas") {
            mas = cmd.getFloat();
        } else if (n == "act") {
            act = cmd.getBoolean();
        } else super.setAttr(cmd);
    }
}

class MLegacyRigidConstraint is MNode {
    var rb1 is MLegacyRigidBody;
    var rb2 is MLegacyRigidBody;
    var ip is Point3;
    var ino is Vec3;
    var typ is Integer;
    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "ip") {
            ip = cmd.getPoint3();
        } else if (n == "ino") {
            ino = cmd.getVec3();
        } else if (n == "typ") {
            typ = cmd.getInt();
        } else super.setAttr(cmd);
    }
}

abstract class MField is MTransform {
    public function toForceField from (m is MaModel) to ForceField;
    public var mag is Number;
    public var att is Number;
    public var maxDistance is Number = -1;

    override public function getPointer
        from (ptr is String, target is Object) 
        to Ref of ?
    {
        println("get pointer {name} attr={ptr} target={target}");
        const n = target as ForceFieldNode;
        if (ptr == "mag") {
            &n.forceField.magnitude;
        } else if (ptr == "att") {
            &n.forceField.attenuation;
        } else if (ptr == "max") {
            &n.forceField.maxDistance;
        } else super.getPointer(ptr, target);
    }

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "mag") {
            mag = cmd.getFloat();
        } else if (n == "att") {
            att = cmd.getFloat();
        } else if (n == "max") {
            maxDistance = cmd.getFloat();
        } else super.setAttr(cmd);
    }

    override function toNode from (m is MaModel) to Node 
    {
        const tn = ForceFieldNode {

            visible: visible;

            id: name

            tx: t.x;
            ty: t.y;
            tz: t.z;

            sx: s.x;
            sy: s.y;
            sz: s.z;

            rx: r.x;
            ry: r.y;
            rz: r.z;

            ro: ro;

            rpx: rp.x;
            rpy: rp.y;
            rpz: rp.z;

            spx: sp.x;
            spy: sp.y;
            spz: sp.z;

            rptx: rpt.x;
            rpty: rpt.y;
            rptz: rpt.z;

            sptx: spt.x;
            spty: spt.y;
            sptz: spt.z;

            tmrpx: tmrp.x;
            tmrpy: tmrp.y;
            tmrpz: tmrp.z;
        }
        m.spatialMap.put(this, tn);
        const p = m.toParentNode(parent as MSpatial);
        insert tn into p.content;
        m.toForceField(this);
        return tn;
    }
}

class MGravityField is MField {

    public var dy is Number = -1.0;
    override var mag = 9.8;
    public var dx is Number;
    public var dz is Number;

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "d") {
            const d = cmd.getVec3();
            dx = d.x; dy = d.y; dz = d.z;
        } else if (n == "dx") {
            dx = cmd.getFloat();
        } else if (n == "dy") {
            dy = cmd.getFloat();
        } else if (n == "dz") {
            dz = cmd.getFloat();
        } else super.setAttr(cmd);
    }
    override function toForceField from (m is MaModel) to ForceField
    {
        const target = m.toNode(this) as ForceFieldNode;
        const r = GravityField {
            dynamicsWorld: m.dynamicsWorld;
            worldTransform: bind target.toSceneTransform;
            magnitude: mag;
            attenuation: att;
            maxDistance: maxDistance;
            gravity: new Vec3(mag * dx, mag *dy, mag *dz);
        }
        target.forceField = r;
        return r;
    }
}

class MRadialField is MField {
    public var typ is Float;
    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "typ") {
            typ = cmd.getFloat();
        } else super.setAttr(cmd);
    }
    override function toForceField from (m is MaModel) to ForceField
    {
        const target = m.toNode(this) as ForceFieldNode;
        const r = RadialField {
            dynamicsWorld: m.dynamicsWorld;
            worldTransform: bind target.toSceneTransform;
            magnitude: mag;
            attenuation: att;
            maxDistance: maxDistance;
        }
        target.forceField = r;
        return r;
    }
}

class MVortexField is MField {
    public var ax is Vec3;
    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "ax") {
            ax = cmd.getVec3();
        } else super.setAttr(cmd);
    }
    override function toForceField from (m is MaModel) to ForceField
    {
        const target = m.toNode(this) as ForceFieldNode;
        const r = VortexField {
            dynamicsWorld: m.dynamicsWorld;
            worldTransform: bind target.toSceneTransform;
            magnitude: mag;
            attenuation: att;
            maxDistance: maxDistance;
            axis: ax;
        }
        target.forceField = r;
        return r;
    }
}

abstract class MRigidBody is MNode {
    public function toRigidBody from (m is MaModel) to Collider;
}

abstract class MRigidBodyConstraint is MNode {
    public function toRigidBodyConstraint from (m is MaModel) to RigidBodyConstraint;
}

class MBulletRigidBodyConstraintShape is MRigidBodyConstraint {
    public var contyp is Integer;
    public var angmotorvel is Vec3;
    public var linconx is Number;
    public var lincony is Number;
    public var linconz is Number;
    public var angconx is Number;
    public var angcony is Number;
    public var angconz is Number;
    public var lcmin is Vec3;
    public var lcmax is Vec3 = Vec3.MAX_VALUE;
    public var acmin is Vec3;
    public var acmax is Vec3 = Vec3.MAX_VALUE;
    public var linspstiff is Vec3;
    public var linspdamp is Vec3;
    public var angspstiff is Vec3 = Vec3.<<1>> * 39.478;
    public var angspdamp is Vec3 = Vec3.<<1>> * 0.1;
    public var lindamp is Number = 0.1;
    public var linsoft is Number;
    public var linrestit is Number;
    public var angdamp is Number = 0.1;
    public var angsoft is Number;
    public var angrestit is Number;
    public var linmotor is Boolean;
    public var linmotorvel is Vec3;
    public var linmotormaxf is Vec3;
    public var angmotor is Boolean;
    public var angmotormaxf is Vec3;
    public var linlimsoft is Number = 1.0;
    public var linlimbias is Number = 0.3;
    public var linlimrelax is Number = 1.0;
    public var anglimsoft is Number = 1.0;
    public var anglimbias is Number = 0.3;
    public var anglimrelax is Number = 1.0;
    public var linspringx is Boolean;
    public var linspringy is Boolean;
    public var linspringz is Boolean;
    public var angspringx is Boolean;
    public var angspringy is Boolean;
    public var angspringz is Boolean;

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "contyp") {
            contyp = cmd.getInt();
        } else if (n == "angmotorvel") {
            angmotorvel = cmd.getVec3();
        } else if (n == "linconx") {
            linconx = cmd.getFloat();
        } else if (n == "lincony") {
            lincony = cmd.getFloat();
        } else if (n == "linconz") {
            linconz = cmd.getFloat();
        } else if (n == "angconx") {
            angconx = cmd.getFloat();
        } else if (n == "angcony") {
            angcony = cmd.getFloat();
        } else if (n == "angconz") {
            angconz = cmd.getFloat();
        } else if (n == "lcmin") {
            lcmin = cmd.getVec3();
        } else if (n == "lcmax") {
            lcmax = cmd.getVec3();
        } else if (n == "acmin") {
            acmin = cmd.getVec3();
        } else if (n == "acmax") {
            acmax = cmd.getVec3();
        } else if (n == "linspstiff") {
            linspstiff = cmd.getVec3();
        } else if (n == "linspdamp") {
            linspdamp = cmd.getVec3();
        } else if (n == "angspstiff") {
            angspstiff = cmd.getVec3();
        } else if (n == "angspdamp") {
            angspdamp = cmd.getVec3();
        } else if (n == "lindamp") {
            lindamp = cmd.getFloat();
        } else if (n == "linsoft") {
            linsoft = cmd.getFloat();
        } else if (n == "linrestit") {
            linrestit = cmd.getFloat();
        } else if (n == "angdamp") {
            angdamp = cmd.getFloat();
        } else if (n == "angsoft") {
            angsoft = cmd.getFloat();
        } else if (n == "angrestit") {
            angrestit = cmd.getFloat();
        } else if (n == "angrestit") {
            angrestit = cmd.getFloat();
        } else if (n == "linmotor") { linmotor = cmd.getBoolean(); }
        else if (n == "linmotorvel") { linmotorvel = cmd.getVec3(); }
        else if (n == "linmotormaxf") { linmotormaxf = cmd.getVec3(); }
        else if (n == "angmotor") { angmotor = cmd.getBoolean(); }
        else if (n == "angmotorvel") { angmotorvel = cmd.getVec3(); }
        else if (n == "angmotormaxf") { angmotormaxf = cmd.getVec3(); }
        else if (n == "linlimsoft") { linlimsoft = cmd.getFloat(); }
        else if (n == "linlimbias") { linlimbias = cmd.getFloat(); }
        else if (n == "linlimrelax") { linlimrelax = cmd.getFloat(); }
        else if (n == "anglimsoft") { anglimsoft = cmd.getFloat(); }
        else if (n == "anglimbias") { anglimbias = cmd.getFloat(); }
        else if (n == "anglimrelax") { anglimrelax = cmd.getFloat(); }
        else if (n == "linspringx") { linspringx = cmd.getBoolean(); }
        else if (n == "linspringy") { linspringy = cmd.getBoolean(); }
        else if (n == "linspringz") { linspringz = cmd.getBoolean(); }
        else if (n == "angspringx") { angspringx = cmd.getBoolean(); }
        else if (n == "angspringy") { angspringy = cmd.getBoolean(); }
        else if (n == "angspringz") { angspringz = cmd.getBoolean(); }
        else super.setAttr(cmd);
    }
    
    override public function toRigidBodyConstraint from (m is MaModel) to RigidBodyConstraint
    {
        //Constraint type. The valid enum values are: Point(0), Hinge(1), Slider(2), ConeTwist(3), 6DOF(4), Spring Hinge(5), Spring 6DOF(6)
        var bodyA is Node;
        var bodyB is Node;
        var pivotA is Point3;
        var pivotB is Point3;
        for (c in connectionsToThis.get("rba")) {
            bodyA = m.toRigidBody(c.sourceNode as MRigidBody).getTarget();
            const parent = m.toNode(c.sourceNode.parent as MSpatial) as MaTransform;
            pivotA = parent.t;
        }
        for (c in connectionsToThis.get("rbb")) {
            bodyB = m.toRigidBody(c.sourceNode as MRigidBody).getTarget();
            const parent = m.toNode(c.sourceNode.parent as MSpatial) as MaTransform;
            pivotB = parent.t;
        }
        if (bodyA == null) {
            println("{name} can't find bodyA: {connectionsToThis}");
            return null;
        }       
        if (bodyB == null) {
            println("{name} can't find bodyB: {connectionsToThis}");
            return null;
        }       

        const result = 
        if (contyp == 0) {
            PointToPointConstraint {
                node1: bodyA;
                node2: bodyB;
            }
        } else if (contyp == 1) {
            HingeConstraint {
                node1: bodyA;
                node2: bodyB;
                worldSpace: no;
                pivotInA: pivotA;
                pivotInB: pivotB;
                usePivots: yes;
                angularConstraintMin: acmin.z;
                angularConstraintMax: acmax.z;
                angularMotorVelocity: angmotorvel.z;
                angularMotor: angmotor;
                angularMotorMaxForce: angmotormaxf.z;
                angularLimitSoftness: anglimsoft;
                angularLimitBias: anglimbias;
                angularLimitRelaxation: anglimrelax;
            }
        } else {
            null;
        }
        println("RIGID BODY CONSTRAINT {result} between {bodyA}, {bodyB}"); 
        result;
    }
}

class MBulletRigidBodyShape is MRigidBody {

    override public function toRigidBody from (m is MaModel) to Collider
    {
        var mesh is MMesh;
        println(connectionsToThis.get("imesh"));
        for (x in connectionsToThis.get("imesh")) {
            mesh = x.sourceNode as MMesh;
        }
        println("mesh=>{mesh}");
        const meshNode = m.toNode(mesh) as MeshNode;
        println("meshNode=>{meshNode}");
        var targetNode is MaTransform;
        var target is Collider;
        const b = this;
        for (x in b.connectionsToThis.get("inwmat")) {
            const tn = m.toNode(x.sourceNode as MSpatial);
            println("BULLET RIGID BODY tn=>{tn}");
            if (tn <> null) {
                targetNode = tn as MaTransform;
                break;
            }
        }
        if (targetNode <> null) {
            if (targetNode.collider == null) {
                target = dynamicsWorld.createCollider(targetNode);
                if (colshtyp == 1) {
                    target.colliderShape = ColliderShape.Box { extent: ext }
                } else if (colshtyp == 2) {
                    target.colliderShape = ColliderShape.Sphere { radius: rad }
                } else if (colshtyp == 3) {
                    target.colliderShape = ColliderShape.Capsule { radius: rad; length: len }
                } else if (colshtyp == 4) {
                    const t = ColliderShape.ConvexHull {target: meshNode};
                    target.colliderShape = t;
                    println("colliderShape.target 4 => {t}");
                } else if (colshtyp == 5) {
                    const t = ColliderShape.StaticMesh {target: meshNode}
                    target.colliderShape = t;
                    println("colliderShape.target 5 => {t.target}");
                } else if (colshtyp == 6) {
                    target.colliderShape = ColliderShape.StaticPlane { }
                } else if (colshtyp == 7) {
                    target.colliderShape = ColliderShape.Cylinder {radius: rad; length: len }
                }
                println("colliderShape {colshtyp} => {target.colliderShape}");
                target.bodyType = if (b.bdytyp == 0) then RigidBodyType.Static else if (b.bdytyp == 1) then RigidBodyType.Kinematic else RigidBodyType.Dynamic; 
                target.mass = b.ms;
                target.centerOfMass = b.com;
                target.friction = b.fric;
                target.restitution = b.restit;
                target.collisionInitialVelocity = b.iv;
                target.linearDamping = b.lindamp;
                target.angularDamping = b.angdamp;
                println("targetNode=>{targetNode}, parent={targetNode.parent}");
                targetNode.irot += irot;
                targetNode.itrs += itrs;
                if (target.bodyType == RigidBodyType.Dynamic) {
                    target.collisionInitialPosition = targetNode.toSceneTransform.getTranslation();
                    target.collisionInitialOrientation = targetNode.toSceneTransform.getRotation().toAngles();
                }
                targetNode.collider = target;
                target.collisionInitialSpin = b.iav;
            }
        }
        return targetNode.collider;
    }

    var ms is Number = 1.0; // mass
    var com is Point3; // center of mass
    var lindamp is Number = 0.0; // linear damping
    var angdamp is Number = 0.0; // angular damping;
    var fric is Number = 0.5; // friction;
    var restit is Number = 0.5; // restitution
    var initslp is Boolean = false; // initially sleeping
    var notslp is Boolean = false; // never sleeps
    var iv is Vec3 = Vec3.<<0>>; // initial velocity
    var iav is Vec3 = Vec3.<<0>>; // initial angular velocity 
    var i is Vec3 = Vec3.<<0>>; // initial impulse
    var ip is Point3 = Point3.<<0>>; // impulse position
    var ti is Vec3 = Vec3.<<0>>; // torque impulse
    var colshtyp is Integer = 1; // collider shape type: box (ext), sphere (rad), capsule (axis, rad, len), hull, mesh, plane (axis), cylinder (rad, len)
    //imesh is link to mesh
    var bdytyp is Integer = 1; // static(0), kinematic(1), dynamic(2)
    var len is Number;
    var ext is Tuple3;
    var axis is Integer;
    var itrs is Point3;
    var irot is Vec3;
    var rad is Number;
    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "ms") {
        } else if (n == "com") {
            com = cmd.getPoint3();
        } else if (n == "lindamp") {
            lindamp = cmd.getFloat();
        } else if (n == "angdamp") {
            angdamp = cmd.getFloat();
        } else if (n == "fric") {
            fric = cmd.getFloat();
        } else if (n == "restit") {
            restit = cmd.getFloat();
        } else if (n == "initslp") {
            initslp = cmd.getBoolean();
        } else if (n == "notslp") {
            notslp = cmd.getBoolean();
        } else if (n == "iv") {
            iv = cmd.getVec3();
        } else if (n == "iav") {
            iav = cmd.getVec3();
        } else if (n == "i") {
            i = cmd.getVec3();
        } else if (n == "ip") {
            ip = cmd.getPoint3();
        } else if (n == "ti") {
            ti = cmd.getVec3();
        } else if (n == "colshtyp") {
            colshtyp = cmd.getInt();
        } else if (n == "bdytyp") {
            bdytyp = cmd.getInt();
        } else if (n == "len") {
            len = cmd.getFloat();
        } else if (n == "ext") {
            ext = cmd.getTuple3();
        } else if (n == "axis") {
            axis = cmd.getInt();
        } else if (n == "rad") {
            rad = cmd.getFloat();
        } else if (n == "itrs") {
            itrs = cmd.getPoint3();
        } else if (n == "irot") {
            irot = cmd.getVec3();
        } else super.setAttr(cmd);
    }
}

abstract class MAbstractShader is MNode {
    abstract function toShader from (m is MaModel) to Shader;
}

class MCGFXShader is MAbstractShader 
{
    var t is String; // technique
    var s is String; // shader
    var vals is String[];
    var vas is String[];

    override public function getPointer
        from (ptr is String, target is Object) 
        to Ref of ?
    {
        const shader = target as Shader;
        var result = shader.getParameter(ptr);
        //println("result in {name} for {ptr} = {result}");
        return result;
    }

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "val") {
            vals = cmd.getStringArray();
        } else if (n == "vas") {
            vas = cmd.getStringArray();
        } else if (n == "s") {
            s = cmd.getString();
        } else if (n == "t") {
            t = cmd.getString();
        } else super.setAttr(cmd);
    }

    override function toShader from (m is MaModel) to Shader
    {
        const baseURL = new java.net.URL(m.url);
        const shaderURL = new java.net.URL(baseURL, s).toString();
        m.recordResource(shaderURL);
        var shader = m.effectLoader.loadEffect(shaderURL, t);
        shader.id = name;
        m.shaderMap.put(this, shader);
        for (conns in connectionsToThis.values()) {
            for (conn in conns) {
                if (conn.sourceNode instanceof MFile) {
                    const file = conn.sourceNode as MFile;
                    var fname = file.ftn;
                    const slashslash = fname.indexOf("//");
                    if (slashslash > 0) {
                        fname = "..{fname.substring(slashslash+1)}";
                    }
                    const testFile = new java.io.File(fname);
                    const paramName = conn.targetPath;
                    const p = shader.getParameter(paramName) as Shader.Parameter of AbstractTexture;
                    try {
                        const u = 
                            if (testFile.exists()) {
                                testFile.toURI().toString();
                            } else {
                                new java.net.URL(baseURL, fname).toString();
                            }
                        const image = m.imageLoader.loadImage(u);
                        m.recordResource(u);
                        println("u={u}");
                        println("setting {paramName} to {file.ftn} p={p}");
                        p.set(image);
                    } catch (e is java.lang.Exception) {
                        e.printStackTrace();
                    }
                }
            }
        }
        var uvs is Integer[];
        for (i in [0..<vals.size() step 4]) {
            const n = vals[i];
            const t = vals[i+1];
            const sem = vals[i+3];
            if (sem.startsWith("TEXCOORD")) {
                const unit = Integer.parseInt(sem.substring(8));
                for (j in [uvs.size()..unit]) {
                    insert 0 into uvs;
                }
                const name = vas[1+(i-1) / 4];
                if (name.startsWith("uv:map")) {
                    const uvIndex = Integer.parseInt(name.substring(6))-1;
                    uvs[unit] = uvIndex;
                } else if (name.startsWith("binormal:map")) {
                    uvs[unit] = -1;
                } else if (name.startsWith("tangent:map")) {
                    uvs[unit] = -2;
                }
            }
        }
        for (attr in attrs.values() where attr.parent == null) {
            if (attr.value <> null) {
                var name = attr.shortName;
                var value = attr.value;
                //println("setting {name} {attr.type} to {value}");
                try {
                    shader.setParameter(name, value);
                } catch (e is java.lang.Exception) {
                    e.printStackTrace();
                }
            }
        }
        const transparent = attrs.get("transparent");
        if (transparent <> null) {
           if (transparent.value is Boolean) {
               shader.isTransparent = transparent.value as Boolean;
           }
        }
        shader.uvMap = uvs;
        return shader;
    }
}

class CGFXVectorNode is Node {
    public var wv is Tuple3;
    public var wvw is Number;
}

class MCGFXVector is MSpatial {
    
    var wv is Tuple3 = Tuple3.<<0>>;
    var wvw is Number;

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "wv") {
            wv = cmd.getVec3();
        } else if (n == "wvw") {
            wvw = cmd.getFloat();
        } else super.setAttr(cmd);
    }

    override public function getPointer
        from (ptr is String, target is Object) 
        to Ref of ?
    {
        const n = target as CGFXVectorNode;
        if (ptr == "wv") {
            return &n.wv;
        } else if (ptr == "wvw") {
            return &n.wvw;
        } else if (ptr == "m") {
            return &n.transform;
        } else {
            return null
        }
    }

    override function toNode from (m is MaModel) to Node {
        var n is Node;
        m.spatialMap.put(this, null);
        for (conn in connectionsToThis.get("m")) {
            if (conn.sourcePath == "wm") {
                n = (conn.sourceNode as MSpatial).toNode(m);
            }
        }
        const vecNode = CGFXVectorNode {
            id: name;
            wvw: wvw;
            wv: bind n.toSceneTransform.getTranslation();
        }
        m.spatialMap.put(this, vecNode);
        for (conn in connectionsFromThis.get("wv")) {
            if (conn.targetNode instanceof MCGFXShader) {
                var shader = m.toShader(conn.targetNode as MCGFXShader);
                const p = shader.getParameter(conn.targetPath) as Shader.Parameter of Tuple3;
                p.bindTo(&vecNode.wv);
            }
        }
        return vecNode;
    }
    
}

class MLayeredShader is MAbstractShader {
    public var c is Tuple3;
    public var t is Tuple3 = Tuple3.<<1>>;
    public var g is Tuple3;
    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "c") {
            c = cmd.getTuple3();
        } else if (n == "t") {
            t = cmd.getTuple3();
        } else if (n == "g") {
            g = cmd.getTuple3();
        } else super.setAttr(cmd);
    }

    override function toShader from (m is MaModel) to Shader 
    {
        null
    }
}

class MShader is MAbstractShader 
{
    public const type is String;

    var c is Tuple3 = tuple(0.8, 0.8, 0.8);
    var ambc is Tuple3 = Tuple3.<<0>>;
    var ic is Tuple3 = Tuple3.<<0>>;
    var sc is Tuple3 = tuple(.5, .5, .5);
    var dc is Number = 0.8;
    var ec is Number = 0.3;
    var cp is Number = 20.0;
    var it is Tuple3 = Tuple3.<<0>>;

    override public function getPointer
        from (ptr is String, target is Object) 
        to Ref of ?
    {
        const shader = target as Shader;
        if (ptr == "c" or ptr == "cb" or ptr == "cg" or ptr == "cr") {
            const result = shader.getParameter("diffuse") as Shader.Parameter of Tuple4;
            if (ptr == "cb") {
                AbstractRef of Number {
                    override public function get to Number 
                    {
                        result.get().z
                    }
                    override public function set from (b is Number) to () 
                    {
                        const t = result.get();
                        result.set(tuple(t.x, t.y, b, t.w));
                    }
                }
            } else if (ptr == "cg") {
                AbstractRef of Number {
                    override public function get to Number 
                    {
                        result.get().y
                    }
                    override public function set from (g is Number) to () 
                    {
                        const t = result.get();
                        result.set(tuple(t.x, g, t.z, t.w));
                    }
                }
            } else if (ptr == "cr") {
                AbstractRef of Number {
                    override public function get to Number 
                    {
                        result.get().x
                    }
                    override public function set from (r is Number) to () 
                    {
                        const t = result.get();
                        result.set(tuple(r, t.y, t.z, t.w));
                    }
                }
            } else {
                AbstractRef of Tuple3 {
                    override public function get to Tuple3
                    {
                        result.get().xyz();
                    }
                    override public function set from (c is Tuple3) to () 
                    {
                        const t = result.get();
                        result.set(tuple(c.x, c.y, c.z, t.w));
                    }
                }
            }
        } else null
    }

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "c") {
            c = cmd.getVec3();
        } else if (n == "ambc") {
            ambc = cmd.getVec3();
        } else if (n == "sc") {
            sc = cmd.getTuple3();
        } else if (n == "cp") {
            cp = cmd.getFloat();
        } else if (n == "ic") {
            ic = cmd.getVec3();
        } else if (n == "dc") {
            dc = cmd.getFloat();
        } else if (n == "it") {
            it = cmd.getVec3();
        } else super.setAttr(cmd);
    }

    function toColor 
        from (r is Number,
              g is Number,
              b is Number,
              a is Number) 
        to Color 
    {
        Color {
            red: r, green: g, blue: b, opacity: a 
        }
    }

    override function toShader from (m is MaModel) to Shader 
    {
        const alpha = 1.0 - it.x;
        const ambient = toColor(ambc.x, ambc.y, ambc.z, alpha);
        const emissive = toColor(ic.x, ic.y, ic.z, alpha);
        const specular = if (this.type == "lambert") then Color.BLACK else toColor(sc.x, sc.y, sc.z, alpha);
        const shininess = if (this.type == "phong") then cp else if (this.type == "blinn") then 100.0 - 99.0 * Math.sqrt(ec) else 0.0;
        println("toShader {this.type} shininess => {shininess}");
        var image is AbstractTexture;
        var uvMap is Integer[] = [];
        for (conn in connectionsToThis.get("c")) {
            if (conn.sourceNode instanceof MFile) {
                const file = conn.sourceNode as MFile;
                const baseURL = new java.net.URL(m.url);
                var fname = file.ftn;
                const slashslash = fname.indexOf("//");
                if (slashslash > 0) {
                    fname = "..{fname.substring(slashslash+1)}";
                }
                try {
                    const testFile = new java.io.File(fname);
                    const u = 
                        if (testFile.exists()) {
                            testFile.toURI().toString(); 
                        } else {
                            new java.net.URL(baseURL, fname).toString();
                        };
                    println("u={u}");
                    image = m.imageLoader.loadImage(u);
                    uvMap = [0];
                } catch (e is java.lang.Exception) {
                    e.printStackTrace();
                }
                break;
            }
        }
        const diffuse = if image == null then toColor(c.x * dc, c.y * dc, c.z * dc, alpha) else Color.color(dc, dc, dc);
        println("diffuse => {diffuse}");
        println("ambient => {ambient}");
        println("emissive => {emissive}");
        println("specular => {specular}");
        println("shininess => {shininess}");
        const shader = m.effectLoader.loadDefaultShader(image,
                                                        diffuse,
                                                        ambient,
                                                        emissive,
                                                        specular,
                                                        shininess);
        m.shaderMap.put(this, shader);
        shader.id = name;
        shader.uvMap = uvMap;
        return shader;
    }
}

class MShadingEngine is MNode {
    override function setAttr from (cmd is Command) to () 
    {
        super.setAttr(cmd)
    }
}

class MFile is MNode {
    var ftn is String;
    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "ftn") {
            ftn = cmd.getString();
        } else super.setAttr(cmd);
    }
}

class MLight is MSpatial {
    const type is String;
    var cl is Tuple3;
    var li is Number;
    override public function toNode from (m is MaModel) to Node 
    {
        if (this.type == "pointLight") {
            const tn = PointLight {}
            m.spatialMap.put(this, tn);
            const p = m.toParentNode(parent as MSpatial);
            insert tn into p.content;
            return tn;
        }
        return null;
    }
}

class MAnimClip is MNode {
    var sf is Integer = 1;
    var ss is Integer = 1;
    var se is Integer;
    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "ss") {
            ss = cmd.getInt();
        } else if (n == "sf") {
            ss = cmd.getInt();
        } else if (n == "se") {
            se = cmd.getInt();
        } else super.setAttr(cmd);
    }
}

class MClipLibrary is MNode {
}

const FIXED  = 1;
const LINEAR  = 2;
const FLAT    = 3;
const STEPPED = 5;
const SPLINE  = 9;
const CLAMPED = 10;
const PLATEAU = 16;

// http://download.autodesk.com/global/docs/maya2012/en_us/Nodes/animCurve.html
abstract class MAnimCurve of a is MTemporal 
{
    var kix is Number[];
    var kiy is Number[];
    var kox is Number[];
    var koy is Number[];
    var tan is Integer;
    var kit is Integer[];
    var kot is Integer[];

    override function setAttr from (cmd is Command) to () 
    {
        const n = cmd.getAttr();
        if (n == "tan") {
            tan = cmd.getInt();
        } else if (n == "kix") {
            const p = cmd.getPath().path;
            const values = cmd.getFloatArray();
            if (p[1] instanceof Range) {
                const r = p[1] as Range;
                while (kix.size() < r.startIndex) {
                    insert 1.0 into kix;
                }
                kix[r.startIndex..r.endIndex] = values;
            } else if (p[1] instanceof Range) {
                const r = p[1] as Range;
                while (kix.size() < r.startIndex) {
                    insert 1.0 into kix;
                }
                kix[r.startIndex..r.endIndex] = values;
            } else {
                kix = values;
            }
            println("kix={kix}");
        } else if (n == "kiy") {
            const p = cmd.getPath().path;
            const values = cmd.getFloatArray();
            if (p[1] instanceof Range) {
                const r = p[1] as Range;
                while (kiy.size() < r.startIndex) {
                    insert 0.0 into kiy;
                }
                kiy[r.startIndex..r.endIndex] = values;
            } else if (p[1] instanceof Index) {
                const r = p[1] as Index;
                while (kiy.size() < r.index) {
                    insert 0.0 into kiy;
                }
                kiy[r.index..r.index] = values;
            } else {
                kiy = values;
            }
            println("kiy={kiy}");
        } else if (n == "kox") {
            const p = cmd.getPath().path;
            const values = cmd.getFloatArray();
            if (p[1] instanceof Range) {
                const r = p[1] as Range;
                while (kox.size() < r.startIndex) {
                    insert 1.0 into kox;
                }
                kox[r.startIndex..r.endIndex] = values;
            } else if (p[1] instanceof Index) {
                const r = p[1] as Index;
                while (kox.size() < r.index) {
                    insert 1.0 into kox;
                }
                kox[r.index..r.index] = values;
            } else {
                kox = values;
            }
            println("kox={kox}");
        } else if (n == "koy") {
            const p = cmd.getPath().path;
            const values = cmd.getFloatArray();
            if (p[1] instanceof Range) {
                const r = p[1] as Range;
                while (koy.size() < r.startIndex) {
                    insert 0.0 into koy;
                }
                koy[r.startIndex..r.endIndex] = values;
            } else if (p[1] instanceof Index) {
                const r = p[1] as Index;
                while (koy.size() < r.index) {
                    insert 0.0 into koy;
                }
                koy[r.index..r.index] = values;
            } else {
                koy = values;
            }
            println("koy={koy}");
        } else if (n == "kit") {
            const p = cmd.getPath().path;
            const values = cmd.getIntArray();
            if (p[1] instanceof Range) {
                const r = p[1] as Range;
                while (kit.size() < r.startIndex) {
                    insert 0 into kit;
                }
                kit[r.startIndex..r.endIndex] = values;
            } else if (p[1] instanceof Index) {
                const r = p[1] as Index;
                while (kit.size() < r.index) {
                    insert 0 into kit;
                }
                kit[r.index..r.index] = values;
            } else {
                kit = values;
            }
        } else if (n == "kot") {
            const p = cmd.getPath().path;
            const values = cmd.getIntArray();
            if (p[1] instanceof Range) {
                const r = p[1] as Range;
                while (kot.size() < r.startIndex) {
                    insert 0 into kot;
                }
                kot[r.startIndex..r.endIndex] = values;
            } else if (p[1] instanceof Range) {
                const r = p[1] as Index;
                while (kot.size() < r.index) {
                    insert 0 into kot;
                }
                kot[r.index..r.index] = values;
            } else {
                kot = values;
            }
        } else super.setAttr(cmd);
    }

    abstract function toChannel from (m is MaModel, clip is Boolean) to Channel of a;

}

const FPS = 1s/24.0;

class MAnimCurve__ is MAnimCurve of Number 
{
    const type is String;
    var ktv is Vec2[];

    override function setAttr from (cmd is Command) to () 
    {

        const n = cmd.getAttr();
        if (n == "ktv") {
            const p = cmd.getPath().path;
            const values = cmd.getFloat2Array();
            if (p[1] instanceof Range) {
                const r = p[1] as Range;
                while (ktv.size() < r.startIndex) {
                    insert Vec2.<<0>> into ktv;
                }
                ktv[r.startIndex..r.endIndex] = values;
            } else if (p[1] instanceof Range) {
                const r = p[1] as Range;
                while (ktv.size() < r.startIndex) {
                    insert Vec2.<<0>> into ktv;
                }
                ktv[r.startIndex..r.endIndex] = values;
            } else {
                ktv = values;
            }
        } else super.setAttr(cmd);
    }

    function getInterpolator from (i1 is Integer) to KeyFrame.NumberInterpolator 
    {
        var tan0 = tan;
        var tan1 = tan;
        const i0 = i1-1;
        if (i0 > 0 and i0 < kot.size()) {
            const t = kot[i0];
            if (t <> 0) {
                tan0 = t;
            }
        }
        if (i1 < kit.size()) {
            const t = kit[i1];
            if (t <> 0) {
                tan1 = t;
            }
        }
        if (tan0 == LINEAR) {
            return KeyFrame.Linear;
        }
        /*
        if (tan0 == FIXED) {
            //return KeyFrame.Discrete;
            return KeyFrame.Linear;
        }
        if (tan0 == STEPPED or i1 > kix.size()) {
            return KeyFrame.Linear;
        }
        */      
        var x0 is Number;
        var y0 is Number;
        var x1 is Number;
        var y1 is Number;
        if (i0 < 0) {
            x0 = 1.0;
            y0 = 0.0;
        } else {
            x0 = kox[i0];
            y0 = koy[i0]
        } 
        if (i1 == kix.size()) {
            x1 = 1.0;
            y1 = 0.0;
        } else {
            x1 = kix[i1];
            y1 = kiy[i1];
        }
        if (x0 == 0 or x1 == 0) {
            println("bad tangent interpolator {name} {x0},{y0} {x1},{y1}");
            return KeyFrame.Linear;
        }
        println("created interpolator {name} {x0},{y0} {x1},{y1}");
        KeyFrame.Tangent {
            kix: x1;
            kiy: y1;
            kox: x0;
            koy: y0;
        }
    }

    override function toChannel from (m is MaModel, clip is Boolean) to Channel of Number 
    {
        var targets is (Ref of Number)[];
        if (not clip) {
            targets = m.getNumberTargets(this, "o");
        } else {
            for (conn in connectionsFromThis.get("a")) {
                const path = parsePath(conn.targetPath).path;
                const cev = (path[3] as Index).index;
                const lib = conn.targetNode as MClipLibrary;
                for (conn2 in lib.connectionsToThis.get("cd")) {
                    if (conn2.sourceNode is MCharacter) {
                        const char = conn2.sourceNode as MCharacter;
                        for (conn3 in char.connectionsToThis.get("dnsm")) {
                            const path2 = parsePath(conn3.targetPath).path;
                            const ind = (path2[1] as Index).index;
                            if (ind == cev) {
                                const p = m.resolveSourcePointer(conn3);
                                insert p as Ref of Number into targets;
                                break;
                            }
                        }
                        break;
                    }
                }
            }
        }
        if (targets == []) {
            println("no targets { name } as clip {clip}");
            return null;
        }
        const keyTimesInSeconds = (this.type == "animCurveUA" or
                                   this.type == "animCurveUL" or
                                   this.type == "animCurveUT" or
                                   this.type == "animCurveUU"); 
        const rate = if (keyTimesInSeconds) then 1s else FPS;
        const keys = foreach (kt in ktv) {
                const adjustment = if (not keyTimesInSeconds and kt.x <> 0.0) then -1 else 0;
                KeyFrame.Key of Number {
                    position: rate * (kt.x + adjustment);
                    value: kt.y;
                    interpolator: getInterpolator(indexof kt);
                }
        }
        println("creating channel with {keys.size()} keys");
        if (keys.size() == 0) then null else NumberChannel
        {
            id: name;
            targets: targets;
            keys: keys
        }
    }
}


class Command 
{
    const name is String;
    readonly var args is String[];
    const namedArgs is java.util.Map of (String, String) 
        = new java.util.HashMap of (String, String);

    override function toString to String 
    {
        "{name} {foreach (ent in namedArgs.entrySet()) " -{ent.getKey()} {ent.getValue()}"} {foreach (arg in args) " {arg}"}"
    }

    public function getBoolean to Boolean {
        const s = getString(1);
        s == "yes" or s == "true" 
    }

    public function getString to String {
        getString(1)
    }

    public function getInt to Integer 
    {
        getInt(1)
    }

    public function getFloat to Number 
    {
        getFloat(1)
    }

    public function getAttr to String 
    {
        const attr = getString(0);
        const bracket = attr.indexOf("[");
        if (bracket > 0) {
            return attr.substring(1, bracket);
        }
        return attr.substring(1)
    }

    public function getPath to Path 
    {
        parsePath(getString(0))
    }
    
    public function getFloatArray to Number[] 
    {
        const count = getCount("s", 1);
        foreach (k in [1..count]) getFloat(k)
    }

    public function getStringArray to String[] 
    {
        const count = getInt(1);
        foreach (k in [0..<count]) getString(k+2);
    }

    public function getIntArray to Integer[] 
    {
        const count = getCount("s", 1);
        foreach (k in [1..count]) getInt(k)
    }

    public function getFloat2Array to Vec2[] 
    {
        const count = getCount("s", 2);
        foreach (k in [1..count*2 step 2]) vector(getFloat(k), getFloat(k+1))
    }

    public function getFlatFloat2Array to Number[] 
    {
        const count = getCount("s", 2);
        foreach (k in [1..count*2]) getFloat(k);
    }

    public function getFloat3 to Vec3 {
        vector(getFloat(1),
               getFloat(2),
               getFloat(3));
    }

    public function getFloat3Array to Vec3[] 
    {
        const count = getCount("s", 3);
        foreach (k in [1..count*3 step 3]) vector(getFloat(k), getFloat(k+1), getFloat(k+2))
    }

    public function getFlatFloat3Array to Number[] 
    {
        const count = getCount("s", 3);
        foreach (k in [1..count*3]) getFloat(k)
    }

    public function getFlatInt3Array to Integer[] 
    {
        const count = getCount("s", 3);
        foreach (k in [1..count*3]) getInt(k)
    }

    public function getPolyfaceData to PolyfaceData[] 
    {
        const len = args.size();
        var i = 1;
        var faceData is PolyfaceData[];
        while (i < len) {
            var cmd = getString(i++);
            var faceEdges is Integer[];
            var mu is UVData[];
            var holes is Integer[];
            var vals is Integer[];
            if (cmd == "f") {
                const count = getInt(i++);
                for (j in [0..<count]) {
                    insert getInt(i++) into faceEdges;
                }
            }
            cmd = getString(i);
            while (cmd == "mu") {
                i++;
                const uvSet = getInt(i++);
                var uvs is Integer[];
                const count = getInt(i++);
                for (j in [0..<count]) {
                    insert getInt(i++) into uvs;
                }
                insert UVData {
                    uvSet: uvSet;
                    uvIndices: uvs;
                } into mu;
                cmd = getString(i);
            }
            insert PolyfaceData {
                faceEdges: faceEdges;
                mu: mu;
            } into faceData;
        }
        //println("faceData={faceData}");
        return faceData;
    }

    const NEG = "-".charAt(0);

    function isInt from (idx is Integer) to Boolean 
    {
        const str = getString(idx);
        const len = str.length();
        if (len == 0) {
            return false;
        }
        var ch = str.charAt(0);
        var i = 0;
        if (ch == NEG) {
            if (len == 1) {
                return false;
            }
            ++i;
        } 
        while (i < len) {
            if (not Character.isDigit(str.charAt(i++))) {
                return false;
            }
        }
        return true;
    }

    const longNames = ["unitlessValues", "angularValues", "linearValues"];
    const shortNames = ["uv", "av", "lv"];

    public function getAttributeAlias to java.util.Map of (String, String) {
        const map = new java.util.HashMap of (String, String);
        var i = 2; // skip aal {
        while (i < args.size()) {
            const k = trim(args[i++]); 
            i++; // skip ,
            var v = trim(args[i++]);
            i++; // skip ,
            //println("k={k} v={v} next={args[i]}");
            const p = parsePath(v);
            const f = p.path[0] as Field;
            const fi = p.path[1] as Index;
            for (j in longNames) {
                if (j == f.name) {
                    v = "{shortNames[indexof j]}[{fi.index}]";
                    break;
                }
            }
            map.put(k, v);
        }
        return map;
    }

    public function getCharacterMapping to java.util.Map of (String, String) {
        const map = new java.util.HashMap of (String, String);
        var i = 1; // skip am {
        const count = getInt(i++);
        while (i < args.size()) {
            const k = trim(args[i++]); 
            const i1 = Integer.parseInt(args[i++]);
            const i2 = Integer.parseInt(args[i++]);
            const k1 = if (i1 == 0) then "uv" else if (i1 == 1) then "lv" else "av";
            map.put("{k1}[{i2}]", k);
        }
        return map;
    }

    public function getMatrix to Mat4 
    {
        const arr = getFloatArray();
        if (arr.size() <> 16) {
            return Mat4.<<1>>;
        }
        Mat4.fromColumns(arr);
    }

    public function getVec3 to Vec3 
    {
        vector(getFloat(1), getFloat(2), getFloat(3))
    }

    public function getTuple3 to Tuple3
    {
        tuple(getFloat(1), getFloat(2), getFloat(3))
    }

    public function getPoint3 to Point3 
    {
        point(getFloat(1), getFloat(2), getFloat(3))
    }

    public function getVec2 to Vec2 
    {
        vector(getFloat(1), getFloat(2));
    }

    public function getCount(size is String, width is Integer) to Integer 
    {
        const c = (args.size()-1) / width; 
        const s = getString(size);
        if (s <> null) then Math.min(Integer.parseInt(s), c) else c;
    }

    public function getInt from (key is String) to Integer 
    {
        java.lang.Integer.parseInt(getString(key));
    }

    public function getInt from (i is Integer) to Integer 
    {
        java.lang.Integer.parseInt(getString(i));
    }

    public function getFloat from (key is String) to Number 
    {
        try {
            return java.lang.Double.parseDouble(getString(key)) as Number;
        } catch (e) {
            println("error {this}, key={key}");
            return 0.0;
        }
    }

    public function getFloat from (i is Integer) to Number 
    {
        try {
            const str = getString(i);
            if (str == "nan") {
                return 0;
            }
            return java.lang.Double.parseDouble(str) as Number;
        } catch (e) {
            println("error {this}, index={i}");
            return 0.0;
        }
    }

    public function getString from (key is String) to String 
    {
        trim(namedArgs.get(key));
    }

    public function getString from (i is Integer) to String 
    {
        trim(args[i]);
    }

    public function trim from (s is String) to String 
    {
        if (s.startsWith("\"")) then s.substring(1, s.length()-1) else s;
    }
}

class MaParser 
{
    public var dynamicsWorld is DynamicsWorld;
    public var effectLoader is CGEffectLoader;
    public var imageLoader is ImageLoader;
    var pos = 0;
    const buf = new java.lang.StringBuffer;
    var tokens = new java.util.ArrayList of String;
    const cmds = new java.util.ArrayList of Command;

    function flush {
        if (buf.length() > 0) {
            tokens.add(buf.toString());
            buf.setLength(0);
        }
    }

    function consumeUntil from (input is String, end is Character) to () 
    {
        const len = input.length();
        const backslash = "\\";
        const escapes = "ntr";
        const escaped = "\n\t\r";
        while (pos < len) {
            var ch = input.charAt(pos++);
            var escape = false;
            if (backslash.indexOf(ch) == 0) {
                escape = true;
                ch = input.charAt(pos++);
                const i = escapes.indexOf(ch);
                if (i >= 0) {
                    ch = escaped.charAt(i);
                }
            }
            buf.append(ch);
            if (not escape and ch == end) {
                break;
            }
        }
        flush()
    }

    function tokenize from (s is String) to () 
    {
        const ws = " \r\n\t";
        const quot = "\"";
        const izer = new java.util.StringTokenizer(s, ";");
        while (izer.hasMoreTokens()) {
            const tok = izer.nextToken();
            if (tok.startsWith("//")) {
                continue;
            }
            buf.setLength(0);
            var len = tok.length();
            pos = 0;
            while (pos < len) {
                const ch = tok.charAt(pos++);
                if (ws.indexOf(ch) >= 0) {
                    flush();
                } else if (quot.indexOf(ch) == 0) {
                    flush();
                    buf.append(ch);
                    consumeUntil(tok, quot.charAt(0));
                } else {
                    buf.append(ch);
                }
            }
            flush();
            if (tokens.size() > 0) {
                const cmd = parseCommand(tokens);
                if (cmd <> null) {
                    cmds.add(cmd);
                }
                tokens.clear();
            }
        }
    }

    public function parse from (u is java.net.URL) to MaModel 
    {
        const r = new java.io.BufferedReader(new java.io.InputStreamReader(u.openStream()));
        const buf = java.lang.StringBuffer {};
        while (true) {
            const ch is Integer = r.read();
            if (ch <= 0) {
                break;
            }
            buf.append(ch as Character);
        }
        parse(u.toString(), buf.toString())
    }

    public function parse from (url is String, input is String) to MaModel 
    {
        tokenize(input);
        const model = MaModel {
            dynamicsWorld: dynamicsWorld;
            effectLoader: effectLoader;
            imageLoader: imageLoader;
            url: url
        }
        model.url = url;
        model.imageLoader = imageLoader;
        for (cmd in cmds) {
            model.processCommand(cmd)
        }
        model.generateScene();
        return model;
    }

    public function parseString from (input is String) to Command[] 
    {
        tokenize(input);
        foreach (cmd in cmds) cmd;
    }

    function parseCommand from (cmds is java.util.List of String) to Command 
    {
        const cmd = Command {
            name: cmds.get(0);
        }
        var i = 1;
        const len = cmds.size();
        while (i < len) {
            const s = cmds.get(i++);
            if (s.length() > 1 and s.startsWith("-") and not java.lang.Character.isDigit(s.charAt(1))) {
                var j = i;
                var v is String = if (i < len) then cmds.get(j++) else "";
                if (v.startsWith("-") and not java.lang.Character.isDigit(v.charAt(1))) {
                    v = null;
                }  else {
                    i = j;
                }
                cmd.namedArgs.put(s.substring(1), v);
            } else {
                insert s into cmd.args;
            }
        }
        return cmd
    }
}

const RotateOrders = ["xyz", "yzx", "zxy", "xzy", "yxz", "zyx"].reverse();
const RotateOrder =   
   [0, 1, 2,  // 0=xyz
    1, 2, 0,  // 1=yzx
    2, 0, 1,  // 2=zxy
    0, 2, 1,  // 3=xzy
    1, 0, 2,  // 4=yxz
    2, 1, 0].reverse(); // 5=zyx

const axes = [Vec3.X_AXIS, Vec3.Y_AXIS, Vec3.Z_AXIS];

// http://download.autodesk.com/global/docs/maya2012/en_us/Nodes/transform.html
public class MaTransform is Group
{
    public var itrs is Point3;
    public var irot is Vec3;
    // translation
    public var tx is Number;
    public var ty is Number;
    public var tz is Number;
    // rotation
    public var rx is Number;
    public var ry is Number;
    public var rz is  Number;
    // scale
    public var sx is Number = 1.0;
    public var sy is Number = 1.0;
    public var sz is Number = 1.0;
    // rotate pivot
    public var rpx is Number;
    public var rpy is Number;
    public var rpz is Number;
    // rotate pivot translate
    public var rptx is Number;
    public var rpty is Number;
    public var rptz is Number;
    // scale pivot
    public var spx is Number;
    public var spy is Number;
    public var spz is Number;
    // scale pivot translate
    public var sptx is Number;
    public var spty is Number;
    public var sptz is Number;
    // transMinusRotatePivot
    public var tmrpx is Number;
    public var tmrpy is Number;
    public var tmrpz is Number;
    // rotate order
    public var ro is Integer;


    // translation
    public readonly var t is Point3 = bind point(tx, ty, tz);
    // rotation
    public readonly var r is Mat4 = bind if (constraint is AimConstraint or constraint is OrientConstraint) then constraint.transform else rotate(irot.x+rx, irot.y+ry, irot.z+rz, ro);
    // scale
    public readonly var s is Tuple3 = bind tuple(sx, sy, sz);

    public readonly var rp is Point3 = bind point(rpx, rpy, rpz);
    
    override public bound function getScalePivot to Mat4 {
        translate(itrs.x+tx+rpx+rptx, 
                  itrs.y+ty+rpy+rpty, 
                  itrs.z+tz+rpz+rptz) * 
            r *
            translate(-rpx
                      -rpy, 
                      -rpz);
    }

    override var transform = 
        bind if (constraint <> null)
        then constraint.transform 
        else translate(itrs.x+tx+rpx+rptx, 
                       itrs.y+ty+rpy+rpty, 
                       itrs.z+tz+rpz+rptz) * 
                 r *
                 translate(-rpx+spx, 
                           -rpy+spy, 
                           -rpz+spz) *
                 scale(sx, sy, sz) *
                 translate(-spx, 
                           -spy, 
                           -spz);
    
   public var constraint is Constraint;
}

public class ForceFieldNode is MaTransform {
    public var forceField is ForceField;
    override function update to ()
    {
        forceField.apply();
        super.update();
    }
}

public class Joint is MaTransform {
    public function setIKRotation from (rot is Quat) to ()
    {
    }
    public var jox is Number;
    public var joy is Number;
    public var joz is Number;
    public var jo is Integer = 0; // jot mapped to RotateOrder
    public var ssc is Boolean = true; // segment scale compensate
    public readonly var jor = bind rotate(jox, joy, joz, jo);

    var parentTransform is MaTransform = bind parent as MaTransform;
    var parentInverseScale is Tuple3 = bind if (not ssc) then Tuple3.<<1>> else { var i_s = Tuple3.<<1>> / parentTransform.s; if (i_s == null) then Tuple3.<<1>> else i_s }

    var ikEffector is MaTransform;

    bound var t0 = if (ikEffector <> null) then ikEffector.t else t;

    var ikr is Mat4 = Mat4.<<1>>;
    var is_ik is Boolean = false;

    postinit {
        ikr = jor;
    }

    bound var r0 = if (is_ik) then ikr else r;

    override var transform =  bind if (constraint <> null) then constraint.transform else
        translate(tx, ty, tz) * scale(parentInverseScale) * jor * r * scale(sx, sy, sz);
        //bind computeTransform(tx, ty, tz, parentInverseScale, jor, r0, sx, sy, sz);

    function computeTransform
        from (tx is Number,
              ty is Number,
              tz is Number,
              parentInverseScale is Tuple3,
              jor is Mat4,
              r0 is Mat4,
              sx is Number,
              sy is Number,
              sz is Number)
        to Mat4 
    {
        
        println("this={this.id}: tx={tx} this.tx={this.tx} ty={ty} this.ty={this.ty} tz={tz} parentInverseScale ={parentInverseScale} \njor={jor} \nr0={r0} \nsx={sx} sy={sy} sz={sz}");
        translate(tx, ty, tz) * scale(parentInverseScale) * jor * r0 * scale(sx, sy, sz);
    }

    var preferredRotation is Quat;

    var pax is Number;
    var pay is Number;
    var paz is Number;
    bound var pa = rotate(pax, pay, paz, ro);

    function getPreferredRotation to Quat {
        if (preferredRotation == null) {
            preferredRotation = pa.getRotation();
        }
        return preferredRotation;
    }

    function resetPreferredRotation {
        ikr = getPreferredRotation().toMat4();
    }

    function setPreferredRotation
        from (x is Number, y is Number, z is Number, w is Number) 
        to ()
    {
        const q = Quat { x: x, y: y, z: z, w: w };
        ikr = (Quat.Quat(toSceneTransform.inverse()) * q  * getPreferredRotation()).toMat4();
    }
}

abstract class MConstraint is MNode {
    var targets is MTransform[];
    var erp is Boolean;
    var rst is Vec3;

    protected const sourceMap = new java.util.HashMap of (String, Constraint.Source);

    abstract function toConstraint from (m is MaModel) to Constraint;

    public override function getPointer from (ptr is String, resolved is Object) to Ref of ?
    {
        println("GET POINTER {ptr} => {sourceMap.get(ptr)}");
        println("source map: {sourceMap}");
        &sourceMap.get(ptr).weight;
    }
}

class MPointConstraint is MConstraint {

    override function toConstraint from (m is MaModel) to Constraint 
    {
        var contextNode is MNode;
        for (c in connectionsFromThis.get("ctx")) {
            contextNode = c.targetNode;
        }
        const tn = m.toNode(contextNode as MSpatial) as MaTransform;
        const constraint = Constraint.PointConstraint {
            toSceneTransform: bind tn.parent.toSceneTransform;
        }
        println("toConstraint: {connectionsToThis}");
        for (i in [0..<10]) {
            var sourceNode is MNode;
            var w is String;
            for (conn in connectionsToThis.get("tg")) {
                if (conn.targetPath == "tg[{i}].tw") {
                    w = conn.sourcePath;
                } else if (conn.targetPath == "tg[{i}].tt") {
                    sourceNode = conn.sourceNode;
                }
            }
            if (sourceNode == null) break;
            const source = Constraint.Source {
                weight: 1.0;// @TODO
            }
            sourceMap.put(w, source);
            source.node = m.toNode(sourceNode as MSpatial);
            insert source into constraint.sources;
        }
        tn.constraint = constraint;
        return constraint;
    }
}

class MOrientConstraint is MConstraint {
    override function toConstraint from (m is MaModel) to Constraint 
    {
        var contextNode is MNode;
        for (c in connectionsFromThis.get("crx")) {
            contextNode = c.targetNode;
        }
        const tn = m.toNode(contextNode as MSpatial) as MaTransform;
        const constraint = Constraint.OrientConstraint {
            toSceneTransform: bind tn.parent.toSceneTransform;
        }
        for (i in [0..<10]) {
            var sourceNode is MNode;
            var w is String;
            for (conn in connectionsToThis.get("tg")) {
                if (conn.targetPath == "tg[{i}].tw") {
                    w = conn.sourcePath;
                } else if (conn.targetPath == "tg[{i}].tr") {
                    sourceNode = conn.sourceNode;
                }
            }
            if (sourceNode == null) break;
            const source = Constraint.Source {
                weight: 1.0;// @TODO
            }
            sourceMap.put(w, source);
            source.node = m.toNode(sourceNode as MSpatial);
            insert source into constraint.sources;
        }
        tn.constraint = constraint;
        return constraint;
    }
}

class MParentConstraint is MConstraint {
    override function toConstraint from (m is MaModel) to Constraint 
    {
        var contextNode is MNode;
        for (c in connectionsFromThis.get("crx")) {
            contextNode = c.targetNode;
        }
        const tn = m.toNode(contextNode as MSpatial) as MaTransform;
        const constraint = Constraint.ParentConstraint {
            toSceneTransform: bind tn.parent.toSceneTransform;
        }
        for (i in [0..<10]) {
            var sourceNode is MNode;
            var w is String;
            for (conn in connectionsToThis.get("tg")) {
                if (conn.targetPath == "tg[{i}].tw") {
                    w = conn.sourcePath;
                } else if (conn.targetPath == "tg[{i}].tr") {
                    sourceNode = conn.sourceNode;
                }
            }
            if (sourceNode == null) break;
            const source = Constraint.Source {
                weight: 1.0;// @TODO
            }
            sourceMap.put(w, source);
            source.node = m.toNode(sourceNode as MSpatial);
            insert source into constraint.sources;
        }
        tn.constraint = constraint;
        return constraint;
    }
}

class MAimConstraint is MConstraint {
    var a is Vec3 = new Vec3(1, 0, 0);
    var u is Vec3 = new Vec3(0, 1, 0);
    var wu is Vec3 = new Vec3(0, 1, 0);
    var rsrr is Tuple3;
    var o is Tuple3;
    override function setAttr from (cmd is Command) to () {
        const n = cmd.getAttr();
        if (n == "a") {
            a = cmd.getVec3();
        } else if (n == "u") {
            u = cmd.getVec3();
        } else if (n == "wu") { 
            wu = cmd.getVec3();
        } else if (n == "rsrr") {
            rsrr = cmd.getTuple3();
        } else if (n == "o") {
            o = cmd.getTuple3();
        } else super.setAttr(cmd);
    }
    override function toConstraint from (m is MaModel) to Constraint 
    {
        var contextNode is MNode;
        for (c in connectionsFromThis.get("crx")) {
            contextNode = c.targetNode;
        }
        const tn = m.toNode(contextNode as MSpatial) as MaTransform;
        const constraint = Constraint.AimConstraint {
            toSceneTransform: bind tn.parent.toSceneTransform;
            aimVector: a;
            localUpVector: u;
            sceneUpVector: wu;
        }
        for (i in [0..<10]) {
            var sourceNode is MNode;
            var w is String;
            for (conn in connectionsToThis.get("tg")) {
                if (conn.targetPath == "tg[{i}].tw") {
                    w = conn.sourcePath;
                } else if (conn.targetPath == "tg[{i}].tt") {
                    sourceNode = conn.sourceNode;
                }
            }
            if (sourceNode == null) break;
            const source = Constraint.Source {
                weight: 1.0;// @TODO
            }
            sourceMap.put(w, source);
            source.node = m.toNode(sourceNode as MSpatial);
            insert source into constraint.sources;
        }
        println("aim constraint => {sourceMap}");
        println("aim constraint => tn={tn}");
        tn.constraint = constraint;
        return constraint;
    }
}

// http://download.autodesk.com/global/docs/maya2012/en_us/Nodes/joint.html

function dumpScene from (spatialRoot is Node) to ()
{
    println(spatialRoot.foldLeft("", function from (y is String, x is Node) to String 
                                 {
                                     if (y == "") 
                                         then "{x.id} =\n{x.transform}" 
                                         else "{y}\n{x.id} {x.getClass()} =\n{x.transform}";
                                 }));
}

public class ModelContent {
    public var spatial is Node;
    public var temporal is TimeNode;
    public var clipLibraries is TimeGroup[];
    public var cameras is Camera[];
    public var resources is String[];
    public var shaders is Shader[];
}

public class Model {

    public var url is String;
    public const effectLoader is CGEffectLoader = the CGEffectLoader;
    public const imageLoader is ImageLoader = the ImageLoader;
    public const dynamicsWorld is DynamicsWorld;

    var fileTimestamp is Long;

    postinit {
        checkTimestamp();
    }

    public bound function getResources to String[] 
    {
        return modelContent.resources;
    }

    const subject = Subject of ModelContent {};
    
    public function observeModelContent to Observable of ModelContent 
    {
        subject
    }

    public bound function getClipLibraries to TimeGroup[] 
    {
        modelContent.clipLibraries;
    }

    public bound function getCameras to Camera[]
    {
        modelContent.cameras;
    }

    public bound function getShaders to Shader[]
    {
        modelContent.shaders;
    }

    function makeRootMonitor from (modelContent is ModelContent) to Node {
        Group {
            id: bind "{url} {new java.util.Date(fileTimestamp)}";
            content: bind modelContent.spatial;
            override function update to ()
            {
                checkTimestamp();
                super.update();
            }
        }
    }


    public bound function getSpatialRoot to Node 
    {
        if (monitorForChanges) {
            makeRootMonitor(modelContent)
        } else modelContent.spatial;
    }

    public bound function getTemporalRoot to TimeNode 
    {
        modelContent.temporal;
    }

    public readonly var modelContent is ModelContent = 
        bind load(url, effectLoader, imageLoader, fileTimestamp); 

    public var monitorForChanges is Boolean = false;
    public var pollInterval is Duration = 2s;
    var lastCheck is Long;

    function checkTimestamp to ()
    {
        if (monitorForChanges) {
            const now = java.lang.System.currentTimeMillis();
            if (now >= lastCheck + pollInterval.toMillis()) {
                lastCheck = now;
                if (url.startsWith("file:")) {
                    const u1 = new java.net.URL(url);
                    const f = new java.io.File(new java.net.URI(u1.getProtocol(), u1.getPath(), null));
                    fileTimestamp = f.lastModified();
                }
            }
        }
    }

    function load from (url is String, 
                        effectLoader is CGEffectLoader, 
                        imageLoader is ImageLoader,
                        timestamp is Long) to ModelContent 
    {
        load(url, effectLoader, imageLoader);
    }

    function load from (url is String, 
                        effectLoader is CGEffectLoader, 
                        imageLoader is ImageLoader) to ModelContent 
    {
        const p = MaParser {effectLoader: effectLoader, imageLoader: imageLoader, dynamicsWorld: dynamicsWorld};
        const m = p.parse(new java.net.URL(url));
        m.spatialRoot.updateParent();
        m.checkDeformers();
        const mc = ModelContent {
            resources: foreach (u in m.resourceUrls) u;
            spatial: m.spatialRoot;
            temporal: m.temporalRoot;
            cameras: m.getCameras();
            clipLibraries: m.clipLibs;
            shaders: m.getShaders();
        }
        subject.onNext(mc);
        return mc;
    }
}

