package f3.media.scene;
import f3.math.*;
import f3.math.LinearMath.*;
import f3.media.scene.*;
import f3.lang.Ref;
import java.lang.Math;

class MAttr {
    const longName is String;
    const shortName is String;
    const type is String;
    var value is Object;
    const parent is MAttr;
}

class MaModel 
{
    const nodeMap is java.util.Map of (String, MNode) = 
	new java.util.HashMap of (String, MNode) ();

    function findNode from (name is String) to MNode 
    {
	nodeMap.get(name);
    }

    var current is MNode; 

    var effectLoader is CGEffectLoader;
    var imageLoader is ImageLoader;

    function createNode from (cmd is Command) to () 
    {
	const nodeType = cmd.getString(0);
	const name = cmd.getString("n");
	const parent = cmd.getString("p");

	current = 
	    if (nodeType == "transform") 
		then MTransform {name: name, parent: findNode(parent)}
	    else if (nodeType == "joint") 
		then MJoint {name: name, parent: findNode(parent)}
	    else if (nodeType == "camera") 
		then MCamera {name: name, parent: findNode(parent)}
	    else if (nodeType == "mesh") 
		then MMesh {name: name, parent: findNode(parent)}
	    else if (nodeType == "phong" or nodeType == "blinn" or nodeType == "lambert") 
		then MShader {type: nodeType, name: name}
	    else if (nodeType == "cgfxShader") 
		then MCGFXShader {name: name}
	    else if (nodeType == "cgfxVector") 
		then MCGFXVector {name: name}
	    else if (nodeType == "file") 
		then MFile {name: name}
	    else if (nodeType == "shadingEngine") 
		then MShadingEngine {name: name}
	    else if (nodeType == "pointLight") 
		then MLight { name: name, parent: findNode(parent), type: nodeType }
	    else if (nodeType.startsWith("animCurve")) 
		then MAnimCurve__ {name: name, parent: findNode(parent)}
	    else if (nodeType == "character") 
		then MCharacter {name: name}
	    else if (nodeType == "addDoubleLinear") 
		then MAddDoubleLinear {name: name}
	    else if (nodeType == "multiplyDivide") 
		then MMultiplyDivide {name: name}
	    else null;
	if (current <> null) {
	    nodeMap.put(current.name, current);
	    nodeMap.put(current.getFullName(), current);
	}
    }

    var lastSetAttr is Command;
    function mergeSetAttr from (next is Command) to () 
    {
	const c = lastSetAttr;
	lastSetAttr = null;
	if (c != null) {
	    next.namedArgs.putAll(c.namedArgs);
	}
    }

    function processCommand from (cmd is Command) to () 
    {
	const n = cmd.name;
	if (n == "createNode") {
	    createNode(cmd);
	} else if (n == "setAttr") {
	    if (cmd.args.size() > 1) {
		mergeSetAttr(cmd);
		setAttr(cmd);
	    } else {
		lastSetAttr = cmd;
	    }
	} else if (n == "addAttr") {
	    addAttr(cmd);
	} else if (n == "connectAttr") {
	    connectAttr(cmd)
	}
    }

    function addAttr from (cmd is Command) to () 
    {
	current.addAttr(cmd);
    }

    function setAttr from (cmd is Command) to () 
    {
	current.setAttr(cmd);
    }
    
    function connectAttr from (cmd is Command) to () 
    {
	const source = cmd.getString(0);
	var dot = source.indexOf(".");
	const sourceName = source.substring(0, dot);
	const sourcePath = source.substring(dot+1);
	const target = cmd.getString(1);
	dot = target.indexOf(".");
	const targetName = target.substring(0, dot);
	const targetPath = target.substring(dot+1);
	const sourceNode = findNode(sourceName);
	const targetNode = findNode(targetName);
	//println("connectAttr {sourceNode} => {targetNode} from {sourcePath} to {targetPath}");
	const conn = 
	    Connection 
	    {
		sourceNode: sourceNode;
		sourcePath: sourcePath;
		targetNode: targetNode;
		targetPath: targetPath;
	    }
	sourceNode.addConnectionFrom(conn);
	targetNode.addConnectionTo(conn);
    }

    const spatialMap is java.util.Map of (MNode, Node) = 
	new java.util.HashMap of (MNode, Node) ();

    const temporalMap is java.util.Map of (MNode, TimeNode) = 
	new java.util.HashMap of (MNode, TimeNode) ();

    const shaderMap is java.util.Map of (MNode, Shader) = 
	new java.util.HashMap of (MNode, Shader) ();

    public var url is String;

    public var spatialRoot is Group;
    public var temporalRoot is TimeGroup;
    var channels is TimeNode[];

    function getCameras to Camera[] {
	var result is Camera[];
	foreach (n in spatialMap.values() where n is Camera) n as Camera;
    }

    function toNode from (n is MSpatial) to Node 
    {
	if spatialMap.containsKey(n)
	    then spatialMap.get(n) 
	    else spatialMap.put(n, n.toNode(this))
    }

    function resolveInput 
	from (n is MNode, 
	      attr is String, 
	      value is Number) 
	to function from () to Number 
    {
	var result is function from () to Number;
	for (c in n.connectionsToThis.get(attr)) {
	    if (c.sourceNode is MUtility of Number) {
		const src = c.sourceNode as MUtilityOfNumber;
		result = src.getOutput(this, c.sourcePath);
		break;
	    } else {
		const ptr = resolveSourcePointer(c) as Ref of Number;
		if (ptr <> null) {
		    result = function from () to Number { ptr.get() }
		    break;
		}
	    }
	}
	if (result == null) {
	    result = function from () to Number { value }
	}
	result as function from() to Number;
    }

    function resolveInput from (n is MUtility, attr is String, value is Tuple3) to function from () to Tuple3 {
	var result is function from () to Tuple3;
	for (c in n.connectionsToThis.get(attr)) {
	    if (c.sourceNode is MUtility of Tuple3) {
		const src = c.sourceNode as MUtilityOfTuple3;
		result = src.getOutput(this, c.sourcePath);
		break;
	    } else {
		const ptr = resolveSourcePointer(c) as Ref of Tuple3;
		if (ptr <> null) {
		    result = function from () to Tuple3 { ptr.get() }
		    break;
		}
	    }
	}
	if (result == null) {
	    const fx = resolveInput(n, "{attr}x", value.x);
	    const fy = resolveInput(n, "{attr}y", value.y);
	    const fz = resolveInput(n, "{attr}z", value.z);
	    result = function from () to Tuple3 {
		tuple(fx(), fy(), fz());
	    }
	}
	result as function from () to Tuple3;
    }

    function resolveTargetPointer
	from (c is Connection) to Ref of ?
    {
	const target = c.targetNode;
	if (target instanceof MCharacter) {
	    (target as MCharacter).resolveTargetPointer(this, c)
	} else if (target instanceof MSpatial) {
	    const resolved = toNode(target as MSpatial);
	    target.getPointer(c.targetPath, resolved);
	} else if (target instanceof MAbstractShader) {
	    const resolved = toShader(target as MAbstractShader);
	    target.getPointer(c.targetPath, resolved);
	} else null
    }

    function resolveSourcePointer
	from (c is Connection) to Ref of ?
    {
	const target = c.sourceNode;
	if (target instanceof MCharacter) {
	    (target as MCharacter).resolveSourcePointer(this, c)
	} else if (target instanceof MSpatial) {
	    const resolved = toNode(target as MSpatial);
	    target.getPointer(c.sourcePath, resolved);
	} else if (target instanceof MAbstractShader) {
	    const resolved = toShader(target as MAbstractShader);
	    target.getPointer(c.targetPath, resolved);
	} else null
    }

    function getNumberTargets 
	from (n is MNode, sourcePath is String) to (Ref of Number)[]
    {
	foreach (c in n.connectionsFromThis.get(sourcePath)) {
	    const ptr = resolveTargetPointer(c) as Ref of Number;
	    ptr;
	}
    }

    function toParentNode from (n is MSpatial) to Group
    {
	const node = toNode(n);
	if (node == null) then spatialRoot else node as Group;
    }

    function toChannel from (n is MAnimCurve) to TimeNode
    {
	if (temporalMap.containsKey(n)) then temporalMap.get(n) else {
		const ch = n.toChannel(this);
		//		println("{this} => {ch}");
		insert ch into channels;
		temporalMap.put(n, ch);
	    }
    }

    function toShader from (n is MAbstractShader) to Shader
    {
	if (shaderMap.containsKey(n)) then shaderMap.get(n) else {
		const shader = n.toShader(this);
		shaderMap.put(n, shader);
	    }
    }

    function generateScene 
    {
	spatialRoot = Group {id: url};
	temporalRoot = TimeGroup {id: url};
	for (n in nodeMap.values()) {
	    const r = 
		if (n is MSpatial) {
		    toNode(n as MSpatial)
		} else if (n is MAnimCurve) {
		    toChannel(n as MAnimCurve);
		} else null;
	}
	var j = 0;
	var g = TimeGroup {id: "{temporalRoot.id}#{j++}"};
	for (ch in channels) {
	    if (g.content.size() > 50) { // hack
		insert g into temporalRoot.content;
		g = TimeGroup {id: "{temporalRoot.id}#{j++}"};
	    }
	    insert ch into g.content;
	}
	insert g into temporalRoot.content;
	println(spatialRoot.foldLeft("", function from (y is String, x is Node) to String 
				     {
					 if (y == "") then "{x.id}" else "{y} -> {x.id}";
				     }));
	println(temporalRoot.foldLeft("", function from (y is String, x is TimeNode) to String 
				      {
					  if (y == "") then "{x.id}" else "{y} -> {x.id}";
				      }));
    }
}

class Connection {
    const sourceNode is MNode;
    const sourcePath is String;
    const targetNode is MNode;
    const targetPath is String;
    override function toString to String {
	"{sourceNode.name} {sourcePath} => {targetNode.name} {targetPath}"
    }
}


class MNode {
    const connectionsFromThis is java.util.Map of (String, Connection[]) =
	new java.util.HashMap of (String, Connection[]);
    const connectionsToThis is java.util.Map of (String, Connection[]) =
	new java.util.HashMap of (String, Connection[]);
    const attrs is java.util.Map of (String, MAttr) =
	new java.util.HashMap of (String, MAttr);
    const name is String;
    const parent is MNode;
    function getFullName to String {
	"{if (parent == null) then "" else parent.getFullName()}|{name}";
    }


    function getPointer 
	from (path is String, target is Object) 
	to Ref of ?
    {
	null
    }

    function resolveInput from (m is MaModel, p is String) to function from () to Object {
	println("{name} can't resolve: {p}");
	null;
    }

    function addConnectionTo from (c is Connection) to () 
    {
	const conns = connectionsToThis.get(c.targetPath);
	connectionsToThis.put(c.targetPath, [c, conns])
    }

    function addConnectionFrom from (c is Connection) to () 
    {
	const conns = connectionsFromThis.get(c.sourcePath);
	connectionsFromThis.put(c.sourcePath, [c, conns])
    }

    function addAttr from (cmd is Command) to () 
    {
	const shortName = cmd.getString("sn");
	const longName = cmd.getString("ln");
	const t = cmd.getString("at");
	const parent = cmd.getString("p");
	const attr = MAttr {
	    shortName: shortName;
	    longName: longName;
	    type: t;
	    parent: attrs.get(parent);
	}
	attrs.put(attr.shortName, attr);
	attrs.put(attr.longName, attr);
    }

    function setAttr from (cmd is Command) to () 
    {
	const attr = attrs.get(cmd.getAttr());
	if (attr != null) {
	    const t = attr.type;
	    const value = 
		if (t == "bool") {
		    cmd.getBoolean();
		} else if (t == "float") {
		    cmd.getFloat();
		} else if (t == "float2") {
		    cmd.getVec2();
		} else if (t == "float3") {
		    cmd.getVec3();
		} else if (t == "int") {
		    cmd.getInt()
		} else if (t == "long") {
		    cmd.getInt()
		} else if (t == "fltMatrix") {
		    cmd.getMatrix();
		} else null;
	    //println("setAttr {attr.shortName} {attr.type} = {value}");
	    if (attr.parent <> null) {
		const suffix = attr.shortName.substring(attr.parent.shortName.length()).toLowerCase();
		if (attr.parent.type == "float3") {
		    var v = attr.parent.value as Tuple3;
		    var n = value as Number;
		    if (suffix == "x") {
			v = tuple(n, v.y, v.z);
		    } else if (suffix == "y") {
			v = tuple(v.x, n, v.z);
		    } else if (suffix == "z") {
			v = tuple(v.x, v.y, n);
		    }
		    attr.parent.value = v;
		}
	    }
	    attr.value = value;
	}
    }
}

abstract class MSpatial is MNode {
    public var visible is Boolean = true;
    abstract function toNode from (m is MaModel) to Node;
    override function setAttr from (cmd is Command) to () {
	super.setAttr(cmd);
	const n = cmd.getAttr();
	if (n == "v") {
	    visible = cmd.getBoolean();
	}
    }

    override function resolveInput from (m is MaModel, p is String) to function from () to Object {
	const ptr = getPointer(p, m.toNode(this));
	if (ptr <> null) {
	    function from () to Object {
		ptr.get();
	    }
	} else super.resolveInput(m, p);
    }

    override function getPointer 
	from (path is String, target is Object) 
	to Ref of ?
    {
	if (false and path == "v") {
	    const n = target as Node;
	    &n.visible;
	} else super.getPointer(path, target);
    }
}

abstract class MUtility is MNode
{
}

abstract class MUtilityOfNumber is MUtility {
    abstract function getOutput from (m is MaModel, attr is String) to function from () to Number;
}

abstract class MUtilityOfTuple3 is MUtility {
    abstract function getOutput from (m is MaModel, attr is String) to function from () to Tuple3;
}

class MMultiplyDivide is MUtilityOfTuple3
{
    var i1 is Tuple3;
    var i2 is Tuple3;
    var op is Integer;

    override function resolveInput from (m is MaModel, p is String) to function from () to Object {
	
	if (p.startsWith("i1")) {
	    const t = m.resolveInput(this, "i1", i1);
	    if (p == "i1x") {
		function from () to Number {
		    t().x
		}
	    } else if (p == "i1y") {
		function from () to Number {
		    t().y
		}
	    } else if (p == "i1z") {
		function from () to Number {
		    t().z
		}
	    } else null
	} else if (p.startsWith("i2")) {
	    const t = m.resolveInput(this, "i2", i2);
	    if (p == "i2x") {
		function from () to Number {
		    t().x
		}
	    } else if (p == "i2y") {
		function from () to Number {
		    t().y
		}
	    } else if (p == "i2z") {
		function from () to Number {
		    t().z
		}
	    } else null
	} else null;
    }

    override function getOutput from (m is MaModel, attr is String) to function from () to Tuple3
    {
	if (attr == "o") {
	    const input1 is function from () to Tuple3 = m.resolveInput(this, "i1", i1);
	    const input2 is function from () to Tuple3 = m.resolveInput(this, "i2", i2);
	    if (op == 0) {
		// select first
		input1 as function from () to Tuple3;
	    } else if (op == 1) {
		// multiply
		function from () to Tuple3 {
		    const t1 is Tuple3 = input1();
		    const t2 is Tuple3 = input2();
		    tuple(t1.x*t2.x, 
			  t1.y*t2.y,
			  t1.z*t2.z);
		}
	    } else if (op == 2) {
		// divide
		function from () to Tuple3 {
		    const t1 is Tuple3 = input1();
		    const t2 is Tuple3 = input2();
		    tuple(t1.x/t2.x, 
			  t1.y/t2.y,
			  t1.z/t2.z);
		}
	    } else if (op == 3) {
		// pow
		function from () to Tuple3 {
		    const t1 is Tuple3 = input1();
		    const t2 is Tuple3 = input2();
		    tuple(Math.pow(t1.x,t2.x), 
			  Math.pow(t1.y,t2.y),
			  Math.pow(t1.z,t2.z));
		}
	    } else null
	} else null
    }

    override function setAttr from (cmd is Command) to () {
	super.setAttr(cmd);
	const n = cmd.getAttr();
	if (n == "i1") {
	    i1 = cmd.getVec3();
	} else if (n == "i2") {
	    i2 = cmd.getVec3();
	} else if (n == "op") {
	    op = cmd.getInt();
	}
    }
}

class MAddDoubleLinear is MUtilityOfNumber
{
    var i1 is Number;
    var i2 is Number;

    override function getOutput from (m is MaModel, attr is String) to function from () to Number
    {

	if (attr == "o") {
	    const input1 = m.resolveInput(this, "i1", i1);
	    const input2 = m.resolveInput(this, "i2", i2);
	    function from () to Number { input1() + input2() }
	} else null
    }

    override function setAttr from (cmd is Command) to () {
	super.setAttr(cmd);
	const n = cmd.getAttr();
	if (n == "i1") {
	    i1 = cmd.getFloat();
	} else if (n == "i2") {
	    i2 = cmd.getFloat();
	}
    }
}

class MTemporal is MNode {
}

class MTransform is MSpatial {

    var t is Vec3;
    var r is Vec3;
    var s is Vec3 = Vec3.<<1>>;
    var rp is Vec3;
    var rpt is Vec3;
    var sp is Vec3;
    var spt is Vec3;
    var tmrp is Vec3;
    var ro is Integer;
    
    override function setAttr from (cmd is Command) to () 
    {
	super.setAttr(cmd);
	const n = cmd.getAttr();
	if (n == "t") {
	    t = cmd.getVec3();
	} else if (n == "r") {
	    r = cmd.getVec3();
	} else if (n == "s") {
	    s = cmd.getVec3();
	} else if (n == "rp") {
	    rp = cmd.getVec3();
	} else if (n == "rpt") {
	    rp = cmd.getVec3();
	} else if (n == "sp") {
	    sp = cmd.getVec3();
	} else if (n == "spt") {
	    spt = cmd.getVec3();
	} else if (n == "tmrp") {
	    tmrp = cmd.getVec3();
	} else if (n == "ro") {
	    ro = cmd.getInt();
	}
    }

    override public function getPointer
	from (ptr is String, target is Object) 
	to Ref of ?
    {
	//	println("get pointer {name} attr={ptr} target={target}");

	const n = target as MaTransform;

	if ptr == "tx" 
        then &n.tx as Ref of ?
	else if ptr == "ty"
        then &n.ty as Ref of ?
	else if ptr == "tz"
        then &n.tz as Ref of ?

        else if ptr == "sx" 
        then &n.sx as Ref of ?
	else if ptr == "sy"
        then &n.sy as Ref of ?
	else if ptr == "sz"
        then &n.sz as Ref of ?

        else if ptr == "rx" 
        then &n.rx as Ref of ?
	else if ptr == "ry"
        then &n.ry as Ref of ?
	else if ptr == "rz"
        then &n.rz as Ref of ?

        else if ptr == "rpx" 
        then &n.rpx as Ref of ?
	else if ptr == "rpy"
        then &n.rpy as Ref of ?
	else if ptr == "rpz"
        then &n.rpz as Ref of ?

        else if ptr == "spx" 
        then &n.spx as Ref of ?
	else if ptr == "spy"
        then &n.spy as Ref of ?
	else if ptr == "spz"
        then &n.spz as Ref of ?

        else if ptr == "rptx" 
        then &n.rptx as Ref of ?
	else if ptr == "rpty"
        then &n.rpty as Ref of ?
	else if ptr == "rptz"
        then &n.rptz as Ref of ?

        else if ptr == "sptx" 
        then &n.sptx as Ref of ?
	else if ptr == "spty"
        then &n.spty as Ref of ?
	else if ptr == "sptz"
        then &n.sptz as Ref of ?

        else if ptr == "tmrpx" 
        then &n.tmrpx as Ref of ?
	else if ptr == "tmrpy"
        then &n.tmrpy as Ref of ?
	else if ptr == "tmprz"
        then &n.tmrpz as Ref of ?
        else super.getPointer(ptr, target)
    }

    override function toNode from (m is MaModel) to Node 
    {
	const tn = MaTransform {

	    visible: visible;

	    id: name

	    tx: t.x;
	    ty: t.y;
	    tz: t.z;

	    sx: s.x;
	    sy: s.y;
	    sz: s.z;

	    rx: r.x;
	    ry: r.y;
	    rz: r.z;

	    ro: ro;

	    rpx: rp.x;
	    rpy: rp.y;
	    rpz: rp.z;

	    spx: sp.x;
	    spy: sp.y;
	    spz: sp.z;

	    rptx: rpt.x;
	    rpty: rpt.y;
	    rptz: rpt.z;

	    sptx: spt.x;
	    spty: spt.y;
	    sptz: spt.z;

	    tmrpx: tmrp.x;
	    tmrpy: tmrp.y;
	    tmrpz: tmrp.z;
	}
	m.spatialMap.put(this, tn);
	const p = m.toParentNode(parent as MSpatial);
	insert tn into p.content;
	return tn;
    }
}

class MCamera is MSpatial 
{
    var ortho is Boolean = false;
    var hfa is Number = 2.4;
    var vfa is Number = 3.6;
    var fcp is Number = 1000;
    var ncp is Number = .1;
    var fl is Number = 35.0;
    var ow is Number = 10.0;
    var lsr is Number = 1.0;
    var ff is Number = 1.0;

    override function setAttr from (cmd is Command) to () 
    {
	const attr = cmd.getAttr();
	if (attr == "o") {
	    ortho = true;
	} else if (attr == "cap") {
	    const v = cmd.getVec3();
	    vfa = v.x;
	    hfa = v.y;
	} else if (attr == "hfa") {
	    hfa = cmd.getFloat();
	} else if (attr == "vfa") {
	    vfa = cmd.getFloat()
	} else if (attr == "fcp") {
	    fcp = cmd.getFloat()
	} else if (attr == "ncp") {
	    ncp = cmd.getFloat()
	} else if (attr == "ow") {
	    ow = cmd.getFloat()
	} else if (attr == "fl") {
	    fl = cmd.getFloat()
	} else if (attr == "lsr") {
	    lsr = cmd.getFloat()
	} else if (attr == "ff") {
	    ff = cmd.getFloat();
	} else super.setAttr(cmd);
    }

    override function toNode from (m is MaModel) to Node 
    {
	const n = 
	    if (ortho) {
		null
	    } else {
		if (ff == 1) {
		    const horizontalAngle = Math.toDegrees(2.0*Math.atan(25.4 * hfa*lsr / 2.0 / fl));
		    PerspectiveCamera {
			id: name;
			near: ncp;
			far: fcp;
			override var widthAngle = horizontalAngle;
			override var heightAngle = bind PerspectiveCamera.widthAngleToHeightAngle(widthAngle, aspectRatio);
		    }
		} else {
		    const verticalAngle = Math.toDegrees(2.0*Math.atan(25.4 * vfa / 2.0 / fl));
		    PerspectiveCamera {
			id: name;
			near: ncp;
			far: fcp;
			heightAngle: verticalAngle;
		    }
		}
	    }
	//println("camera {name} => {n}");
	m.spatialMap.put(this, n);
	const p = m.toParentNode(parent as MSpatial);
	insert n into p.content;
	return n;
    }
}

class MJoint is MTransform {
    // TBD
}

class MCharacter is MNode {

    function resolveTargetPointer from (m is MaModel, toThis is Connection) to Ref of ?
    {
	// toThis connects to one of my inputs; forward to the corresponding connection 
	for (conn in connectionsFromThis.get(toThis.targetPath)) {
	    const ptr = m.resolveTargetPointer(conn);
	    if (ptr <> null) return ptr;
	    println("failed to resolve target {toThis.targetPath} using {conn}");
	}
	return null;
    }

    function resolveSourcePointer from (m is MaModel, toThis is Connection) to Ref of ?
    {
	// toThis connects to one of my inputs; forward to the corresponding connection 
	for (conn in connectionsToThis.get(toThis.targetPath)) {
	    const ptr = m.resolveSourcePointer(conn);
	    if (ptr <> null) return ptr;
	    println("failed to resolve source {toThis.targetPath} using {conn}");
	}
	return null;
    }
}

class UVData {
    public var uvSet is Integer;
    public var uvIndices is Integer[]; 
    override function toString to String {
	"UVData: {uvSet}, uvIndices: {uvIndices}";
    }
}

class PolyfaceData {
    public var faceEdges is Integer[];
    public var holes is Integer[];
    public var mu is UVData;

    function getUV from (uvIndex is Integer) to Integer {
	if (mu == null) return 0;
	return mu.uvIndices[uvIndex];
    }

    override function toString to String {
	"faceEdges: {faceEdges}, holes: {holes}, mu: {mu}";
    }
}

// attribute structure paths
class PathNode {
}

class Index is PathNode {
    const index is Integer;
    override function toString to String {
	"[{index}]"
    }
}

class Field is PathNode {
    const name is String;
    override function toString to String {
	".{name}"
    }
}

class Range is PathNode {
    const startIndex is Integer;
    const endIndex is Integer;
    override function toString to String {
	"[{startIndex}:{endIndex}]"
    }
}

class Path {
    const path is PathNode[];
    override function toString to String {
	"{path}"
    }
}

function parsePath from (path is String) to Path
{
    const izer = new java.util.StringTokenizer(path, ".[]:", true);
    var result is PathNode[];
    while (izer.hasMoreTokens()) {
	const elem = izer.nextToken();
	var pnode is PathNode;
	if (elem == "[") {
	    const i1 = izer.nextToken();
	    const t = izer.nextToken();
	    var i2 is String = null;
	    if (t == ":") { 
		i2 = izer.nextToken();
		izer.nextToken(); // ignore "]"
		pnode = Range {
		    startIndex: Integer.parseInt(i1);
		    endIndex: Integer.parseInt(i2);
		}
	    } else {
		pnode = Index {
		    index: Integer.parseInt(i1);
		}
	    }
	} else if (elem == ".") {
	    pnode = Field {
		name: izer.nextToken()
	    }
	} else {
	    pnode = Field {
		name: elem;
	    }
	}
	insert pnode into result;
    }
    return Path {path: result};
}

class UVSet {
    const uvIndex is Integer;
    const uvs is Number[];
    override function toString to String {
	"uvSet: {uvIndex}, uvs: {uvs}";
    }
}

class ComponentList {
    const faceStart is Integer;
    const faceEnd is Integer;
}

class MMesh is MSpatial 
{
    var components is ComponentList[];
    var verts is Number[];
    var pointTweaks is Number[];
    var normals is Number[];
    var edges is Integer[];
    var polyfaces is PolyfaceData[];
    var uvSets is UVSet[];
    var faceNormals is Vec3[];

    function faceEdgeIndex from (i is Integer) to Integer 
    {
	if (i < 0) then -i-1 else i;
    }
    
    function edgeStart from (faceEdge is Integer) to Integer {
	faceEdgeToEdge(faceEdge, true);
    }

    function edgeEnd from (faceEdge is Integer) to Integer {
	faceEdgeToEdge(faceEdge, false);
    }

    function faceEdgeToEdge(faceEdge is Integer, 
			    fromStart is Boolean) to Integer 
    {
	const bwd = faceEdge < 0;
	const i = faceEdgeIndex(faceEdge); 
	const j = if (bwd == fromStart) then 1 else 0;
	edges[i*3+j];
    }
    
    function isSmooth from (faceEdge is Integer) to Boolean 
    {
	const i = faceEdgeIndex(faceEdge);
	edges[i*3+2] != 0
    }

    function uv from (uvSet is Integer, uvIndex is Integer) to Point2
    {
	const uvs = uvSets[uvSet].uvs;
	const i0 = uvIndex * 2;
	const i1 = i0+1;
	point(uvs[i0], uvs[i1]);
    }
    
    function vertex from (i is Integer) to Point3 
    {
	const i0 = 3*i;
	const i1 = i0+1;
	const i2 = i1+1;
	point(verts[i0] + pointTweaks[i0],
	      verts[i1] + pointTweaks[i1],
	      verts[i2] + pointTweaks[i2])
    }

    function normal from (i is Integer) to Vec3 
    {
	const i0 = 3*i;
	const i1 = i0+1;
	const i2 = i1+1;
	vector(normals[i0],
	       normals[i1],
	       normals[i2])
    }

    const edgeToNormal = new java.util.TreeMap of (Integer, Vec3);

    function buildMesh
    {
	//	println("buildMesh {name}: normals: {normals} polyfaces = {polyfaces}");
	println("buildMesh {name}: verts {verts.size()} norms {normals.size()} polyfaces {polyfaces.size()} uvSets {uvSets.size()}");
	for (polyface in polyfaces) {
	    var norm = Vec3.<<0>>;
	    const faceEdges = polyface.faceEdges;
	    for (faceEdge in faceEdges) {
		const i = indexof faceEdge;
		const edge = edgeStart(faceEdge);
		const next = edgeEnd(faceEdge);
		const prev = edgeStart(faceEdges[(i + faceEdges.size()-1) mod faceEdges.size()]);
		const v0 = vertex(edge);
		const v1 = vertex(next);
		const v2 = vertex(prev);
		norm += (v1 - v0).cross(v2 - v0);
	    }
	    norm = norm.normalize();
	    insert norm into faceNormals;
	}
	const edgeToFace1 = new java.util.TreeMap of (Integer, Integer[]);
	for (f in polyfaces) {
	    const faceIndex = indexof f;
	    for (faceEdge in f.faceEdges) {
		if (isSmooth(faceEdge)) {
		    const e0 = edgeStart(faceEdge);
		    const e1 = edgeEnd(faceEdge);
		    edgeToFace1.put(e0, [faceEdge, faceIndex]);
		    edgeToFace1.put(e1, [faceEdge, faceIndex]);
		}
	    }
	}
	const stack = new java.util.Stack of Integer;
	const edgeToFace2 = new java.util.TreeMap of (Integer, Integer[]);
	while (edgeToFace1.size() > 0) {
	    const ent = edgeToFace1.pollFirstEntry();
	    const edge1 = ent.getKey();
	    const indices1 = ent.getValue();
	    var faces is Integer[];
	    const faceEdge = indices1[0];
	    const faceIndex = indices1[1];
	    stack.push(faceIndex);
	    stack.push(faceEdge);
	    while (not stack.isEmpty()) {
		const faceEdge1 = stack.pop();
		const faceIndex1 = stack.pop();
		insert faceIndex1 into faces;
		const iter = edgeToFace1.entrySet().iterator();
		while (iter.hasNext()) {
		    const n = iter.next();
		    const edge2 = n.getKey();
		    const indices2 = n.getValue();
		    const faceEdge2 = indices2[0];
		    const faceIndex2 = indices2[1];
		    if (faceEdge1 == faceEdge2 or faceIndex1 == faceIndex2) {
			stack.push(faceIndex2);
			stack.push(faceEdge2);
			iter.remove();
		    }
		}
	    }
	    edgeToFace2.put(edge1, faces);
	}
	for (f in polyfaces) {
	    const faceIndex = indexof f;
	    for (faceEdge in f.faceEdges) {
		const edge = edgeStart(faceEdge);
		const faces = edgeToFace2.get(edge);
		if (faces == []) {
		    //edgeToNormal.put(edge, this.normal(faceIndex));
		} else {
		    var norm = Vec3.<<0>>;
		    for (j in faces) {
			const faceNorm = faceNormals[j];
			norm += faceNorm;
		    }
		    edgeToNormal.put(edge, norm);
		}
	    }
	}
    }

    function getMesh to AbstractMesh[]
    {
	if (components == []) {
	    components = [ComponentList {
		    faceStart: 0;
		    faceEnd: polyfaces.size();
		}];
	}
	foreach (comp in components) {
	    this.ib.clear();
	    this.vb.clear();
	    this.nb.clear();
	    this.uvb.clear();
	    const startIndex = comp.faceStart;
	    const endIndex = comp.faceEnd;
	    for (i in [startIndex..<endIndex]) {
		const f = polyfaces[i];
		const mu = f.mu;
		const edge0 = edgeStart(f.faceEdges[0]);
		const norm0 = i;
		const uv0 = f.getUV(0);
		var edge1 = edgeStart(f.faceEdges[1]);
		var norm1 = i;
		var uv1 = f.getUV(1);
		for (j in [2..<f.faceEdges.size()]) {
		    insertVertex(edge0, norm0, mu.uvSet, uv0);
		    insertVertex(edge1, norm1, mu.uvSet, uv1);
		    const edge2 = edgeStart(f.faceEdges[j]);
		    const norm2 = i;
		    const uv2 = f.getUV(j);
		    insertVertex(edge2, norm2, mu.uvSet, uv2);
		    edge1 = edge2;
		    norm1 = norm2;
		    uv1 = uv2;
		}
	    }
	    const ib = this.ib.getBuffer();
	    const vb = this.vb.getBuffer();
	    const nb = this.nb.getBuffer();
	    const uvb = this.uvb.getBuffer();
	    const tanb = BufferUtils.createVector3Buffer(ib.limit());
	    const binb = BufferUtils.createVector3Buffer(ib.limit());
	    ImportUtils.addTangentBinormalStreams(ib, vb, uvb,nb, tanb, binb);
	    MeshBuffer {
		indexBuffer: ib;
		vertexBuffer: MeshBuffer.VertexAttributeBuffer { coordsPerVertex: 3, buffer: vb };
		normalBuffer: MeshBuffer.VertexAttributeBuffer { coordsPerVertex: 3, buffer: nb };
		textureBuffers: [MeshBuffer.VertexAttributeBuffer { coordsPerVertex: 2, buffer: uvb },
				 MeshBuffer.VertexAttributeBuffer { coordsPerVertex: 3, buffer: tanb },
				 MeshBuffer.VertexAttributeBuffer { coordsPerVertex: 3, buffer: binb }];
	    }.toMesh();
	}
    }

    const ib = new IntBufferBuilder();
    const vb = new FloatBufferBuilder();
    const nb = new FloatBufferBuilder();
    const uvb = new FloatBufferBuilder();

    function insertVertex
	from (edge is Integer, face is Integer, uvSet is Integer, uvIndex is Integer) 
	to ()
    {
	const v = this.vertex(edge);
	const n = 
	    if (normals <> []) 
		then this.normal(edge) 
		else if (edgeToNormal.containsKey(edge)) 
		    then edgeToNormal.get(edge) 
		    else faceNormals[face];
	const uv = this.uv(uvSet, uvIndex);
	ib.add(ib.getBufferSize());
	vb.add(v.x, v.y, v.z);
	nb.add(n.x, n.y, n.z);
	uvb.add(uv.x, uv.y);
    }

    override function setAttr from (cmd is Command) to () 
    {
	super.setAttr(cmd);
	const n = cmd.getAttr();
	if (n == "vt") {
	    const path = cmd.getPath();
	    const values = cmd.getFlatFloat3Array();
	    if (path.path[1] instanceof Range) {
		const r = path.path[1] as Range;
		verts[r.startIndex*3..r.endIndex*3] = values;
	    } else {
		verts = values;
	    }
	} else if (n == "pt") {
	    const path = cmd.getPath();
	    const values = cmd.getFlatFloat3Array();
	    if (path.path[1] instanceof Range) {
		const r = path.path[1] as Range;
		pointTweaks[r.startIndex*3..r.endIndex*3] = values;
	    } else {
		pointTweaks = values;
	    }
	} else if (n == "n") {
	    const path = cmd.getPath();
	    println("NORMAL PATH={path.path[1]}");
	    const values = cmd.getFlatFloat3Array();
	    for (v in values) {
		if (v > 1e10) { // bogus normals
		    normals = [];
		    return;
		}
	    }
	    if (path.path[1] instanceof Range) {
		const r = path.path[1] as Range;
		normals[r.startIndex*3..r.endIndex*3] = values;
	    } else {
		normals = values;
	    }
	} else if (n == "ed") {
	    const path = cmd.getPath();
	    const values = cmd.getFlatInt3Array();
	    if (path.path[1] instanceof Range) {
		const r = path.path[1] as Range;
		edges[r.startIndex*3..r.endIndex*3] = values;
	    } else {
		edges = values;
	    }
	} else if (n == "fc") {
	    const path = cmd.getPath();
	    const values = cmd.getPolyfaceData();
	    if (path.path[1] instanceof Range) {
		const r = path.path[1] as Range;
		polyfaces[r.startIndex..r.endIndex] = values;
	    } else {
		polyfaces = values;
	    }
	} else if (n == "iog") {
	    const path = cmd.getPath();
	    const index = path.path[1] as Index;
	    const field = path.path[2] as Field;
	    if (field.name == "og") {
		const ogIndex = path.path[3] as Index;
		const gcl = path.path[4] as Field;
		if (gcl.name == "gcl") {
		    const componentList = cmd.getStringArray();
		    for (comp in componentList) {
			const compPath = parsePath(comp);
			println("compPath={compPath}");
			if (compPath.path[0] is Field) {
			    const f = compPath.path[0] as Field;
			    if (f.name == "f") {
				const compList is ComponentList = 
				    if (compPath.path[1] instanceof Range) {
					const fr = compPath.path[1] as Range;
					ComponentList {
					    faceStart: fr.startIndex;
					    faceEnd: fr.endIndex;
					} 
				    } else {
					const fi = compPath.path[1] as Index;
					ComponentList {
					    faceStart: fi.index;
					    faceEnd: fi.index;
					} 
				    };
				insert compList into components;
			    }
			}
		    }
		}
	    }
	} else if (n == "uvst") {
            // uv sets
	    const path = cmd.getPath();
	    const index = path.path[1] as Index;
	    const field = path.path[2] as Field;
	    if (field.name == "uvsp") {
		const range = path.path[3] as Range;
		const uvIndex = index.index;
		const values = cmd.getFlatFloat2Array();
		if (uvSets[uvIndex] == null) {
		    insert UVSet {
			uvIndex: uvIndex;
			uvs: values;
		    } into uvSets;
		} else {
		    uvSets[uvIndex].uvs[range.startIndex*2..range.endIndex*2] = values;
		}
	    }
	}
    }

    override function toNode from (m is MaModel) to Node 
    {
	buildMesh();
	const p = m.toParentNode(parent as MSpatial);
	var id = "";
	var r0 is Node;
	for (mesh in getMesh()) {
	    const shaderConn = connectionsFromThis.get("iog");
	    const mshaderNode = 
		if (shaderConn <> null) {
		    println("shaderConn={shaderConn}");
		    println("shaderConn={shaderConn[0].targetNode}");
		    println("shaderConn={shaderConn[0].targetNode.connectionsToThis}");
		    println("shader = {shaderConn[0].targetNode.connectionsToThis.get("ss")[0].sourceNode}");
		    shaderConn[0].targetNode.connectionsToThis.get("ss")[0].sourceNode as MAbstractShader;
		} else null;
	    const shader = m.toShader(mshaderNode);
	    println("shaderNode={mshaderNode} for {name} => {shader}");
	    const r = MeshNode {
		//visible: visible;
		id: "{name}{id}";
		mesh: mesh;
		shader: shader;
	    }
	    id = "#{indexof mesh +1}";
	    insert r into p.content;
	    r0 = r;
	    m.spatialMap.put(this, r);
	}
	return r0;
    }
}

abstract class MAbstractShader is MNode {
    abstract function toShader from (m is MaModel) to Shader;
}

class MCGFXShader is MAbstractShader 
{
    var t is String; // technique
    var s is String; // shader
    var vals is String[];
    var vas is String[];

    override public function getPointer
	from (ptr is String, target is Object) 
	to Ref of ?
    {
	const shader = target as Shader;
	return shader.getParameter(ptr);
    }

    override function setAttr from (cmd is Command) to () 
    {
	const n = cmd.getAttr();
	if (n == "val") {
	    vals = cmd.getStringArray();
	} else if (n == "vas") {
	    vas = cmd.getStringArray();
	} else if (n == "s") {
	    s = cmd.getString();
	} else if (n == "t") {
	    t = cmd.getString();
	} else super.setAttr(cmd);
    }

    override function toShader from (m is MaModel) to Shader
    {
	const baseURL = new java.net.URL(m.url);
	var shader = m.effectLoader.loadEffect(new java.net.URL(baseURL, s).toString(), t);
	m.shaderMap.put(this, shader);
	for (conns in connectionsToThis.values()) {
	    for (conn in conns) {
		if (conn.sourceNode instanceof MFile) {
		    const file = conn.sourceNode as MFile;
		    const paramName = conn.targetPath;
		    const p = shader.getParameter(paramName) as Shader.Parameter of AbstractTexture;
		    const image = m.imageLoader.loadImage(new java.net.URL(baseURL, file.ftn).toString());
		    p.set(image);
		}
	    }
	}
	var uvs is Integer[];
	for (i in [0..<vals.size() step 4]) {
	    const n = vals[i];
	    const t = vals[i+1];
	    const sem = vals[i+3];
	    if (sem.startsWith("TEXCOORD")) {
		const unit = Integer.parseInt(sem.substring(8));
		for (j in [uvs.size()..unit]) {
		    insert 0 into uvs;
		}
		const name = vas[1+(i-1) / 4];
		if (name.startsWith("uv:map")) {
		    const uvIndex = Integer.parseInt(name.substring(6))-1;
		    uvs[unit] = uvIndex;
		} else if (name.startsWith("binormal:map")) {
		    uvs[unit] = 1;
		} else if (name.startsWith("tangent:map")) {
		    uvs[unit] = 2;
		}
	    }
	}
	for (attr in attrs.values() where attr.parent == null) {
	    if (attr.value <> null) {
		var name = attr.shortName;
		var value = attr.value;
		//println("setting {name} {attr.type} to {value}");
		try {
		    shader.setParameter(name, value);
		} catch (e is java.lang.Exception) {
		    e.printStackTrace();
		}
	    }
	}
	shader.uvMap = uvs;
	return shader;
    }
}


class CGFXVectorNode is Node {
    public var wv is Tuple3;
    public var wvw is Number;
}

class MCGFXVector is MSpatial {
    
    var wv is Tuple3 = Tuple3.<<0>>;
    var wvw is Number;

    override function setAttr from (cmd is Command) to () 
    {
	const n = cmd.getAttr();
	if (n == "wv") {
	    wv = cmd.getVec3();
	} else if (n == "wvw") {
	    wvw = cmd.getFloat();
	} else super.setAttr(cmd);
    }

    override public function getPointer
	from (ptr is String, target is Object) 
	to Ref of ?
    {
	const n = target as CGFXVectorNode;
	if (ptr == "wv") {
	    return &n.wv;
	} else if (ptr == "wvw") {
	    return &n.wvw;
	} else if (ptr == "m") {
	    return &n.transform;
	} else {
	    return null
	}
    }

    override function toNode from (m is MaModel) to Node {
	var n is Node;
	m.spatialMap.put(this, null);
	for (conn in connectionsToThis.get("m")) {
	    if (conn.sourcePath == "wm") {
		n = (conn.sourceNode as MSpatial).toNode(m);
	    }
	}
	const vecNode = CGFXVectorNode {
	    id: name;
	    wvw: wvw;
	    wv: bind n.sceneTransform.getTranslation();
	}
	m.spatialMap.put(this, vecNode);
	for (conn in connectionsFromThis.get("wv")) {
	    if (conn.targetNode instanceof MCGFXShader) {
		var shader = m.toShader(conn.targetNode as MCGFXShader);
		const p = shader.getParameter(conn.targetPath);
		p.bindTo(&vecNode.wv);
	    }
	}
	return vecNode;
    }
    
}

class MShader is MAbstractShader 
{
    public const type is String;

    var c is Tuple3 = tuple(0.5, 0.5, 0.5);
    var ambc is Tuple3 =Tuple3.<<0>>;
    var ic is Tuple3 = Tuple3.<<0>>;
    var sc is Tuple3 = Tuple3.<<0>>;
    var dc is Number = 0.8;
    var ec is Number = 0.3;
    var cp is Number = 20.0;
    var it is Tuple3 = Tuple3.<<0>>;

    override function setAttr from (cmd is Command) to () 
    {
	const n = cmd.getAttr();
	if (n == "c") {
	    c = cmd.getVec3();
	} else if (n == "ambc") {
	    ambc = cmd.getVec3();
	} else if (n == "sc") {
	    sc = cmd.getVec3();
	} else if (n == "cp") {
	    cp = cmd.getFloat();
	} else if (n == "ic") {
	    ic = cmd.getVec3();
	} else if (n == "dc") {
	    dc = cmd.getFloat();
	} else if (n == "it") {
	    it = cmd.getVec3();
	} else super.setAttr(cmd);
    }

    function toColor 
	from (r is Number,
	      g is Number,
	      b is Number,
	      a is Number) 
	to Color {
	Color {
	    red: r, green: g, blue: b, opacity: a 
	}
    }

    override function toShader from (m is MaModel) to Shader 
    {
	const alpha = 1.0 - it.x;
	const diffuse = toColor(c.x * dc, c.y * dc, c.z * dc, alpha);
	const ambient = toColor(ambc.x, ambc.y, ambc.z, alpha);
	const emissive = toColor(ic.x, ic.y, ic.z, alpha);
	const specular = toColor(sc.x, sc.y, sc.z, alpha);
	const shininess = if (this.type == "phong") then cp else if (this.type == "blinn") then 100 - 99 * Math.sqrt(ec) else 1;
	var image is AbstractTexture;
	var uvMap is Integer[] = [];
	for (conn in connectionsToThis.get("c")) {
	    if (conn.sourceNode instanceof MFile) {
		const file = conn.sourceNode as MFile;
		const paramName = conn.targetPath;
		const baseURL = new java.net.URL(m.url);
		image = m.imageLoader.loadImage(new java.net.URL(baseURL, file.ftn).toString());
		uvMap = [0];
		break;
	    }
	}
	var shader = m.effectLoader.loadDefaultShader(image,
						      diffuse,
						      ambient,
						      emissive,
						      specular,
						      shininess);
	m.shaderMap.put(this, shader);
	shader.uvMap = uvMap;
	return shader;
    }
}

class MShadingEngine is MNode {
    override function setAttr from (cmd is Command) to () 
    {
	super.setAttr(cmd)
    }
}

class MFile is MNode {
    var ftn is String;
    override function setAttr from (cmd is Command) to () 
    {
	const n = cmd.getAttr();
	if (n == "ftn") {
	    ftn = cmd.getString();
	}
    }
}

class MLight is MSpatial {
    const type is String;
    override public function toNode from (m is MaModel) to Node 
    {
	if (this.type == "pointLight") {
	    const tn = PointLight {}
	    m.spatialMap.put(this, tn);
	    const p = m.toParentNode(parent as MSpatial);
	    insert tn into p.content;
	    return tn;
	}
	return null;
    }
}

// http://download.autodesk.com/global/docs/maya2012/en_us/Nodes/animCurve.html
abstract class MAnimCurve of a is MTemporal 
{
    var kix is Number[];
    var kiy is Number[];
    var kox is Number[];
    var koy is Number[];
    var kit is Integer[];
    var kot is Integer[];

    override function setAttr from (cmd is Command) to () 
    {
	super.setAttr(cmd);
	const n = cmd.getAttr();
	if (n == "kix") {
	    kix = cmd.getFloatArray();
	} else if (n == "kiy") {
	    kiy = cmd.getFloatArray();
	} else if (n == "kox") {
	    kox = cmd.getFloatArray();
	} else if (n == "koy") {
	    koy = cmd.getFloatArray();
	} else if (n == "kit") {
	    kit = cmd.getIntArray();
	} else if (n == "kot") {
	    kot = cmd.getIntArray();
	}
    }

    abstract function toChannel from (m is MaModel) to Channel of a;

}

const FPS = 1s/24.0;

class MAnimCurve__ is MAnimCurve of Number 
{
    var ktv is Vec2[];

    override function setAttr from (cmd is Command) to () 
    {
	super.setAttr(cmd);
	const n = cmd.getAttr();
	if (n == "ktv") {
	    ktv = cmd.getFloat2Array();
	}
    }

    function getInterpolator from (i is Integer) to KeyFrame.NumberInterpolator 
    {
	if (i >= kix.size()) {
	    return KeyFrame.Linear;
	}
	KeyFrame.Tangent {
	    kix: kix[i];
	    kiy: kiy[i];
	    kox: kox[i];
	    koy: koy[i];
	}
    }

    override function toChannel from (m is MaModel) to Channel of Number 
    {
	Channel of Number 
	{
	    id: name;
	    targets: m.getNumberTargets(this, "o");
	    keys:
	    foreach (x in ktv) {
		KeyFrame.Key of Number {
		    position: FPS * (x.x - 1)
		    value: x.y;
		    interpolator: getInterpolator(indexof x);
		}
	    }
	}
    }
}


class Command 
{
    const name is String;
    const args is String[];
    const namedArgs is java.util.Map of (String, String) 
	= new java.util.HashMap of (String, String) ();

    override function toString to String 
    {
	"{name} {foreach (ent in namedArgs.entrySet()) " -{ent.getKey()} {ent.getValue()}"} {foreach (arg in args) " {arg}"}"
    }

    public function getBoolean to Boolean {
	const s = getString(1);
	s == "yes" or s == "true" 
    }

    public function getString to String {
	getString(1)
    }

    public function getInt to Integer 
    {
	getInt(1)
    }

    public function getFloat to Number 
    {
	getFloat(1)
    }

    public function getAttr to String 
    {
	const attr = getString(0);
	const bracket = attr.indexOf("[");
	if (bracket > 0) {
	    return attr.substring(1, bracket);
	}
	return attr.substring(1)
    }

    public function getPath to Path 
    {
	parsePath(getString(0))
    }
    
    public function getFloatArray to Number[] 
    {
	const count = getCount("s", 1);
	foreach (k in [1..count]) getFloat(k)
    }

    public function getStringArray to String[] 
    {
	const count = getInt(1);
	foreach (k in [0..<count]) getString(k+2);
    }

    public function getIntArray to Integer[] 
    {
	const count = getCount("s", 1);
	foreach (k in [1..count]) getInt(k)
    }

    public function getFloat2Array to Vec2[] 
    {
	const count = getCount("s", 2);
	foreach (k in [1..count*2 step 2]) vector(getFloat(k), getFloat(k+1))
    }

    public function getFlatFloat2Array to Number[] 
    {
	const count = getCount("s", 2);
	foreach (k in [1..count*2]) getFloat(k);
    }

    public function getFloat3Array to Vec3[] 
    {
	const count = getCount("s", 3);
	foreach (k in [1..count*3 step 3]) vector(getFloat(k), getFloat(k+1), getFloat(k+2))
    }

    public function getFlatFloat3Array to Number[] 
    {
	const count = getCount("s", 3);
	foreach (k in [1..count*3]) getFloat(k)
    }

    public function getFlatInt3Array to Integer[] 
    {
	const count = getCount("s", 3);
	foreach (k in [1..count*3]) getInt(k)
    }

    public function getPolyfaceData to PolyfaceData[] 
    {
	const len = args.size();
	var i = 1;
	var faceData is PolyfaceData[];
	while (i < len) {
	    var cmd = getString(i++);
	    var faceEdges is Integer[];
	    var mu is UVData;
	    var holes is Integer[];
	    var vals is Integer[];
	    if (cmd == "f") {
		const count = getInt(i++);
		for (j in [0..<count]) {
		    insert getInt(i++) into faceEdges;
		}
	    }
	    cmd = getString(i++);
	    if (cmd == "mu") {
		const uvSet = getInt(i++);
		var uvs is Integer[];
		const count = getInt(i++);
		for (j in [0..<count]) {
		    insert getInt(i++) into uvs;
		}
		mu = UVData {
		    uvSet: uvSet;
		    uvIndices: uvs;
		}
	    }
	    insert PolyfaceData {
		faceEdges: faceEdges;
		mu: mu;
	    } into faceData;
	}
	return faceData;
    }

    const NEG = "-".charAt(0);

    function isInt from (idx is Integer) to Boolean 
    {
	const str = getString(idx);
	const len = str.length();
	if (len == 0) {
	    return false;
	}
	var ch = str.charAt(0);
	var i = 0;
	if (ch == NEG) {
	    if (len == 1) {
		return false;
	    }
	    ++i;
	} 
	while (i < len) {
	    if (not Character.isDigit(str.charAt(i++))) {
		return false;
	    }
	}
	return true;
    }

    public function getMatrix to Mat4 {
	Mat4.fromColumns(getFloatArray());
    }

    public function getVec3 to Vec3 
    {
	vector(getFloat(1), getFloat(2), getFloat(3))
    }

    public function getVec2 to Vec2 
    {
	vector(getFloat(1), getFloat(2));
    }

    public function getCount(size is String, width is Integer) to Integer 
    {
	const c = (args.size()-1) / width; 
	const s = getString(size);
	if (s <> null) then Math.min(Integer.parseInt(s), c) else c;
    }

    public function getInt from (key is String) to Integer 
    {
	java.lang.Integer.parseInt(getString(key));
    }

    public function getInt from (i is Integer) to Integer 
    {
	java.lang.Integer.parseInt(getString(i));
    }

    public function getFloat from (key is String) to Number 
    {
	try {
	    return java.lang.Float.parseFloat(getString(key));
	} catch (e) {
	    println("error {this}, key={key}");
	    return 0.0;
	}
    }

    public function getFloat from (i is Integer) to Number 
    {
	try {
	    const str = getString(i);
	    if (str == "nan") {
		return 0;
	    }
	    return java.lang.Float.parseFloat(str);
	} catch (e) {
	    println("error {this}, index={i}");
	    return 0.0;
	}
    }

    public function getString from (key is String) to String 
    {
	trim(namedArgs.get(key));
    }

    public function getString from (i is Integer) to String 
    {
	trim(args[i]);
    }

    public function trim from (s is String) to String 
    {
	if (s.startsWith("\"")) then s.substring(1, s.length()-1) else s;
    }
}

class MaParser 
{
    public var effectLoader is CGEffectLoader;
    public var imageLoader is ImageLoader;
    var pos = 0;
    const buf = new java.lang.StringBuffer;
    var tokens = new java.util.ArrayList of String;
    const cmds = new java.util.ArrayList of Command;

    function flush() {
	if (buf.length() > 0) {
	    tokens.add(buf.toString());
	    buf.setLength(0);
	}
    }

    function consumeUntil(input is String, end is Character) {
	const len = input.length();
	const backslash = "\\";
	const escapes = "ntr";
	const escaped = "\n\t\r";
	while (pos < len) {
	    var ch = input.charAt(pos++);
	    var escape = false;
	    if (backslash.indexOf(ch) == 0) {
		escape = true;
		ch = input.charAt(pos++);
		const i = escapes.indexOf(ch);
		if (i >= 0) {
		    ch = escaped.charAt(i);
		}
	    }
	    buf.append(ch);
	    if (not escape and ch == end) {
		break;
	    }
	}
	flush()
    }

    function tokenize from (s is String) to () 
    {
	const ws = " \r\n\t";
	const quot = "\"";
	const izer = new java.util.StringTokenizer(s, ";");
	while (izer.hasMoreTokens()) {
	    const tok = izer.nextToken();
	    if (tok.startsWith("//")) {
		continue;
	    }
	    buf.setLength(0);
	    var len = tok.length();
	    pos = 0;
	    while (pos < len) {
		const ch = tok.charAt(pos++);
		if (ws.indexOf(ch) >= 0) {
		    flush();
		} else if (quot.indexOf(ch) == 0) {
		    flush();
		    buf.append(ch);
		    consumeUntil(tok, quot.charAt(0));
		} else {
		    buf.append(ch);
		}
	    }
	    flush();
	    if (tokens.size() > 0) {
		const cmd = parseCommand(tokens);
		if (cmd <> null) {
		    cmds.add(cmd);
		}
		tokens.clear();
	    }
	}
    }

    public function parse from (u is java.net.URL) to MaModel 
    {
	const r = new java.io.BufferedReader(new java.io.InputStreamReader(u.openStream()));
	const buf = new java.lang.StringBuffer();
	while (true) {
	    const ch is Integer = r.read();
	    if (ch <= 0) {
		break;
	    }
	    buf.append(ch as Character);
	}
	parse(u.toString(), buf.toString())
    }

    public function parse from (url is String, input is String) to MaModel 
    {
	tokenize(input);
	const model = MaModel {
	    effectLoader: effectLoader;
	    imageLoader: imageLoader;
	    url: url
	}
	model.url = url;
	model.imageLoader = imageLoader;
	for (cmd in cmds) {
	    model.processCommand(cmd)
	}
	model.generateScene();
	return model;
    }

    function parseCommand from (cmds is java.util.List of String) to Command 
    {
	const cmd = Command {
	    name: cmds.get(0);
	}
	var i = 1;
	const len = cmds.size();
	while (i < len) {
	    const s = cmds.get(i++);
	    if (s.startsWith("-") and not java.lang.Character.isDigit(s.charAt(1))) {
		var j = i;
		var v is String = if (i < len) then cmds.get(j++) else "";
		if (v.startsWith("-") and not java.lang.Character.isDigit(v.charAt(1))) {
		    v = null;
		}  else {
		    i = j;
		}
		cmd.namedArgs.put(s.substring(1), v);
	    } else {
		insert s into cmd.args;
	    }
	}
	return cmd
    }
}

const RotateOrder =   
   [0, 1, 2,  // 0=xyz
    1, 2, 0,  // 1=yzx
    2, 0, 1,  // 2=zxy
    0, 2, 1,  // 3=xzy
    1, 0, 2,  // 4=yxz
    2, 1, 0]; // 5=zyx

const axes = [Vec3.X_AXIS, Vec3.Y_AXIS, Vec3.Z_AXIS];

// http://download.autodesk.com/global/docs/maya2012/en_us/Nodes/transform.html
public class MaTransform is Group 
{
    // translation
    public var tx is Number;
    public var ty is Number;
    public var tz is Number;
    // rotation
    public var rx is Number;
    public var ry is Number;
    public var rz is  Number;
    // scale
    public var sx is Number = 1.0;
    public var sy is Number = 1.0;
    public var sz is Number = 1.0;
    // rotate pivot
    public var rpx is Number;
    public var rpy is Number;
    public var rpz is Number;
    // rotate pivot translate
    public var rptx is Number;
    public var rpty is Number;
    public var rptz is Number;
    // scale pivot
    public var spx is Number;
    public var spy is Number;
    public var spz is Number;
    // scale pivot translate
    public var sptx is Number;
    public var spty is Number;
    public var sptz is Number;
    // transMinusRotatePivot
    public var tmrpx is Number;
    public var tmrpy is Number;
    public var tmrpz is Number;
    // rotate order
    public var ro is Integer;

    function rotate 
	from (rx is Number, ry is Number, rz is Number, ro is Integer) 
	to Mat4 
    {
	const angles = [rx, ry, rz];
	var result = Mat4.<<1>>;
	for (i in [0..<3]) { 
	    const j = RotateOrder[i*3+ro]; 
	    result *= axes[j].rotate(angles[j]);
	}
	return result;
    }

    // translation
    public readonly var t is Vec3 = bind vector(tx, ty, tz);
    // rotation
    public readonly var r is Mat4 = bind rotate(rx, ry, rz, ro);
    // scale
    public readonly var s is Vec3 = bind vector(sx, sy, sz);
    
    override var transform = 
        bind 
	translate(tx+rpx+rptx, 
		  ty+rpy+rpty, 
		  tz+rpz+rptz) * 
	r *
	translate(-rpx+spx, 
		  -rpy+spy, 
		  -rpz+spz) *
	scale(sx, sy, sz) *
	translate(-spx, 
		  -spy, 
		  -spz);
}

// http://download.autodesk.com/global/docs/maya2012/en_us/Nodes/joint.html

function dumpScene (spatialRoot is Node) 
{
    println(spatialRoot.foldLeft("", function from (y is String, x is Node) to String 
				 {
				     if (y == "") 
					 then "{x.id} =\n{x.transform}" 
					 else "{y}\n{x.id} {x.getClass()} =\n{x.transform}";
				 }));
}

class ModelContent {
    public var spatial is Node;
    public var temporal is TimeNode;
    public var cameras is Camera[];
}

public class Model {

    public var url is String;
    public const effectLoader is CGEffectLoader = the CGEffectLoader;
    public const imageLoader is ImageLoader = the ImageLoader;

    public bound function getCameras to Camera[]
    {
	modelContent.cameras;
    }

    public bound function getSpatialRoot to Node 
    {
	modelContent.spatial;
    }

    public bound function getTemporalRoot to TimeNode 
    {
	modelContent.temporal;
    }

    readonly var modelContent is ModelContent = bind load(url, effectLoader, imageLoader); 

    function load from (url is String, effectLoader is CGEffectLoader, imageLoader is ImageLoader) to ModelContent 
    {
	const p = MaParser {effectLoader: effectLoader, imageLoader: imageLoader};
	const m = p.parse(new java.net.URL(url));
	m.spatialRoot.updateParent();
	const r = ModelContent {
	    spatial: m.spatialRoot;
	    temporal: m.temporalRoot;
	    cameras: m.getCameras();
	}
	return r;
    }
}

public function run from (args is String[]) to () 
{
    const p = MaParser {};
    const m = p.parse(new java.net.URL(args[0]));
}

