package f3.media.scene;
import jassimp.*;
import jassimp.AiPostProcessSteps.*;
import f3.media.scene.*;
import f3.media.scene.meshdeform.*;
import f3.media.scene.MeshBuffer.*;
import f3.media.scene.KeyFrame.*;
import f3.media.scene.Channel.*;
import f3.math.*;
import f3.math.LinearMath.*;

const DISABLE_DEFORMERS = Boolean.getBoolean("f3.assimp.disable.deformers");

class WeightList {
    public var w is Number[];
}

class IntList {
    public var i is Integer[];
}

public class NumberKey is Key of Number {
    override var interpolator = KeyFrame.Linear;
}

function findFile from (dir is java.io.File, name is String) to java.io.File
{
    if (dir == null) return null;
    println("searching for {name} in {dir}");
    const isPsd = name.endsWith(".psd"); // hacks for unity fbx
    const baseName = {
        const dot = name.lastIndexOf(".");
        if (dot > 0) then name.substring(0, dot) else name;
    };
    for (f in dir.listFiles()) {
        if (not f.isDirectory()) {
            if (f.getName().equalsIgnoreCase(name)) {
                return f;
            }
        }
    }
    return null;
}

const QuatLinear is KeyFrame.Interpolator = KeyFrame.Interpolator of Quat {
    override var zero = Quat.<<1>>;
    override function interpolate from (k is Key of Quat, t is Number) to Quat 
    {
	const r = if (k.prev == null) then k.value else k.prev.value.slerp(k.value, t).normalize();
        println("interpolated {k.prev.value.toAngles()} @{t} {k.value.toAngles()} to {r.toAngles()}");
        return r;
    }
    override function scale from (x is Quat, weight is Number) to Quat
    {
        Quat.<<1>>.slerp(x, weight);
    }
    override function add from (x is Quat, y is Quat) to Quat 
    {
        x * y
    }
}

public class QuatKey is KeyFrame.Key of Quat {
    override var interpolator = QuatLinear;
}

public class QTransformNode extends Group {
    public var tx is Number;
    public var ty is Number;
    public var tz is Number;
    public var sx is Number = 1.0;
    public var sy is Number = 1.0;
    public var sz is Number = 1.0;
    public var rx is Number = 0.0;
    public var ry is Number = 0.0;
    public var rz is Number = 0.0;
    public var r is Quat = Quat.<<1>>;
    public var initialTransform is Mat4;
    override var transform = bind translate(tx, ty, tz) * rotate(rx, ry, rz) * r.toMat4() * scale(sx, sy, sz) * initialTransform;
}

class Loader {
    var resources = new java.util.HashSet of String;
    const imageLoader is ImageLoader;
    const effectLoader is CGEffectLoader;
    const filename is String;
    const defaultShader = 
        effectLoader.loadDefaultShader(null,
                                       Color.GRAY,
                                       Color.BLACK,
                                       Color.BLACK,
                                       Color.BLACK,
                                       0);
    
    function importFile from (filename is String) to AiScene
    {
        try {
            
            const r = 
                Jassimp.importFile(filename, 
                                   java.util.EnumSet.<<of>>(CALC_TANGENT_SPACE, 
                                                            GEN_SMOOTH_NORMALS, 
                                                            //JOIN_IDENTICAL_VERTICES, 
                                                            TRIANGULATE, 
                                                            //OPTIMIZE_MESHES,
                                                            //SPLIT_LARGE_MESHES,
                                                            //SORT_BY_PTYPE,
                                                            //DEBONE,
                                                            GEN_UV_COORDS));
            println("Meshes: {r.getNumMeshes()}");
            println("Anims: {r.getNumAnimations()}");
            return r;
        } catch (e is java.lang.Exception) {
            println(Jassimp.getErrorString());
            throw new java.lang.RuntimeException(Jassimp.getErrorString());
        }
    }
    const scene = importFile(filename);
    const wrapper = new AiBuiltInWrapperProvider();
    const cameraMap is java.util.Map of (String, AiCamera) = {
        const map = new java.util.HashMap of (String, AiCamera);
        for (cam in scene.getCameras()) map.put(cam.getName(), cam);
        map;
    }
    const lightMap is java.util.Map of (String, AiLight) = {
        const map = new java.util.HashMap of (String, AiLight);
        for (light in scene.getLights()) map.put(light.getName(), light);
        map;
    }
    function toColor from (c is AiColor) to Color
    {
        println("TO COLOR {c}");
        Color.color(c.getRed(), c.getGreen(), c.getBlue(), c.getAlpha());
    }
    const shaders = foreach (mat in scene.getMaterials()) {
        var d = mat.getDiffuseColor(wrapper);
        var a = mat.getAmbientColor(wrapper);
        var s = mat.getSpecularColor(wrapper);
        var e = mat.getEmissiveColor(wrapper);
        var t = mat.getTransparentColor(wrapper);
        var r = mat.getReflectiveColor(wrapper);
        var diffuseCount = mat.getNumTextures(AiTextureType.DIFFUSE);
        var diffuseTex = if (diffuseCount > 0) then {
                const textureFilename = mat.getTextureFile(AiTextureType.DIFFUSE, 0).replace("\\", "/");
                const dir = new java.io.File(filename).getParentFile();
                const actual = new java.io.File(dir, textureFilename);
                const finalFilename = if (actual.exists()) then actual else {
                        const fname = actual.getName();
                        const imgFile = findFile(dir, fname);
                        if (imgFile == null) then findFile(dir.getParentFile(), fname) else imgFile;
                    };
                println("texture file: {textureFilename} => {finalFilename.toURI().toString()}");
                const tex = if (finalFilename == null) then null else imageLoader.loadImage(finalFilename.toURI().toString());
                println("tex=>{tex} loader={imageLoader}");
                if (tex <> null) {
                    resources.add(finalFilename.toURI().toString());
                }
                tex;
            } else null;
        var shininess = mat.getShininessStrength();
        const sh = if (diffuseTex == null) {
            effectLoader.loadDefaultShader(diffuseTex,
                                           toColor(d),
                                           toColor(a),
                                           Color.BLACK,//toColor(e),
                                           toColor(s),
                                           shininess);
        } else {
            effectLoader.loadDefaultShader(diffuseTex,
                                           Color.WHITE,
                                           Color.BLACK,//toColor(a),
                                           Color.BLACK,//toColor(e),
                                           toColor(s),
                                           shininess);
        };
        sh.id = mat.getName();
        sh;
    }
    const meshes = foreach (m in scene.getMeshes()) generateMesh(m);
    const root = scene.getSceneRoot(wrapper);
    const spatialRoot = generateScene(root);

    function generateAllDeformers to ()
    {
        spatialRoot.updateParent();
        foreach (i in [0..<scene.getMeshes().size()]) {
            const mesh = meshes[i];
            spatialRoot.foldLeft((), function from (_ is (), n is Node) to () {
                    if (n is MeshNode) {
                        const mn = n as MeshNode;
                        if (mn.mesh == mesh) {
                            const d = generateDeformer(mn, i);
                            insert d into mn.deformers;
                        }
                    }
                });
        }
    }

    const clips = foreach (x in scene.getAnimations()) TimeGroup {
        var ticksPerSecond = x.getTicksPerSecond() as Number;
        var tick = 1s / (if (ticksPerSecond == 0) then 24 else ticksPerSecond);
        id: x.getName();
        var content = foreach (ch in x.getChannels())  {

            const qs is Tuple3[] = {
                var tmp is Tuple3[];
                for (i in [0..<ch.getNumRotKeys()]) {
                    const q0 = ch.getRotKeyQuaternion(i, wrapper);
                    const q1 = new Quat(q0.getX(), q0.getY(), q0.getZ(), q0.getW());
                    const t = q1.toAngles(Quat.EULER_ZYX);
                    //println("rot key at {i} = {t}, {q1.toAngles()}");
                    insert t into tmp;
                }
                tmp;
            };

            var target is QTransformNode = sceneRoot.lookup(ch.getNodeName()) as QTransformNode;
            if (target == null) {
                target = spatialRoot.lookup(ch.getNodeName()) as QTransformNode;
            }
            ///println("{x.getName()} animation target {ch.getNodeName()} => {target}, t={ch.getNumPosKeys()}, s={ch.getNumScaleKeys()}, r={ch.getNumRotKeys()}");
            //println("initialTransform was:");
            //println(target.initialTransform);
            target.initialTransform = Mat4.<<1>>;
            [if (ch.getNumPosKeys() > 0) {
                [Channel of Number {
                        id: "{x.getName()}#tx"
                        targets: &target.tx;
                        keys: 
                        foreach (i in [0..<ch.getNumPosKeys()]) {
                            NumberKey {
                                position: tick * ch.getPosKeyTime(i);
                                value: ch.getPosKeyX(i);
                            }
                        }
                    },
                    Channel of Number {
                        id: "{x.getName()}#ty"
                        targets: &target.ty;
                        keys: 
                        foreach (i in [0..<ch.getNumPosKeys()]) {
                            NumberKey {
                                position: tick * ch.getPosKeyTime(i);
                                value: ch.getPosKeyY(i);
                            }
                        }
                    },
                    Channel of Number {
                        id: "{x.getName()}#tz"
                        targets: &target.tz;
                        keys: 
                        foreach (i in [0..<ch.getNumPosKeys()]) {
                            NumberKey {
                                position: tick * ch.getPosKeyTime(i);
                                value: ch.getPosKeyZ(i);
                            }
                        }
                    }];
                } else [],
                if (ch.getNumScaleKeys() > 0) {
                    [Channel of Number {
                        id: "{x.getName()}#sx"
                        targets: &target.sx;
                        keys: 
                        foreach (i in [0..<ch.getNumScaleKeys()]) {
                            NumberKey {
                                position: tick * ch.getScaleKeyTime(i);
                                value: ch.getScaleKeyX(i)
                            }
                        }
                    },
                    Channel of Number {
                        id: "{x.getName()}#sy"
                        targets: &target.sy;
                        keys: 
                        foreach (i in [0..<ch.getNumScaleKeys()]) {
                            NumberKey {
                                position: tick * ch.getScaleKeyTime(i);
                                value: ch.getScaleKeyY(i)
                            }
                        }
                    },
                    Channel of Number {
                        id: "{x.getName()}#sz"
                        targets: &target.sz;
                        keys: 
                        foreach (i in [0..<ch.getNumScaleKeys()]) {
                            NumberKey {
                                position: tick * ch.getScaleKeyTime(i);
                                value: ch.getScaleKeyZ(i);
                            }
                        }
                    }];
                } else [],
                if (ch.getNumRotKeys() > 0) {

                    if true then [Channel of Quat {
                        id: "{x.getName()}#r"
                        targets: &target.r;
                        keys: foreach (i in [0..<ch.getNumRotKeys()]) {
                            QuatKey {
                                position: tick * ch.getRotKeyTime(i);
                                var q0 = ch.getRotKeyQuaternion(i, wrapper);
                                var q1 = new Quat(q0.getX(), q0.getY(), q0.getZ(), q0.getW());
                                value: q1;
                            }
                       }
                    }] else

                [Channel of Number {
                        id: "{x.getName()}#rx"
                        targets: &target.rx;
                        keys: 
                        foreach (i in [0..<ch.getNumRotKeys()]) {
                            NumberKey {
                                position: tick * ch.getRotKeyTime(i);
                                value: qs[i].x;
                            }
                        }
                    },
                    Channel of Number {
                        id: "{x.getName()}#rz"
                        targets: &target.rz;
                        keys: 
                        foreach (i in [0..<ch.getNumRotKeys()]) {
                            NumberKey {
                                position: tick * ch.getRotKeyTime(i);
                                value: qs[i].y;
                            }
                        }
                    },
                    Channel of Number {
                        id: "{x.getName()}#rz"
                        targets: &target.rz;
                        keys: 
                        foreach (i in [0..<ch.getNumRotKeys()]) {
                            NumberKey {
                                position: tick * ch.getRotKeyTime(i);
                                value: qs[i].z;
                            }
                        }
                    }]
                    } else []
                ]
            };
            content: content;
    }
    function toMat4 from (mat is AiMatrix4f) to Mat4
    {
        Mat4.fromRows(foreach (r in [0..<4], c in [0..<4]) mat.get(r, c))
    }

    function generateMesh from (mesh is AiMesh) to AbstractMesh
    {
        const mb = MeshBuffer {
            indexBuffer: mesh.getFaceBuffer();
            vertexBuffer: VertexAttributeBuffer { 
                id: "POSITION";
                coordsPerVertex: 3;
                buffer: mesh.getPositionBuffer();
            }
            normalBuffer: VertexAttributeBuffer { 
                id: "NORMAL";
                coordsPerVertex: 3;
                buffer: mesh.getNormalBuffer();
            }
            textureBuffers: foreach (i in [0..<JassimpConfig.MAX_NUMBER_TEXCOORDS]) {
                const buf = mesh.getTexCoordBuffer(i);
                if (buf == null) then null else {
                        //println("texcoord: {i} {mesh.getNumUVComponents(i)}");
                        VertexAttributeBuffer {
                            id: "TEXCOORD{i}";
                            coordsPerVertex: mesh.getNumUVComponents(i); 
                            buffer: buf;
                        }
                    }
            }
        };
        const result = mb.toMesh();
        println("created mesh {mesh.getName()}: {result.vertices.getVertexCount()}, texCoords: {mb.textureBuffers.size()}");
        result;
    }

    function generateDeformer from (mn is MeshNode, i is Integer) to SkinCluster
    {
        const sceneMesh = scene.getMeshes().get(i);
        if (sceneMesh.hasBones() and sceneMesh.getBones().size() > 1) {
            const mesh = meshes[i];
            const ib = mesh.getIndexBuffer();
            println("generate deformer: tri={sceneMesh.isPureTriangle()} ib={ib.limit()} vert={mesh.getVertexBuffer().limit()}");
            var weights is Number[];
            var pm is Mat4[];
            const map = new java.util.TreeMap of (Integer, WeightList);
            var joints is Node[];
            var jointMats is Mat4[];
            for (x in sceneMesh.getBones()) {
                const jointIndex = indexof x;
                for (wt in x.getBoneWeights()) {
                    const v = wt.getVertexId();
                    var wl = map.get(v);
                    if (wl == null) {
                        wl = WeightList {};
                        map.put(v, wl);
                    }
                    const w = wt.getWeight();
                    insert jointIndex into wl.w;
                    insert w into wl.w;
                }
                // transforms from mesh to bone local space
                const m = x.getOffsetMatrix(wrapper);
                const m1 = toMat4(m);
                // pm is joint world to local at time of bind
                const joint = spatialRoot.lookup(x.getName());
                insert joint into joints;
                //println("mesh:");
                //println(mn.toSceneTransform);
                //println("joint inverse {joint.id}:");
                //println(joint.toSceneTransform.inverse());
                //println("offset:");
                //println(m1);
                insert joint.toSceneTransform.inverse() into pm;
            }
            for (ent in map.entrySet()) {
                const v is Integer = ent.getKey();
                const wl = ent.getValue();
                //for (ii in [0..<wl.w.size() step 2]) {
                //    println("\"wl[{v}].w[{wl.w[ii] as Integer}]\" {wl.w[ii+1]};");                     
                // }
                insert v into weights;
                insert wl.w.size() / 2 into weights;
                insert wl.w into weights;
            }
            const sourceVertices = BufferUtils.clone(mesh.getVertexBuffer());
            const sourceNormals = BufferUtils.clone(mesh.getNormalBuffer());
            const deformer = SkinCluster {
                root: spatialRoot;
                indexBuffer: mesh.getIndexBuffer();
                sourceVertices: sourceVertices;
                sourceNormals: sourceNormals;
                targetVertices: mesh.getVertexBuffer();
                targetNormals: mesh.getNormalBuffer();
                joints: joints;          
                weights: weights;
                bindPreMatrices: pm;
                geomMatrix: Mat4.<<1>>; // already applied by assimp
            }
        } else null
    }

    function generateScene from (x is AiNode) to Node {
        var q is QTransformNode;
        var t = Group {
            id: "{if x == root then url else x.getName()}#wrapper";
            content:
            { 
                q = QTransformNode {
                    initialTransform: toMat4(x.getTransform(wrapper));
                    id: if x == root then url else x.getName();
                    var meshIndices is Integer[] = x.getMeshes();
                    var meshNodes is MeshNode[] = foreach (i in meshIndices) {
                        const sceneMesh = scene.getMeshes().get(i);
                        const mesh = meshes[i];
                        MeshNode 
                        { 
                            id: "{x.getName()}#mesh";
                            shader: shaders[sceneMesh.getMaterialIndex()];
                            mesh: mesh;
                        }
                    }
                    var ac = cameraMap.get(x.getName());
                    var cam = if (ac == null) then null else PerspectiveCamera {
                                id: "{x.getName()}#camera";
                                near: ac.getClipPlaneNear();
                                far: ac.getClipPlaneFar();
                                heightAngle: java.lang.Math.toDegrees(ac.getHorizontalFOV()) * 2;
                            };
                    content: [foreach (c in x.getChildren()) generateScene(c), meshNodes, cam];
                }
            }
        }
        //println("{q.id}:");
        //println(t.transform);
        return t;
    }
}
    
class ModelContent {
    public var resources is String[]; 
    public var spatialRoot is Node;
    public var temporalRoot is TimeNode;
    public var shaders is Shader[];
    public var cameras is Camera[];
    public var lights is PointLight[];
}

public class F3Assimp {
    public var sceneRoot is Node;
    public var url is String;
    public readonly var spatialRoot is Node = bind getSpatialRoot();
    public readonly var temporalRoot is TimeNode = bind getTemporalRoot();
    public bound function getTemporalRoot to TimeNode { modelContent.temporalRoot }
    public const effectLoader is CGEffectLoader = the CGEffectLoader;
    public const imageLoader is ImageLoader = the ImageLoader;
    bound var modelContent is ModelContent = load(url, effectLoader, fileTimestamp);
    public var monitorForChanges is Boolean = false;
    public var pollInterval is Duration = 2s;
    var lastCheck is Long;

    function checkTimestamp to ()
    {
        if (monitorForChanges) {
            const now = java.lang.System.currentTimeMillis();
            if (now >= lastCheck + pollInterval.toMillis()) {
                lastCheck = now;
                if (url.startsWith("file:")) {
                    const u1 = new java.net.URL(url);
                    const f = new java.io.File(new java.net.URI(u1.getProtocol(), u1.getPath(), null));
                    fileTimestamp = f.lastModified();
                }
            }
        }
    }

    var fileTimestamp is Long;

    postinit {
        checkTimestamp();
    }

    function makeRootMonitor from (modelContent is ModelContent) to Node {
        Group {
            id: bind "{url} {new java.util.Date(fileTimestamp)}";
            content: bind modelContent.spatialRoot;
            override function update to ()
            {
                checkTimestamp();
                super.update();
            }
        }
    }

    public bound function getSpatialRoot to Node 
    {
        if (monitorForChanges) {
            makeRootMonitor(modelContent)
        } else modelContent.spatialRoot;
    }

    public bound function getResources to String[]  
    {
        modelContent.resources;
    }

    function toFilename from (u is String) to String
    {
        const u1 = new java.net.URL(u);
        new java.io.File(new java.net.URI(u1.getProtocol(), u1.getPath(), null)).getAbsolutePath();
    }

    function load from (url is String, effectLoader is CGEffectLoader, fileTimestamp is Long) to ModelContent {
        const loader = Loader {
            effectLoader: effectLoader;
            imageLoader: imageLoader;
            filename: toFilename(url);
        }
        if (not DISABLE_DEFORMERS) {
            loader.generateAllDeformers();
        }
        ModelContent {
            spatialRoot: loader.spatialRoot;
            temporalRoot: TimeGroup { id: url content: loader.clips }
            resources: foreach (x in loader.resources) x;
        }
    }
}